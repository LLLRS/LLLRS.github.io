<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱生活,爱柒柒</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://9191rs.me/"/>
  <updated>2019-03-28T13:35:09.857Z</updated>
  <id>https://9191rs.me/</id>
  
  <author>
    <name>LI Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="https://9191rs.me/posts/24142/"/>
    <id>https://9191rs.me/posts/24142/</id>
    <published>2019-03-28T13:26:07.000Z</published>
    <updated>2019-03-28T13:35:09.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dijkstra算法的特点"><a href="#Dijkstra算法的特点" class="headerlink" title="Dijkstra算法的特点"></a>Dijkstra算法的特点</h3><ul><li>Dijkstra算法使用了广度优先搜索解决赋权有向图最短路径问题。</li><li>Dijkstra算法的时间复杂度是n的平方。</li><li>Dijkstra算法只能适用于权值为正的情况下；如果权值存在负数，则不能使用。</li></ul><h3 id="Dijkstra算法的计算过程"><a href="#Dijkstra算法的计算过程" class="headerlink" title="Dijkstra算法的计算过程"></a>Dijkstra算法的计算过程</h3><p>&#8195;&#8195;1.设置两个顶点集S和T，集合S中存放已经找到最短路径的顶点，集合T中存放着当前还未找到最短的顶点；<br>&#8195;&#8195;2.初始状态下，集合S中只包含源点V1，T中为除了源点之外的其余顶点，此时源点到各顶点的最短路径为两个顶点所连的边上的权值，如果源点V1到该顶点没有边，则最小路径为无穷大；<br>&#8195;&#8195;3.从集合T中选取到源点V1的路径长度最短的顶点Vi加入到集合S中；<br>&#8195;&#8195;4.修改源点V1到集合T中剩余顶点Vj的最短路径长度。新的最短路径长度值为Vj原来的最短路径长度值与顶点Vi的最短路径长度加上Vi到Vj的路径长度值中的较小者；<br>&#8195;&#8195;5.不断重复步骤3、4，直至集合T的顶点全部加入到集合S中。</p><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class DijkstraDemo &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MAXVALUE = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span>[] path = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span>[] dis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">//定义图的临接矩阵，假设0为源点</span></span><br><span class="line">        <span class="built_in">int</span>[][] wt = &#123;&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,MAXVALUE,MAXVALUE&#125;,</span><br><span class="line">                &#123;MAXVALUE,<span class="number">0</span>,MAXVALUE,MAXVALUE,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;MAXVALUE,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,MAXVALUE&#125;,</span><br><span class="line">                &#123;MAXVALUE,MAXVALUE,MAXVALUE,<span class="number">0</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;MAXVALUE,MAXVALUE,MAXVALUE,MAXVALUE,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">int</span> n = wt.length;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Dijkstra(wt,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"源点0到"</span>+i+<span class="string">"的距离是： "</span> + dis[i] + <span class="string">" ;经过的路径是： "</span> + getPath(<span class="number">0</span>,i));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回为0到其他点的最短距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> Dijkstra(<span class="built_in">int</span> [][] wt,<span class="built_in">int</span> s,<span class="built_in">int</span> n)&#123;</span><br><span class="line"></span><br><span class="line">        dis = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        <span class="built_in">boolean</span>[] used = <span class="keyword">new</span> <span class="built_in">boolean</span>[n];</span><br><span class="line">        path = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        used[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        dis = wt[s];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            path[i] = s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">min</span> = MAXVALUE;</span><br><span class="line">            <span class="built_in">int</span> idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!used[j] &amp;&amp; dis[j] &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">                  idx = j;</span><br><span class="line">                  <span class="built_in">min</span> = dis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(idx == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            used[idx] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!used[j] &amp;&amp; wt[idx][j] != MAXVALUE &amp;&amp; <span class="built_in">min</span> + wt[idx][j] &lt; dis[j]) &#123;</span><br><span class="line">                    dis[j] = <span class="built_in">min</span> + wt[idx][j];</span><br><span class="line">                    path[j] = idx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> getPath(<span class="built_in">int</span> s,<span class="built_in">int</span> i) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.<span class="built_in">append</span>(i).<span class="built_in">append</span>(<span class="string">"&gt;--"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (path[i] != s)&#123;</span><br><span class="line">            i = path[i];</span><br><span class="line">            sb.<span class="built_in">append</span>(i).<span class="built_in">append</span>(<span class="string">"&gt;--"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.<span class="built_in">append</span>(s);</span><br><span class="line">        <span class="keyword">return</span> sb.<span class="built_in">reverse</span>().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><ul><li><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" target="_blank" rel="noopener">维基-Dijkstra算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Dijkstra算法的特点&quot;&gt;&lt;a href=&quot;#Dijkstra算法的特点&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra算法的特点&quot;&gt;&lt;/a&gt;Dijkstra算法的特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Dijkstra算法使用了广度优先搜索解
      
    
    </summary>
    
      <category term="最短路径" scheme="https://9191rs.me/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="Dijkstra" scheme="https://9191rs.me/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>Java实现常用的排序算法</title>
    <link href="https://9191rs.me/posts/27762/"/>
    <id>https://9191rs.me/posts/27762/</id>
    <published>2019-03-22T09:49:27.000Z</published>
    <updated>2019-03-22T12:18:52.801Z</updated>
    
    <content type="html"><![CDATA[<p>重新回顾下几种常见的排序算法。</p><p><img src="/posts/27762/20180415162735131.png" alt=""></p><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>特点：效率低，实现简单 </li><li>原理：将待排序列中最大的数往后冒泡，成为新的序列，重复以上操作直到所有元素排列完成</li><li>平均时间复杂度 O(n^2) ,最好O(n),最差O(n^2)</li><li>空间复杂度O(1) </li><li>稳定排序</li></ul><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>特点：效率低，容易实现。 </li><li>原理：每一趟从待排序序列选择一个最小的元素放到已排好序序列的首位，剩下的位待排序序列，重复上述步骤直到完成排序</li><li>平均时间复杂度 O(n^2) , 最优时间复杂度O (n^2),最坏时间复杂度 O(n^2)</li><li>空间复杂度O(1) </li><li>不稳定排序</li><li>比较次数与序列初始化状态无关</li></ul><p>代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">sort</span>(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[<span class="built_in">min</span>])</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line"></span><br><span class="line">        swap(nums,i,<span class="built_in">min</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>特点：效率低，容易实现。 </li><li>原理：将数组分为两部分，将后部分元素逐一插入前部分有序元素的适当位置</li><li>平均时间复杂度 O(n^2)，最好时间复杂度O(n), 最坏时间复杂度O(n^2)</li><li>空间复杂度O(1) </li><li>稳定排序</li></ul><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt; <span class="number">0</span> &amp;&amp; nums[j<span class="number">-1</span>] &gt; t; j--)</span><br><span class="line">            nums[j] = nums[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>特点：高效，时间复杂度为nlogn。 </li><li>原理：采用分治法的思想：首先设置一个中间值，然后以这个中间值为划分基准将待排序序列分成比该值大和比该值小的两部分，将这两部分再分别进行快速排序 直到序列只剩下一个元素</li><li>平均时间复杂度O(nlogn) , 最好时间复杂度O(nlogn), 最坏时间复杂度 O(n^2)</li><li>空间复杂度O(logn) </li><li>不稳定排序</li></ul><p>代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="keyword">sort</span>(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> p = partition(nums,l,r);</span><br><span class="line">       <span class="keyword">sort</span>(nums,l,p-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">sort</span>(nums,p+<span class="number">1</span>,r);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> partition(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> v = nums[l];  <span class="comment">//标定点为第一个，也可以随机在[l,r]选择一个</span></span><br><span class="line">       <span class="keyword">int</span> j = l;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=l+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &lt; v)</span><br><span class="line">               swap(nums,++j,i);</span><br><span class="line"></span><br><span class="line">       swap(nums,l,j);</span><br><span class="line">       <span class="keyword">return</span> j;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//三路快排</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> sort3(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> v = nums[l];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> lt = l,gt = r+<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> i = l+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(i &lt; gt)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &lt; v)</span><br><span class="line">               swap(nums,i++,++lt);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; v)</span><br><span class="line">               swap(nums,i,--gt);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               i++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       swap(nums,l,lt);</span><br><span class="line">       <span class="keyword">sort</span>(nums,l,lt-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">sort</span>(nums,gt,r);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>平均时间复杂度O(nlogn) , 最好时间复杂度O(nlogn), 最坏时间复杂度O(nlgn)</li><li>空间复杂度O(n) </li><li>稳定排序</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span>[] aux = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">sort</span>(<span class="built_in">int</span>[] nums,<span class="built_in">int</span> l ,<span class="built_in">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;  <span class="comment">//这块有一个优化就是对于小规模数组，用插入效果更好</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">sort</span>(nums,l,m);</span><br><span class="line">    <span class="built_in">sort</span>(nums,m+<span class="number">1</span>,r);</span><br><span class="line">    merge(nums,l,m,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> merge(<span class="built_in">int</span>[] nums,<span class="built_in">int</span> l,<span class="built_in">int</span> m,<span class="built_in">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        aux[i] = nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> i = l, j = m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> k = l ; k &lt;= r; k ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>( i &gt; m )</span><br><span class="line">            nums[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( j &gt; r )</span><br><span class="line">            nums[k] = aux[i++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( aux[i] &lt; aux[j])</span><br><span class="line">            nums[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[k] = aux[j++];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>时间复杂度O(nlogn) </li><li>空间复杂度 O(1) O(1)O(1)</li><li>不稳定排序</li></ul><p>代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">sort</span>(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">//初始化一个最大堆</span></span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">cursor</span> = nums.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="built_in">cursor</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxHeap(nums, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        swap(nums,<span class="number">0</span>,i);  <span class="comment">// 将最大的放到数组末尾</span></span><br><span class="line">        maxHeap(nums,i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大堆 root = i, left = 2*i+1, right = 2*i+2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> maxHeap(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> <span class="built_in">size</span>, <span class="built_in">int</span> root) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> left = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> right = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> t = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left &lt; <span class="built_in">size</span> &amp;&amp; nums[left] &gt; nums[t])</span><br><span class="line">        t = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="built_in">size</span> &amp;&amp; nums[right] &gt; nums[t])</span><br><span class="line">        t = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t != root)&#123;   <span class="comment">// 子节点比根节点大</span></span><br><span class="line">        swap(nums,root,t);</span><br><span class="line">        maxHeap(nums,<span class="built_in">size</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><ul><li><a href="https://blog.csdn.net/qq_39098813/article/details/79950444" target="_blank" rel="noopener">动画演示</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重新回顾下几种常见的排序算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/27762/20180415162735131.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="排序" scheme="https://9191rs.me/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="排序" scheme="https://9191rs.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>抢红包算法</title>
    <link href="https://9191rs.me/posts/15969/"/>
    <id>https://9191rs.me/posts/15969/</id>
    <published>2019-03-01T07:15:14.000Z</published>
    <updated>2019-03-19T07:31:01.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二倍均值法"><a href="#二倍均值法" class="headerlink" title="二倍均值法"></a>二倍均值法</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p> 假设人数为 N，钱数为 M，且都为整数。每次分配的红包为 [0, 2*M/N] 之间的某个随机数，那么分配的红包的均值为 M/N。这个公式，保证了每次随机金额的平均值是相等的，不会因为抢红包的先后顺序而造成不公平。举个例子：假设有10个人，红包总额100元。</p><ul><li>100/10X2 = 20, 所以第一个人的随机范围是（0，20 )，平均可以抢到10元。</li><li>假设第一个人随机到10元，那么剩余金额是100-10 = 90 元。90/9X2 = 20, 所以第二个人的随机范围同样是（0，20 )，平均可以抢到10元。</li><li>假设第二个人随机到10元，那么剩余金额是90-10 = 80 元。80/8X2 = 20, 所以第三个人的随机范围同样是（0，20 )，平均可以抢到10元。</li><li>以此类推，每一次随机范围的均值是相等的。</li></ul><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; generatePacketsByDoubleMean(<span class="built_in">int</span> people, <span class="built_in">int</span> money) &#123;</span><br><span class="line">    List&lt;Integer&gt; packets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Random <span class="built_in">random</span> = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">while</span> (people &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> p = <span class="built_in">random</span>.nextInt(<span class="number">2</span> * money / people);</span><br><span class="line">        packets.<span class="built_in">add</span>(p);</span><br><span class="line">        money -= p;</span><br><span class="line">        people--;</span><br><span class="line">    &#125;</span><br><span class="line">    packets.<span class="built_in">add</span>(money);</span><br><span class="line"></span><br><span class="line">    Collections.shuffle(packets); <span class="comment">//更随机</span></span><br><span class="line">    <span class="keyword">return</span> packets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段切割法"><a href="#线段切割法" class="headerlink" title="线段切割法"></a>线段切割法</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>如果把红包总金额想象成一条很长的线段，而每个人抢到的金额，则是这条主线段所拆分出的若干子线段。每一条子线段的长度可以由“切割点”来决定，当N个人一起抢红包的时候，就需要确定N-1个切割点。因此，当N个人一起抢总金额为M的红包时，只需要做N-1次随机运算，以此确定N-1个切割点。随机的范围区间是（1， M）。当所有切割点确定以后，子线段的长度也随之确定。这样每个人来抢红包的时候，只需要顺次领取与子线段长度等价的红包金额即可。</p><h4 id="Java代码实现-1"><a href="#Java代码实现-1" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; generatePacketsByLineCutting(<span class="built_in">int</span> people, <span class="built_in">int</span> money) &#123;</span><br><span class="line">    List&lt;Integer&gt; packets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Random <span class="built_in">random</span> = <span class="keyword">new</span> Random();</span><br><span class="line">    Set&lt;Integer&gt; points = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="comment">//利用TreeSet处理重复的随机切割点</span></span><br><span class="line">    <span class="keyword">while</span> (points.<span class="built_in">size</span>() &lt; people - <span class="number">1</span>) &#123;</span><br><span class="line">        points.<span class="built_in">add</span>(<span class="built_in">random</span>.nextInt(money - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    points.<span class="built_in">add</span>(money);</span><br><span class="line">    <span class="built_in">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> p : points) &#123;</span><br><span class="line">        packets.<span class="built_in">add</span>(p - pre);</span><br><span class="line">        pre = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   Collections.shuffle(packets); <span class="comment">//更随机</span></span><br><span class="line">   <span class="keyword">return</span> packets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><ul><li><a href="https://blog.csdn.net/qq_35393472/article/details/80073948" target="_blank" rel="noopener">Java抢红包代码实现及二倍均值法分析 </a></li><li><a href="https://blog.csdn.net/bjweimengshu/article/details/80045958" target="_blank" rel="noopener">漫画：如何实现抢红包算法？</a></li><li><a href="https://www.zhihu.com/question/22625187" target="_blank" rel="noopener">微信红包的随机算法是怎样实现的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二倍均值法&quot;&gt;&lt;a href=&quot;#二倍均值法&quot; class=&quot;headerlink&quot; title=&quot;二倍均值法&quot;&gt;&lt;/a&gt;二倍均值法&lt;/h3&gt;&lt;h4 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;
      
    
    </summary>
    
      <category term="抢红包" scheme="https://9191rs.me/categories/%E6%8A%A2%E7%BA%A2%E5%8C%85/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="抢红包" scheme="https://9191rs.me/tags/%E6%8A%A2%E7%BA%A2%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>两道经典的动态规划问题</title>
    <link href="https://9191rs.me/posts/43664/"/>
    <id>https://9191rs.me/posts/43664/</id>
    <published>2019-01-17T11:17:04.000Z</published>
    <updated>2019-01-17T14:26:34.621Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划的题目。对于可用动态规划求解的问题，一般有两个特征：①最优子结构；②重叠子问题</p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个字符串，求解这两个字符串的最长公共子序列（Longest Common Sequence）。</p><h4 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h4><p>dp[i][j]：它是指word1[0…i]和word2[0…j]的最长公共子序列的长度</p><ul><li><p>如果word1[i]和word2[j]相等，则dp[i][j] = dp[i-1][j-1]</p></li><li><p>如果word1[i]和word2[j]不相等相等，则要分情况讨论</p><ul><li>dp[i][j] = dp[i-1][j]</li><li>dp[i][j] = dp[i][j-1]</li></ul></li></ul><h4 id="Java参考代码"><a href="#Java参考代码" class="headerlink" title="Java参考代码"></a>Java参考代码</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  public static int LCS(String str1, String str2)&#123;</span><br><span class="line">      int<span class="string">[]</span><span class="string">[]</span> dp = new int<span class="string">[str1.length() + 1]</span><span class="string">[str2.length() + 1]</span>;</span><br><span class="line">//初始条件</span><br><span class="line">      for(int row = <span class="number">0</span>; row &lt;= str1.length(); row++)</span><br><span class="line">          dp<span class="string">[row]</span><span class="string">[0]</span> = <span class="number">0</span>;</span><br><span class="line">      for(int column = <span class="number">0</span>; column &lt;= str2.length(); column++)</span><br><span class="line">          dp<span class="string">[0]</span><span class="string">[column]</span> = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      for(int i = <span class="number">1</span>; i &lt;= str1.length(); i++)</span><br><span class="line">          for(int j = <span class="number">1</span>; j &lt;= str2.length(); j++)</span><br><span class="line">          &#123;</span><br><span class="line">              if(str1.charAt(i-<span class="number">1</span>) == str2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                  dp<span class="string">[i]</span><span class="string">[j]</span> = dp<span class="string">[i-1]</span><span class="string">[j-1]</span> + <span class="number">1</span>;</span><br><span class="line">              else if(dp<span class="string">[i]</span><span class="string">[j-1]</span> &gt; dp<span class="string">[i-1]</span><span class="string">[j]</span>)</span><br><span class="line">                  dp<span class="string">[i]</span><span class="string">[j]</span> = dp<span class="string">[i]</span><span class="string">[j-1]</span>;</span><br><span class="line">              else</span><br><span class="line">                  dp<span class="string">[i]</span><span class="string">[j]</span> = dp<span class="string">[i-1]</span><span class="string">[j]</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      return dp<span class="string">[str1.length()]</span><span class="string">[str2.length()]</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="最小编辑距离"><a href="#最小编辑距离" class="headerlink" title="最小编辑距离"></a>最小编辑距离</h3><p>求两个字符串的编辑距离，将一个字符串变成另外一个字符串所用的最少操作数，每次只能增加、删除或者替换一个字符。<br><img src="/posts/43664/1.jpg" alt=""></p><p><strong>两个字符串的编辑距离越小，说明两个字符串越相似！</strong></p><h4 id="DP解法-1"><a href="#DP解法-1" class="headerlink" title="DP解法"></a>DP解法</h4><p>dp[i][j]：它是指word1[0…i]和word2[0…j]的编辑距离</p><ul><li><p>如果word1[i]和word2[j]相等，则dp[i][j] = dp[i-1][j-1]</p></li><li><p>如果word1[i]和word2[j]不相等相等，则要分情况讨论</p><ul><li>添加： 也就是在word1[i]后加一个字符x使得word1[0…i] + x和word2[0…j]相等，则dp[i][j]  =  dp[i][j-1] + 1</li><li>删除：也就是在word1[i]后删除第i处字符x使得word1[0…i-1] 和word2[0…j]相等，则dp[i][j]  =  dp[i-1][j] + 1</li><li>修改：也就是在word1[i]后修改第i处的字符使得word1[0…i] 和word2[0…j]相等，则dp[i][j]  =  dp[i-1][j-1] + 1</li></ul></li></ul><h4 id="Java参考代码-1"><a href="#Java参考代码-1" class="headerlink" title="Java参考代码"></a>Java参考代码</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public  int minDistance(String w1, String w2) &#123;</span><br><span class="line"></span><br><span class="line">     int r = w1.length();</span><br><span class="line">     int c = w2.length();</span><br><span class="line"></span><br><span class="line">     int<span class="string">[]</span><span class="string">[]</span> dp = new int<span class="string">[r+1]</span><span class="string">[c+1]</span>;</span><br><span class="line"></span><br><span class="line">     for(int i=<span class="number">0</span>;i&lt;=c;i++)</span><br><span class="line">         dp<span class="string">[0]</span><span class="string">[i]</span> = i; //dp<span class="string">[i]</span><span class="string">[0]</span>就是，w1长度为i，w2为空时，w1需要删除i个字符才能转换成空</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     for(int i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">         dp<span class="string">[i]</span><span class="string">[0]</span> = i;  //dp<span class="string">[0]</span><span class="string">[j]</span>就是w1为空，w2长度为j的情况，w1需要添加j个字符转换成w2</span><br><span class="line">         for(int j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">             if(w1.charAt(i-<span class="number">1</span>)==w2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                 dp<span class="string">[i]</span><span class="string">[j]</span> = dp<span class="string">[i-1]</span><span class="string">[j-1]</span>;</span><br><span class="line">             else</span><br><span class="line">                 dp<span class="string">[i]</span><span class="string">[j]</span> = Math.min(dp<span class="string">[i-1]</span><span class="string">[j-1]</span>,Math.min(dp<span class="string">[i-1]</span><span class="string">[j]</span>, dp<span class="string">[i]</span><span class="string">[j-1]</span>)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return dp<span class="string">[r]</span><span class="string">[c]</span>;         </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="基于上述代码的一种改进"><a href="#基于上述代码的一种改进" class="headerlink" title="基于上述代码的一种改进"></a>基于上述代码的一种改进</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span> minDistance(<span class="keyword">String</span> w1, <span class="keyword">String</span> w2) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> r = w1.length();</span><br><span class="line"> <span class="keyword">int</span> c = w2.length();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[c+<span class="number">1</span>];         </span><br><span class="line"> <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=c;i++)</span><br><span class="line"> dp[i] = i;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line"> <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[c+<span class="number">1</span>];</span><br><span class="line"> temp[<span class="number">0</span>] = i;</span><br><span class="line"> <span class="built_in">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line"> <span class="built_in">if</span>(w1.charAt(i<span class="number">-1</span>)==w2.charAt(j<span class="number">-1</span>))</span><br><span class="line"> temp[j] = dp[j<span class="number">-1</span>];</span><br><span class="line"> <span class="built_in">else</span></span><br><span class="line"> temp[j] = Math.<span class="built_in">min</span>(temp[j<span class="number">-1</span>],Math.<span class="built_in">min</span>(dp[j<span class="number">-1</span>], dp[j])) + <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// temp[j-1] 添加  dp[j-1] 修改   dp[j] 删除</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> dp = temp;</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="built_in">return</span> dp[c];         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><ul><li><a href="https://www.cnblogs.com/masterlibin/p/5785092.html" target="_blank" rel="noopener">EditDistance,求两个字符串最小编辑距离，动态规划</a></li><li><a href="https://www.cnblogs.com/hapjin/p/5572483.html" target="_blank" rel="noopener">求解两个字符串的最长公共子序列</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划的题目。对于可用动态规划求解的问题，一般有两个特征：①最优子结构；②重叠子问题&lt;/p&gt;
&lt;h3 id=&quot;最长公共子序列&quot;&gt;&lt;a href=&quot;#最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列&quot;&gt;&lt;/a&gt;最长公共子序列&lt;/h3&gt;&lt;p
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>写给实验室的下一代By刘泽豪真讨厌</title>
    <link href="https://9191rs.me/posts/53466/"/>
    <id>https://9191rs.me/posts/53466/</id>
    <published>2019-01-10T09:46:46.000Z</published>
    <updated>2019-01-10T09:49:54.846Z</updated>
    
    <content type="html"><![CDATA[<p>在CSDN上看到一篇文章，想了想自己的行为真的，个中滋味，自己感受吧！</p><p>原文连接：<a href="https://blog.csdn.net/liu506039293/article/details/51925043" target="_blank" rel="noopener">https://blog.csdn.net/liu506039293/article/details/51925043</a> </p><h3 id="保护好你的兴趣。"><a href="#保护好你的兴趣。" class="headerlink" title="保护好你的兴趣。"></a>保护好你的兴趣。</h3><p> 据我观察，但凡在计算机方面有所建树，能赚到大钱的人，有一个算一个都是对计算机有浓厚兴趣的人。所以我认为兴趣是第一位的。学长们虚长几岁，能告诉你未来能发展的方向，能告诉你一个技术点如何解决，但是每个人的生活经历不同，在兴趣这件事上只有你自己去寻找。</p><p><strong>对了，我说的是“寻找”。</strong></p><p>中式教育是很忽视兴趣这个东西的，多年的实用主义加计划表式的学习模式使很多人不懂什么叫做兴趣，而正是因为兴趣的缺失越来越多的人空虚，迷茫，陷入虚无主义的深渊中。因为失去了，所以要寻找。仔细想想这么多专业，你为什么愿意报计算机？是喜欢玩游戏？是想当黑客？是想成为极客拥有独门绝技？也许你苦恼地说专业调剂，那一定是天公作美o(^▽^)o。</p><p>当然，既然说了寻找，那自然是原本就有才能寻找。</p><p>如果你现在脑子里空空，当然啥寻找不到。为啥会没兴趣呢？我分析这通常有2点心理，一是我了解过计算机但我就是对着复杂玩意儿不感兴趣，我喜欢简单的生活。如果你是这种人我劝你还是不要学了，学计算机你会活的很累。二是我没了解过太多计算机的东西，我也没想过了解。对于你呢，笛卡儿曾经说过‘没有无缘无故的恨，也没有无缘无故的爱。’狗血电视剧里经常有这种桥段，子女被父母包办婚姻，都会说‘我都没见过这个人，我怎么喜欢他’，是啊，你都没了解过计算机你怎么知道你没兴趣？如果你想了解我建议你去知乎找找‘黑客入侵美女邻居电脑’‘美国五角大楼被中国黑客攻破’这类的玩意儿，哈哈我相信你会有兴趣。</p><p>要知道寻找兴趣只是第一步，更为关键的其实是保护兴趣。你或许会觉得我在扯淡，有兴趣就有兴趣，没兴趣就没兴趣，‘保护兴趣’是什么鬼？确实，在这一点上我和大多数人的观点不一样。我认为兴趣是很脆弱的，尤其是你刚刚有那么点兴趣的时候，那时，他就像是一个婴儿，手无缚鸡之力，稍稍的风吹草动他就消失了。保护和培养至关重要。其次，兴趣并不单单是一个加法，同样会做减法。兴趣的生存条件极为苛刻，你需要足够时间，足以为生的金钱，足够的社群，足够的好奇心，兴趣才能成长，缺失任何一项兴趣就会退化。幸运的是你是大学生，前三项起码4年中你始终满足。反过来看，倘若你在大学中都找不到兴趣，那一辈子你可能都很难有感兴趣的东西。</p><p>谈到保护和培养自己的兴趣，我认为，兴趣并非完全客观不由自主的，相反，我认为兴趣是相对可控的，主观意志可以影响的。这也就给了自我培养兴趣的基本条件，我不知道到你是否有这样的经历，跟你的伙伴聊起一部你极为喜欢的剧的时候，两个人都兴趣盎然，聊的昏天黑地甚至忘了时间。聊完之后更加感兴趣，根本停不下来，不碎觉也要看剧。这就是我所谈的培养兴趣的第一点，找一个志同道合的社团，实验室就不错，希望你能找到兴趣相投的伙伴。</p><p>不要单干，不要单干，不要单干，重要的事说三遍，单干对你的兴趣来说是致命的，两年来我看过太多以为自己学就能有所成就的人，这些人大多极为有天赋，但也或许正是由于他们的天赋让他们自以为可以孤胆闯天下，然而事实证明他们是错的。他们中的百分之九十都在下定决心单干的一个月之内放弃了，而剩下的百分之十，真的是天赋异禀之人，毅力，决心，天资，兴趣无不是上上之选，然而观察至今我认为他们所取得的成就远不符合他们的天才。          </p><p>第二不要和圈子外的人谈程序，《哈利波特》中将不会使用魔法的人叫麻瓜，其实对我们来说实验室外的家伙都可以叫麻瓜，别和那帮家伙谈程序，即使你觉得那程序简直妙的天下无双，人家也只会呵呵。这挺有挫败感的，真的，别问我怎么知道的，麻瓜懂个屁啊。</p><p>第三别和哑炮学程序。《哈利波特》中还有一种让人叫哑炮，这种人具有巫师血脉却不会使用魔法。我把这个词引申到这来，指那种会编一些程序，但对此并无兴趣，只以此为生之人。这种让人哪里最多？培！训！机！构！这也是我极其反对在初始阶段就去培训机构学习的原因之一，他们只会告诉你这个怎么弄就行，那个怎么弄就好，至于为什么，你别管。他们会用毕业后的好前途，好钱途来诱惑你，先不管能不能做到，但我告诉你，他们教会你更多的是写软件有多么多么的无趣。</p><p>这会涉及到一个问题，什么样的老师是哑炮，什么样的老师是真正的好老师？如果要给好老师下一个定义真的很难，个体的差异性太大。但是我们可以找到一些共同的特点，你看他上课就行了，一个老师如果按部就班对着ppt读，哑炮。如果，你站在门外都可以感受到他充沛的热情洋溢的教学语调，不管水平如何，推开门进去，放心，你可以学到东西的。对于哑炮来说，你可千万别以为上课不听他就毒害不到你了，我强烈建议你去都不要去，那种枯燥的氛围足以抹杀你那点点好奇心。我说的就不仅仅是软件学习了，所有学科都是如此。</p><h3 id="不要用有用无用衡量你学的东西"><a href="#不要用有用无用衡量你学的东西" class="headerlink" title="不要用有用无用衡量你学的东西"></a>不要用有用无用衡量你学的东西</h3><p>中国人的现实主义思想如此深入人心，以至于每每我向别人解释某门语言，某门技术的时候，下一句就是有什么用？用？没用。没有就是有用。</p><p>这不是绕口令，记得《庄子》中有这么一个故事，大意是庄子和一个木匠在路上走，一颗巨大的树木挡住了去路，庄子问木匠“请问师傅，如此好大木材，怎一直无人砍伐？以至独独长了几千年？”木匠似对此树不屑一顾，道：“这何足为奇？此树是一种不中用的木材。用来作舟船，则沉于水；用来作棺材，则很快腐烂；用来作器具，则容易毁坏；用来作门窗，则脂液不干；用来作柱子，则易受虫蚀，此乃不成材之木。不材之木也，无所可用，故能有如此之寿。”说着，树变成了一个人，笑道“我是无用，得以千年成神”。</p><p>如今，你到了选择的时刻，实验室要求你分方向，你可千万要明白无用之用的道理。</p><p>举个现代的例子，苹果系统的优美字体被认为是ios得以取得巨大成功的原因之一，而据乔布斯本人回忆，这和乔在大学时学过的字体课有密不可分的关系。请问当乔上这样一门偏艺术类的课程时他怎么会想到这门课会如此深刻的影响他，对未来的ios有这么重大的作用呢？</p><p>无用的未必无用，现在看起来很有用的未必有用。所以有用无用是一件在未来看才会看得清楚的事情，判断这样一件事情事实上是超越了人类自身的能力的。可惜大多数人不懂这一点，纠结于现在的有用无用，而成为鼠目寸光之人。</p><p>所以无论你选择的是安卓开发还是web开发你可千万不要纠结于学这个有什么用。如果你一定这么问，我告诉你，没用。你会说难道学了我不会找到好工作吗？我倾向于你能不能找到好工作和你现在学了多少没什么太大联系。</p><p>你先别急着反驳我，我慢慢说来。首先，你不可能通过公平校招的手段找到好工作。请你思考一下企业为什么要校招？公司没人了么？是一个原因，但不全是。主要原因是空缺的位置不是好位置，难道不是吗？如果有个好位置，活又轻松价钱又高，他们公司内部早就抢疯了轮得到校招？所以，校招的职位一定不是好职位，有可能这个公司的工作比那个公司好，但在公司内部你一定是最差的位置，好位置轮不到你坐。当然，父母帮忙另说，但也反驳不了我，你现在学不学和你父母帮不帮没有必然联系。</p><p>另一个问题，找不找得’到‘工作跟你学不学更加没啥关系。市场讲究的是供求关系，讲究的是相对优势而不是绝对优势。换句人话说，你找得到找不到工作取决于一是今年行业好坏，二是今年毕业人数，三是你愿不愿意把自己的价格压得足够低。再换句话说，你什么都不学，只要你价钱足够低，相对优势足够明显一样找得到工作。</p><p>所以找不找得到工作?跟你无关，你要想找一定有，市场会给你。找得到找不到好工作?做梦，找不到。就是这么回事，我说了这不是鸡汤文，现实就是这么残酷，你的努力和你的成就并非线性关系。那现在学毫无作用？又不是，无用即有用嘛，刚刚说的是相对公平的校招，如果你现阶段的努力换来了并非那么公平的招聘，情况又有所不同。</p><p>此种种妙处堪称玄学，《道德经》说玄之又玄，众妙之门。有的人以为按照自己的想法或别人提供的路线图按部就班的学一遍就能找个好工作走上人生巅峰了，有这种想法的人尤以上面提到的独行侠为多，错，大错特错。每个人的路都是不同的，走在这条路上的他成功了不代表你能成功，今天他走这条路成功了不代表明天走也能成。只有走一步看一步才可能找到众妙之门啊。而在此过程中，与其自己骗自己想什么有用无用，把自己骗得团团转，不敢远离所谓标准成功道路半步，不如照着兴趣走，即使一无所获起码过程快乐嘛，不是吗？所以兴趣的重要性再怎么强调也不为过。</p><p>那么，到底选择安卓好还是web好呢？且看下一条。</p><h3 id="不要走容易走的道路"><a href="#不要走容易走的道路" class="headerlink" title="不要走容易走的道路"></a>不要走容易走的道路</h3><p>安卓，web。实验室有两个方向供你选择，其实在我选啥看来无甚关系，都行。</p><p><div align="center"><img src="/posts/53466/1.jpg" alt=" "></div></p><p>这是一张著名的图，讲的是计算机系统结构，无论你选哪个，其实可以看到你会学的大部分东西其实都处在右上角那个小角落里，勉强向左移动那么一丢丢碰到数据库，碰到一丢丢网络。对整个计算机体系而言选哪个都是无足轻重的。如果把整个计算机体系比作一棵大树的话，这两个方向不过是大树上的两片叶子，仅此而已。</p><p>那为什么还要学呢？我认为这是一个入口，这是揭开笼罩计算机这个巨大黑幕下面真相的一条快速通道，学习了这些你才能真正理解什么是《计算机组成原理》，是什么《数据库原理》，什么是《计算机网络》，什么是《操作系统》，而这些你的同学以为的和高数，物理没什么区别的无聊的课才是计算机这棵大树的树枝和隐藏在烟雾中的庞大躯干啊。你所在实验室中所学的能让你把这些都粘合起来，从而对计算机一窥全貌。这也是为什么很多企业宁可要看似啥也不会的毕业生也不要培训机构三四个月培养出来的‘能干活’的人。经历系统培训的毕业生即使学的再差其对计算机的理解也非门外汉可比的。</p><p>而另一个原因是，你要明白你能三四个月学出来，别人也能三四个月学出来，这是没有什么优势可言的。你要知道，市场上无论什么东西一多就是垃圾，换成个体的角度来看也可以说但凡速成的东西千万不要当成自己的依仗。</p><p>所以根据这种想法，我当初就选了web，不是别的什么原因，安卓比web简单。简单及可以速成，即基本是垃圾，看看现在市场上安卓程序员的数量你就明白了。当然我不绝不是说选安卓不好，一样好，一样可以由此入门。但是请你明白你的优势在哪里。你能想到要参加实验室不可否认你一定是个聪明人，聪明人的优势在于聪明，学东西比别人快，比别人深。如果你天天跟别人竞争满分80 的东西，你79，他笨点也有75，体现不出你的优势嘛。要体现你的竞争力你就得选择难的。</p><p>如果你没看我的文章，我想你一定选安卓了，可是你仔细想想。是，我明白你为啥选安卓，因为每个人都有手机，天天玩有亲切感。可是你了解web嘛？你都没了解你怎么知道这不是你的菜？可千万别以为什么html,css这些就是web,web可没这么low啊，就这么说，想理解黑客，想更清楚的明白什么是计算机，首选web而不是安卓。多说一句，现在大学课程基本都是默认x86架构下的,啥编译原理，操作系统。安卓平台可是arm架构，虽说高级编程无视底层，但学习本来就基于x86上的web编程不是对你理解计算机是更加有好处的事情嘛？  </p><p>不知不觉写了3个小时，近五千字了，边写边想其实自己也挺感慨的。不知不觉两年已经过去，在此过程中看到了太多的‘伤仲永’式的人物，所以写了这些。人活着，就怕习惯，懒懒地过着单调重复的生活，在‘超神’中感受着虚无和颓废。唯有找到自己所喜爱的事物才得以享受一把充实，这或许是大学和过去的生活最不同的地方吧。过去我从没想过忙的跟狗一样是一种享受；从未想过我自己做选择，自己承担后果。多了的是自由，又何尝不是烦恼？</p><p>希望你能够找到自己所爱，不单单程序，人，也不错。。。而当有一天你会发现你已然满足了当初的所有好奇，再回过头想想你所喜爱的到底是什么？一定不是计算机本身了，你明白那就是一推电路，一定不是编程了，好几个小时一动不动有啥意思嘛。或许是计算机背后所代表的某种与你灵魂深处有强烈共鸣的东西吧。那种自由的精神？那种无法无天的快感？那种掌控全局的傲然？或许吧。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在CSDN上看到一篇文章，想了想自己的行为真的，个中滋味，自己感受吧！&lt;/p&gt;
&lt;p&gt;原文连接：&lt;a href=&quot;https://blog.csdn.net/liu506039293/article/details/51925043&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="心得感悟" scheme="https://9191rs.me/categories/%E5%BF%83%E5%BE%97%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="心得感悟" scheme="https://9191rs.me/tags/%E5%BF%83%E5%BE%97%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>网站攻击与信息加密技术</title>
    <link href="https://9191rs.me/posts/21221/"/>
    <id>https://9191rs.me/posts/21221/</id>
    <published>2018-12-04T08:54:28.000Z</published>
    <updated>2018-12-04T09:54:14.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网站攻击"><a href="#网站攻击" class="headerlink" title="网站攻击"></a>网站攻击</h2><p><strong>常见的网站攻击手段有XSS攻击、SQL注入攻击、CSRF攻击等。</strong></p><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>XSS攻击全称为跨站脚本攻击(Cross Site Scripting)。它的原理是攻击者向有XSS漏洞的网站中插入恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。比如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。<br> XSS的攻击方式</p><ul><li><strong>反射式：</strong>点击恶意URL，恶意脚本会执行。</li><li><strong>持久性XSS攻击：</strong>黑客提交含有恶意脚本的请求，保存在被攻击的web站点的数据库中，用户浏览网页的时候，恶意脚本被包含在正常页面中，达到攻击的目的。</li></ul><p><strong>XSS的防御措施</strong></p><ul><li><strong>编码：</strong>对用户输入的数据进行HTML Entity编码 </li><li><strong>过滤：</strong>移除用户上传的DOM属性，如onerror等，移除用户上传的style节点，script节点，iframe节点等。</li><li><strong>校正：</strong>避免直接对HTML Entity编码，使用DOM Prase转换，校正不配对的DOM标签。</li></ul><h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><p>SQL注入攻击是发生于<strong>应用程序与数据库层的安全漏洞</strong>。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了字符检查，那么这些注入进去的恶意指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。</p><p>例如某登录验证的SQL查询代码为</p><blockquote><p>SELECT * FROM users WHERE (name = ‘“ + userName + “‘) and (pw = ‘“+ passWord +”‘);</p></blockquote><p>恶意填入 <strong>userName = “1’ OR ‘1’=’1”</strong> 与 <strong>passWord = “1’ OR ‘1’=’1”</strong> 时，将导致原本的SQL字符串被填为</p><blockquote><p>SELECT * FROM users WHERE (name = ‘1’ OR ‘1’=’1’) and (pw = ‘1’ OR ‘1’=’1’);</p></blockquote><p>也就是实际上运行的SQL命令会变成下面这样的</p><blockquote><p>SELECT * FROM users;</p></blockquote><p>因此达到无账号密码，亦可登录网站。所以SQL注入攻击被俗称为黑客的填空游戏。</p><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF全称为跨站请求伪造（Cross-site request forgery），是一种网络攻击方式，也被称为 one-click attack 或者 session riding。</p><p><img src="/posts/21221/1543916810097.png" alt="Alt text"><br>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ul><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ul><p><strong>CSRF攻击是源于WEB的隐式身份验证机制。</strong>WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</p><p><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/" target="_blank" rel="noopener">CSRF 攻击的应对之道</a></p><h2 id="信息加密技术"><a href="#信息加密技术" class="headerlink" title="信息加密技术"></a>信息加密技术</h2><p><strong>常见的信息加密技术分为三类：单项散列加密、对称加密和非对称加密。</strong></p><h3 id="单项散列加密"><a href="#单项散列加密" class="headerlink" title="单项散列加密"></a>单项散列加密</h3><p>单项散列加密是指通过对不同输入长度的信息进行散列计算，得到固定长度的输出，这个散列计算过程是单向的。为了加强单向散列计算的安全性，可以给散列算法加盐，salt相当于加密的密钥，增加破解难度。</p><p>单向散列函数特点：</p><ul><li>对任意长度的消息散列值是定长的。</li><li>散列计算速度快，非常高效。</li><li>明文不同，散列加密后的密文一定不同；明文相同，散列加密后密文一定相同。</li><li>具备单向性，无法逆推计算。</li></ul><p>单向散列的经典算法有 MD5、SHA、RSA-SHA等。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p><p>对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1 bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1 MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。密钥的大小既要照顾到安全性，也要照顾到效率，是一个trade-off。</p><p>常见的对称加密算法：DES，AES，3DES等。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥（公钥加密，私钥解密；私钥加密，公钥解密）。常见的非对称加密算法加密和签名算法：RSA、DSA等。</p><p>由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当需要加密大量的数据时，一般采用对称加密算法，提高加解密速度。 对称加密算法不能实现签名，因此签名只能非对称算法。</p><p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。 根据对称加密和非对称加密的特点，在实际的操作过程中，采用的方式是：<strong>采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</strong></p><hr><p>参考链接</p><ul><li><a href="https://www.cnblogs.com/zfxJava/p/5295957.html" target="_blank" rel="noopener">数字签名、数字证书、对称加密算法、非对称加密算法、单向加密（散列算法） </a></li><li><a href="https://www.cnblogs.com/jfzhu/p/4020928.html" target="_blank" rel="noopener">对称加密与非对称加密</a></li><li><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网站攻击&quot;&gt;&lt;a href=&quot;#网站攻击&quot; class=&quot;headerlink&quot; title=&quot;网站攻击&quot;&gt;&lt;/a&gt;网站攻击&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;常见的网站攻击手段有XSS攻击、SQL注入攻击、CSRF攻击等。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="分布式" scheme="https://9191rs.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式学习之一致性Hash算法</title>
    <link href="https://9191rs.me/posts/13533/"/>
    <id>https://9191rs.me/posts/13533/</id>
    <published>2018-11-30T08:59:44.000Z</published>
    <updated>2018-11-28T13:25:09.892Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法背景"><a href="#算法背景" class="headerlink" title="算法背景"></a>算法背景</h3><p>在分布式系统中，常常需要使用缓存，而且通常是集群，访问缓存和添加缓存都需要一个 hash 算法来寻找到合适的 Cache 节点。 如何将数据均匀的分散到各个节点中，并且尽量的在加减节点时能使受影响的数据最少。</p><p>一致性哈希算法在1997年由麻省理工学院的Karger等人在解决分布式Cache中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得DHT可以在P2P环境中真正得到应用。</p><h3 id="余数hash"><a href="#余数hash" class="headerlink" title="余数hash"></a>余数hash</h3><p>可以将传入的 Key 按照 index = hash(key) % N 这样来计算出需要存放的节点。其中 hash 函数是一个将字符串转换为正整数的哈希映射方法，N 就是节点的数量。这样可以满足数据的均匀分配，但是这个算法的容错性和扩展性都较差。比如增加或删除了一个节点时，所有的 Key 都需要重新计算，显然这样成本较高，为此需要一个算法满足分布均匀同时也要有良好的容错性和拓展性。</p><p>如果原来有HashCode为0~19的20个数据，那么：<br><img src="/posts/13533/1.jpg" alt=""></p><p>如果扩容到4台，加粗标红的表示命中：<br><img src="/posts/13533/2.jpg" alt=""></p><p>如果扩容到20+的台数，只有前三个HashCode对应的Key是命中的，也就是15%。当然这只是个简单例子，现实情况肯定比这个复杂得多，不过足以说明，使用余数Hash的路由算法，在扩容的时候会造成大量的数据无法正确命中（其实不仅仅是无法命中，那些大量的无法命中的数据还在原缓存中在被移除前占据着内存）。这个结果显然是无法接受的，在网站业务中，大部分的业务数据度操作请求上事实上是通过缓存获取的，只有少量读操作会访问数据库，因此数据库的负载能力是以有缓存为前提而设计的。当大部分被缓存了的数据因为服务器扩容而不能正确读取时，这些数据访问的压力就落在了数据库的身上，这将大大超过数据库的负载能力，严重的可能会导致数据库宕机。</p><h3 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h3><p>一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：<br><img src="/posts/13533/3.jpg" alt=""></p><p>整个空间按<strong>顺时针</strong>方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p><p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择<strong>服务器的IP或主机名</strong>作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：<br><img src="/posts/13533/4.jpg" alt=""><br>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p><p>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：<br><img src="/posts/13533/5.jpg" alt=""></p><p>根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p><h3 id="一致性hash算法深入分析"><a href="#一致性hash算法深入分析" class="headerlink" title="一致性hash算法深入分析"></a>一致性hash算法深入分析</h3><h4 id="一致性Hash算法的容错性和可扩展性"><a href="#一致性Hash算法的容错性和可扩展性" class="headerlink" title="一致性Hash算法的容错性和可扩展性"></a>一致性Hash算法的容错性和可扩展性</h4><p>现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：<br><img src="/posts/13533/6.jpg" alt=""></p><p>下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：<br><img src="/posts/13533/7.jpg" alt=""></p><p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p><p><strong>综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</strong></p><h4 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h4><p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下： </p><p><img src="/posts/13533/8.jpg" alt=""></p><p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入<strong>了虚拟节点机制</strong>，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为<strong>虚拟节点</strong>。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p><p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点： </p><p><img src="/posts/13533/9.jpg" alt=""><br>同时数据定位算法不变，<strong>只是多了一步虚拟节点到实际节点的映射</strong>，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p><hr><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368" target="_blank" rel="noopener">什么是一致性Hash算法</a></li><li><a href="https://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noopener">一致性哈希算法原理</a></li><li><a href="https://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="noopener">对一致性Hash算法，Java代码实现的深入研究</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法背景&quot;&gt;&lt;a href=&quot;#算法背景&quot; class=&quot;headerlink&quot; title=&quot;算法背景&quot;&gt;&lt;/a&gt;算法背景&lt;/h3&gt;&lt;p&gt;在分布式系统中，常常需要使用缓存，而且通常是集群，访问缓存和添加缓存都需要一个 hash 算法来寻找到合适的 Cache 节
      
    
    </summary>
    
      <category term="算法" scheme="https://9191rs.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式学习之一致性协议：ZAB</title>
    <link href="https://9191rs.me/posts/34624/"/>
    <id>https://9191rs.me/posts/34624/</id>
    <published>2018-11-29T12:12:42.000Z</published>
    <updated>2018-11-28T13:16:19.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ZAB算法概述"><a href="#ZAB算法概述" class="headerlink" title="ZAB算法概述"></a>ZAB算法概述</h3><p>ZAB 协议全称是Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持 <strong>崩溃恢复</strong> 和 <strong>原子广播</strong> 协议。</p><p>ZAB 协议包括两种基本的模式，分别是<strong>崩溃恢复</strong>和<strong>消息广播</strong>。</p><ul><li>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时， ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的Leader 服务器同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。<strong>这里的状态同步指的是数据同步，用来保证集群中存在过半的机器和Leader服务器的数据保持一致。</strong></li><li>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播 ， 那么新加人的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</li></ul><h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p>ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 二阶段提交过程。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行 commit 操作（先提交自己，再发送 commit 给所有 Follwer）。</p><p><div align="center"><img src="/posts/34624/1543392456472.png" alt="Alt text"></div></p><p>在 ZAB 协议的二阶段提交过程中，移除了中断逻辑，所有的 Follower 服务器要么正常反馈 Leader 提出的事务 Proposal ,要么就抛弃Leader 服务器。同时， ZAB 协议将二阶段提交中的中断逻辑移除意味着我们可以在过半的 Follower 服务器已经反馈 Ack 之后就开始提交事务 Proposal 了，而不需要等待集群中所有的 Follower 服务器都反馈响应。这种简化了的二阶段提交模型<strong>无法处理</strong> Leader 服务器崩溃退出而带来的数据不一致问题<strong>（单点问题）</strong>，此时采用崩溃恢复模式来解决这个问题。</p><p>在整个消息广播过程中， Leader 服务器会为每个事务请求生成对应的 Proposal来进行广播，并且在广播事务 Proposal 之前， Leader 服务器会首先为这个事务 Proposal 分配一个全局单调递增的唯一事务ID (即 ZXID )。</p><p>Leader 服务器会为每一个 Follower 服务器都各自分配一个单独的队列，然后将需要广播的事务 Proposal 依次放入这些队列中去，并且根据 FIFO策略进行消息发送。每一个 Follower 服务器在接收到这个事务 Proposal 之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给 Leader 服务器一个 Ack 响应。当 Leader 服务器接收到超过半数 Follower 的 Ack 响应后，就会广播一个Commit 消息给所有的 Follower 服务器以通知其进行事务提交，同时 Leader 自身也会完成对事务的提交。</p><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>Leader 服务器出现崩溃，或者说由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式。Leader 选举算法不仅仅需要让 Leader自己知道其自身已经被选举为 Leader ,同时还需要让集群中的所有其他机器也能够快速地感知到选举产生的新的 Leader 服务器。</p><p>ZAB 协议规定了如果一个事务 Proposal 在一台机器上被处理成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃。</p><p>下面介绍两种崩溃恢复中的场景和zab协议需要保证的特性：</p><ul><li><strong>ZAB 协议需要确保那些已经在 Leader 服务器上提交的事务最终被所有服务器都提交</strong></li></ul><p>假设一个事务在 Leader 服务器上被提交了，并且已经得到过半 Follower 服务器的Ack 反馈，但是在它将 Commit 消息发送给所有 Follower 机器之前， Leader 服务器挂了，针对这种情况， ZAB 协议就需要确保该事务最终能够在所有的服务器上都被提交成功，否则将出现不一致。</p><ul><li><strong>ZAB协议需要确保丢弃那些只在 Leader 服务器上被提出的事务</strong></li></ul><p>假设初始的 Leader 服务器 在提出了一个事务之后就崩溃退出了，导致集群中的其他服务器都没有收到这个事务，当该服务器恢复过来再次加入到集群中的时候 ，ZAB协议需要确保丢弃这个事务。</p><p>针对以上两点需求，zab协议需要设计的选举算法应该满足：<strong>确保提交已经被 Leader 提交的事务 Proposal，同时丢弃已经被跳过的事务 Proposal 。</strong> 如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群中所有机器最高编号（即 ZXID 最大）的事务 Proposal,那么就可以保证这个新选举出来的 Leader —定具有所有已经提交的提案。同时，如果让具有最高编号事务 Proposal 的机器来成为 Leader, 就可以省去 Leader 服务器检查 Proposal 的提交和丢弃工作的这一步操作。</p><p>综上，选举阶段必须确保选出的Leader具有最大ZXID，否则在崩溃恢复阶段没法保证数据的一致性。</p><p><strong>选举流程：</strong></p><ul><li>每个Follower都向其他节点发送选自身为Leader的Vote投票请求，等待回复</li><li>Follower接受到的Vote如果比自身的大（ZXID更新）时则投票，并更新自身的Vote，否则拒绝投票</li><li>每个Follower中维护着一个投票记录表，当某个节点收到过半的投票时，结束投票并把该Follower选为Leader，投票结束</li></ul><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>当崩溃恢复之后，需要在正式工作之前（接收客户端请求），Leader 服务器首先确认事务是否都已经被过半的 Follwer 提交了，即是否完成了数据同步。目的是为了保持数据一致。 当所有的 Follwer 服务器都成功同步之后，Leader 会将这些服务器加入到可用服务器列表中。</p><p>Leader 服务器会为每一个 Follower 服务器都准备一个队列，并将那些没有被各 Follower 服务器同步的事务以 Proposal 消息的形式逐个发送给 Follower 服务器，并在每一个 Proposal 消息后面紧接着再发送一个 Commit 消息，以表示该事务已经被提交。等到 Follower 服务器将所有其尚未同步的事务 Proposal 都从 Leader 服务器上同步过来并成功应用到本地数据库中后， Leader 服务器就会将该 Follower 服务器加入到真正的可用 Follower 列表中，并开始之后的其他流程。</p><p>下面来看 ZAB 协议是如何处理那些需要被丢弃的事务 Proposal 的。在 ZAB 协议的事务编号 ZXID 设计中， ZXID 是一个 64 位的数字，低 32 位可以看作是一个简单的单调递增的计数器，针对客户端的每一个事务请求， Leader 服务器在产生一个新的事务 Proposal 的时候，都会对该计数器进行加1操作；高 32 位代表了 Leader 周期 epoch 的编号，每当选举产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务 Proposal 的 ZXID ,并从该 ZXID 中解析出对应的 epoch 值，然后再对其进行加1操作，之后就会以此编号作为新的 epoch, 并将低 32 位置0来开始生成新的 ZXID 。</p><p><div align="center"><img src="/posts/34624/1543409008791.png" alt="Alt text"></div></p><p>基于这样的策略，当一个包含了上一个 Leader 周期中尚未提交过的事务 Proposal的服务器启动加入到集群中，发现此时集群中已经存在leader，将自身以Follower 角色连接上 Leader 服务器之后， Leader 服务器会根据自己服务器上最后被提交的 Proposal来和 Follower 服务器的 Proposal进行比对，发现follower中有上一个leader周期的事务Proposal时，Leader 会要求 Follower 进行一个回退操作——回退到一个确实已经被集群中过半机器提交的最新的事务 Proposal 。</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>ZooKeeper主要依赖ZAB协议来实现分布式数据一致性。基于该协议,ZooKeeper实现了一种主备模式的系统架构来保持ZooKeeper为高可用。具体如下：</p><ul><li>使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用 ZAB 的原子广播协议，将服务器数据的状态变更以事务 Proposal 的形式广播到所有的副本进程上去。</li><li>同一时刻集群中只能有一个主进程来广播服务器的变更。</li><li>保证一个全局的变更序列被顺序应用。</li><li>当前主进程出现异常情况的时候，依旧能够正常工作。</li></ul><p>ZAB 协议的核心在于定义了会改变ZooKeeper服务器数据状态的事务请求的处理方式：</p><blockquote><p><strong>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为 Leader服务器，而余下的其他服务器则成为 Follower 服务器。 Leader 服务器负责将一个客户端事务请求转换成一个事务proposal（提议），并将该 Proposal分发给集群中所有的Follower服务器。之后 Leader 服务器需要等待所有Follower 服务器的反馈,一旦超过半数的Follower服务器进行了正确的反馈后，那么 Leader 就会再次向所有的 Follower服务器分发Commit消息，要求其将前一个proposal进行提交。</strong></p></blockquote><hr><p>参考链接</p><ul><li><a href="http://item.jd.com/11622772.html" target="_blank" rel="noopener">从Paxos到 Zookeeper——分布式一致性原理和实践  </a></li><li><a href="https://blog.csdn.net/wangyangzhizhou/article/details/52698555" target="_blank" rel="noopener">ZAB协议</a><div align="center"></div></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ZAB算法概述&quot;&gt;&lt;a href=&quot;#ZAB算法概述&quot; class=&quot;headerlink&quot; title=&quot;ZAB算法概述&quot;&gt;&lt;/a&gt;ZAB算法概述&lt;/h3&gt;&lt;p&gt;ZAB 协议全称是Zookeeper Atomic Broadcast（Zookeeper 原子广播
      
    
    </summary>
    
      <category term="分布式" scheme="https://9191rs.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>分布式学习之一致性算法：Raft</title>
    <link href="https://9191rs.me/posts/9940/"/>
    <id>https://9191rs.me/posts/9940/</id>
    <published>2018-11-27T12:12:00.000Z</published>
    <updated>2018-11-28T13:12:42.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Raft-算法概述"><a href="#Raft-算法概述" class="headerlink" title="Raft 算法概述"></a>Raft 算法概述</h3><p>Raft 算法是在复制状态机的背景下提出的，复制状态机通常都是基于复制日志实现的，这个日志可以理解为一个比喻，相当于一个指令。</p><blockquote><p><strong>状态机：</strong>多个节点上，从相同的初始状态开始，执行相同的一串命令，产生相同的最终状态。 复制状态机通常都是基于复制日志实现的，保证复制日志相同就是一致性算法的工作了。</p></blockquote><p><strong>Raft 是一种为了管理复制日志的一致性算法。</strong>它将一致性问题分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）。</p><p>Raft算法将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：</p><ul><li>Leader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li><li>Follower：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li><li>Candidate：Leader选举过程中的临时角色。</li></ul><h3 id="Leader选举（Leader-election）"><a href="#Leader选举（Leader-election）" class="headerlink" title="Leader选举（Leader election）"></a>Leader选举（Leader election）</h3><p> Raft算法要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。当所有服务器初始化的时候，都是跟随者，这个时候需要一个领导者，所有人都变成候选者，直到有人成功当选 领导者。 Raft算法角色状态转换如下：</p><p><div align="center"><img src="/posts/9940/1543284112135.png" alt="Alt text"></div></p><p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p><p><div align="center"><img src="/posts/9940/1543284412375.png" alt="Alt text"></div></p><p>从上图可以看出，整个系统总是在选举和正常运行之间切换<strong>。Leader周期性的</strong>向所有Follower发送心跳包来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，那么他就会认为系统中没有可用的Leader,并且发起选举以选出新的领导者。<strong>要开始一次选举过程，</strong>Follower先要增加自己的当前任期号并且转换到 Candidater状态。然后请求其他服务器为自己投票。那么会产生 3 种结果：</p><ul><li>赢得了多数的选票，成功选举为Leader；</li><li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；</li><li>没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举（term3）</li></ul><blockquote><p>每一个 server 最多在一个任期内投出一张选票（有任期号约束），先到先得。<br>要求最多只能有一个人赢得选票。<br>一旦成功，立即成为领导人，然后广播所有服务器停止投票阻止新得领导产生。<br>如果Leader选举失败， Raft 通过使用随机选举超时时间（例如 150 - 300 毫秒）的方法将服务器打散投票。每个候选人在僵住的时候会随机从一个时间开始重新选举。</p></blockquote><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。某些Followers可能没有成功的复制日志，Leader会无限的重试 AppendEntries RPC直到所有的Followers最终存储了所有的日志条目。直到第四步骤，整个事务才会达成。中间任何一个步骤发生故障，都不会影响日志一致性。</p><p><div align="center"><img src="/posts/9940/1543284930678.png" alt="Alt text"></div></p><p>日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交了。</p><p><div align="center"><img src="/posts/9940/1543285319491.png" alt="Alt text"></div></p><p>Raft日志同步保证如下两点：</p><ul><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。</li></ul><p>第一条特性源于Leader在一个term内在给定的一个log index最多创建一条日志条目，同时该条目在日志中的位置也从来不会改变。</p><p>第二条特性源于 AppendEntries 的一个简单的一致性检查。当发送一个 AppendEntries RPC 时，Leader会把新日志条目紧接着之前的条目的log index和term都包含在里面。如果Follower没有在它的日志中找到log index和term都相同的日志，它就会拒绝新的日志条目。</p><p>一般情况下，Leader和Followers的日志保持一致，因此 AppendEntries 一致性检查通常不会失败。然而，Leader崩溃可能会导致日志不一致：旧的Leader可能没有完全复制完日志中的所有条目。</p><p>如果出现了日志不一致，Leader通过强制Followers复制它的日志来处理日志的不一致，Followers上的不一致的日志会被Leader的日志覆盖。 Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目。<strong>具体的做法为：</strong>Leader会从后往前试，每次AppendEntries失败后尝试前一个日志条目，直到成功找到每个Follower的日志一致位点，然后向后逐条覆盖Followers在该位置之后的条目。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Raft增加了如下两条限制以保证安全性：</p><ul><li>拥有最新的已提交的log entry的Follower才有资格成为Leader。</li></ul><p>这个保证是在RequestVote RPC中做的，Candidate在发送RequestVote RPC时，要带上自己的最后一条日志的term和log index，其他节点收到消息时，如果发现自己的日志比请求中携带的更新，则拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term更大，则term大的更新，如果term一样大，则log index更大的更新。</p><ul><li>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。 之所以要这样，是因为可能会出现已提交的日志又被覆盖的情况。</li></ul><p><strong>以上就是Raft算法的简单描述，更具体的内容还要参考作者的论文。</strong></p><hr><p>参考链接</p><ul><li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">Raft论文中文翻译</a></li><li><a href="https://www.cnblogs.com/stateis0/p/9062131.html" target="_blank" rel="noopener">分布式理论(六)——Raft 算法</a></li><li><a href="http://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">Raft 为什么是更易理解的分布式一致性算法</a></li><li><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">Paxos、Raft分布式一致性最佳实践</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Raft-算法概述&quot;&gt;&lt;a href=&quot;#Raft-算法概述&quot; class=&quot;headerlink&quot; title=&quot;Raft 算法概述&quot;&gt;&lt;/a&gt;Raft 算法概述&lt;/h3&gt;&lt;p&gt;Raft 算法是在复制状态机的背景下提出的，复制状态机通常都是基于复制日志实现的，这
      
    
    </summary>
    
      <category term="分布式" scheme="https://9191rs.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Raft" scheme="https://9191rs.me/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>分布式学习之一致性算法：Paxos</title>
    <link href="https://9191rs.me/posts/35956/"/>
    <id>https://9191rs.me/posts/35956/</id>
    <published>2018-11-26T12:12:25.000Z</published>
    <updated>2018-11-28T14:51:27.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Paxos概述"><a href="#Paxos概述" class="headerlink" title="Paxos概述"></a>Paxos概述</h3><p>在常见的分布式系统中，总会发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。</p><p><strong>注：这里某个数据的值并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。根据应用场景不同，某个数据的值有不同的含义。</strong></p><p> <strong>Paxos的三个角色</strong></p><ul><li><strong>Proposer：提议发起者。</strong>Proposer 可以有多个，Proposer 提出议案（value）。所谓 value，可以*是任何操作，比如“设置某个变量的值为value”。不同的 Proposer 可以提出不同的 value，例如某个Proposer 提议“将变量 X 设置为 1”，另一个 Proposer 提议“将变量 X 设置为 2”，但对同一轮 Paxos过程，最多只有一个 value 被批准。</li><li><strong>Acceptor：提议接受者。</strong>Acceptor 有 N 个，Proposer 提出的 value 必须获得超过半数(N/2+1)的 Acceptor批准后才能通过。Acceptor 之间完全对等独立。</li><li><strong>Learner：提议学习者。</strong>上面提到只要超过半数accpetor通过即可获得通过，那么learner角色的目的就是把通过的确定性取值同步给其他未确定的Acceptor。</li></ul><p><div align="center"><img src="/posts/35956/1543415317261.png" alt="Alt text"></div></p><p>Paxos算法<strong>原理推导过程</strong>可以参考 <a href="http://www.cnblogs.com/linbingdong/p/6253479" target="_blank" rel="noopener">这篇文章</a>。</p><h3 id="Paxos算法的流程"><a href="#Paxos算法的流程" class="headerlink" title="Paxos算法的流程"></a>Paxos算法的流程</h3><p>Paxos算法分为两个阶段。具体如下：</p><p><strong>阶段一：</strong></p><ul><li>Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。</li><li>如果一个Acceptor收到一个编号为N的Prepare请求，如果小于它已经响应过的请求，则拒绝，不回应或回复error。且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话，如果还没有的accept提案的话返回{pok，null，null}）作为响应反馈给Proposer，<strong>同时该Acceptor承诺不再接受任何编号小于N的提案。</strong></li></ul><p><strong>阶段二：</strong></p><ul><li>如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。</li><li>如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。如果N小于Acceptor以及响应的prepare请求，则拒绝，不回应或回复error（当proposer没有收到过半的回应，那么他会重新进入第一阶段，递增提案号，重新提出prepare请求）。</li></ul><p><strong>上述过程中的关键点：</strong></p><ul><li><strong>阶段一Accpetor的处理流程</strong></li></ul><p>假设Acceptor本地记录的编号为T。如果N小于T，则不响应或者响应error。如果N大于等于T，则会更新本地记录的编号为N，并且返回已经存在的值或者返回null。</p><ul><li><strong>阶段二Proposer的处理流程</strong></li></ul><p>如果Proposer未超过半数Accpetor响应，提议失败。超过半数的Accpetor响应的值<strong>都为空</strong>才提交自身要写入的值，否则选择非空值里版本号最大的值提交，最大的区别在于是提交的值是自身的还是使用以前提交的。</p><h3 id="Paxos算法的活锁问题（保证算法活性）"><a href="#Paxos算法的活锁问题（保证算法活性）" class="headerlink" title="Paxos算法的活锁问题（保证算法活性）"></a>Paxos算法的活锁问题（保证算法活性）</h3><p>Paxos算法运行过程中，可能还会存在一种极端情况，当有两个proposer依次提出一系列编号递增的议案，那么会陷入死循环，无法完成第二阶段，也就是无法选定一个提案。如下图：</p><p><div align="center"><img src="/posts/35956/1543415734852.png" alt="Alt text"></div></p><p>通过选取主Proposer，就可以保证Paxos算法的活性。选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，只要主Proposer和过半的Acceptor能够正常进行网络通信，那么肯定会有一个提案被批准（第二阶段的accept），则可以解决死循环导致的活锁问题。</p><hr><p>参考链接</p><ul><li><a href="http://item.jd.com/11622772.html" target="_blank" rel="noopener">从Paxos到 Zookeeper——分布式一致性原理和实践  </a></li><li><a href="http://www.cnblogs.com/linbingdong/p/6253479.html" target="_blank" rel="noopener">Paxos算法原理与推导</a></li><li><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科–Paxos算法</a></li><li><a href="https://blog.csdn.net/qq_35440678/article/details/78080431" target="_blank" rel="noopener">paxos协议的精髓</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Paxos概述&quot;&gt;&lt;a href=&quot;#Paxos概述&quot; class=&quot;headerlink&quot; title=&quot;Paxos概述&quot;&gt;&lt;/a&gt;Paxos概述&lt;/h3&gt;&lt;p&gt;在常见的分布式系统中，总会发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区
      
    
    </summary>
    
      <category term="分布式" scheme="https://9191rs.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>分布式学习之一致性协议：2PC和3PC</title>
    <link href="https://9191rs.me/posts/39597/"/>
    <id>https://9191rs.me/posts/39597/</id>
    <published>2018-11-25T09:11:29.000Z</published>
    <updated>2018-11-25T11:27:30.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一致性协议之2PC"><a href="#一致性协议之2PC" class="headerlink" title="一致性协议之2PC"></a>一致性协议之2PC</h2><p>2PC是 Two-Phase Commit的缩写，即两阶段提交 ，主要目的就是为了保证分布式系统数据的一致性。</p><p>二阶段提交就是讲事务的提交过程分成了两个阶段来进行处理。流程如下：</p><h3 id="阶段一：-提交事务请求"><a href="#阶段一：-提交事务请求" class="headerlink" title="阶段一： 提交事务请求"></a>阶段一： 提交事务请求</h3><p><strong>事务询问：</strong> 协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。</p><p><strong>执行事务：</strong>各参与者节点执行事务操作，并将 Undo 和 Redo 信息记入事务日志中。</p><p><strong>各参与者向协调者反馈事务询问的响应：</strong> 如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行；如果参与者没有成功执行事务，就返回 No 给协调者，表示事务不可以执行。</p><h3 id="阶段二：执行事务提交"><a href="#阶段二：执行事务提交" class="headerlink" title="阶段二：执行事务提交"></a>阶段二：执行事务提交</h3><p>在阶段二中，会根据阶段一的投票结果执行 2 种操作：执行事务提交，中断事务。</p><h4 id="执行事务提交"><a href="#执行事务提交" class="headerlink" title="执行事务提交"></a>执行事务提交</h4><p><strong>发送提交请求：</strong>协调者向所有参与者发出 commit 请求。<br><strong>事务提交：</strong>参与者收到 commit 请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。<br><strong>反馈事务提交结果：</strong>参与者在完成事务提交之后，向协调者发送 Ack 信息。 协调者接收到所有参与者反馈的 Ack 信息后，完成事务。</p><h4 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h4><p><strong>发送回滚请求：</strong>协调者向所有参与者发出 Rollback 请求。<br><strong>事务回滚：</strong>参与者接收到 Rollback 请求后，会利用其在阶段一种记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。<br><strong>反馈事务回滚结果：</strong>参与者在完成事务回滚之后，想协调者发送 Ack 信息。<br><strong>中断事务：</strong>协调者接收到所有参与者反馈的 Ack 信息后，完成事务中断。</p><p>从上面的逻辑可以看出，二阶段提交就做了2个事情：投票，执行。 <strong>核心</strong>是对每个事务都采用<strong>先尝试后提交</strong>的处理方式，因此也可以将二阶段提交看成一个强一致性的算法。</p><h3 id="2PC优缺点分析"><a href="#2PC优缺点分析" class="headerlink" title="2PC优缺点分析"></a>2PC优缺点分析</h3><p><strong>优点：</strong>原理简单，实现方便<br><strong>缺点：</strong>同步阻塞，单点问题，数据不一致，过于保守<br><strong>同步阻塞：</strong> 在二阶段提交的过程中，所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。</p><p><strong>单点问题：</strong> 协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转，更重要的是：其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。</p><p><strong>数据不一致：</strong> 假设当协调者向所有的参与者发送 commti 请求之后，发生了局部网络异常或者是协调者在尚未发送完所有 commit 请求之前自身发生了崩溃，导致最终只有部分参与者收到了 commit 请求。这将导致严重的数据不一致问题。</p><p><strong>过于保守：</strong> 如果在二阶段提交的提交询问阶段中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的化，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。</p><h2 id="一致性协议之3PC"><a href="#一致性协议之3PC" class="headerlink" title="一致性协议之3PC"></a>一致性协议之3PC</h2><p>3PC是 “Three Phase Commit”的缩写，即三阶段提交，是 2PC 的改进版，主要是将 2PC 的 “提交事务请求” 过程一分为二。</p><h3 id="阶段一：CanCommit"><a href="#阶段一：CanCommit" class="headerlink" title="阶段一：CanCommit"></a>阶段一：CanCommit</h3><p><strong>事务询问：</strong>协调者向所有的参与者发送一个包含事务内容的 canCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p><p><strong>各参与者向协调者反馈事务询问的响应：</strong>参与者接收来自协调者的 canCommit 请求，如果参与者认为自己可以顺利执行事务，就返回 Yes，否则反馈 No 响应。</p><h3 id="阶段二：PreCommit"><a href="#阶段二：PreCommit" class="headerlink" title="阶段二：PreCommit"></a>阶段二：PreCommit</h3><p>协调者在得到所有参与者的响应之后，会根据结果执行2种操作：执行事务预提交，或者中断事务。</p><h4 id="执行事务预提交"><a href="#执行事务预提交" class="headerlink" title="执行事务预提交"></a>执行事务预提交</h4><p><strong>发送预提交请求：</strong>协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态。<br><strong>事务预提交：</strong>参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 中的 “执行事务”，也会 Undo 和 Redo 信息记录到事务日志中。<br><strong>各参与者向协调者反馈事务执行的结果：</strong>如果参与者成功执行了事务，就反馈 Ack 响应，同时等待指令：提交（commit） 或终止（abor）。</p><h4 id="中断事务-1"><a href="#中断事务-1" class="headerlink" title="中断事务"></a>中断事务</h4><p><strong>发送中断请求：</strong>协调者向所有参与者节点发出 abort 请求 。<br><strong>中断事务：</strong>参与者如果收到 abort 请求或者超时了，都会中断事务。</p><h3 id="阶段三：doCommit"><a href="#阶段三：doCommit" class="headerlink" title="阶段三：doCommit"></a>阶段三：doCommit</h3><p>该阶段做真正的提交，同样也会出现两种情况：</p><h4 id="执行提交"><a href="#执行提交" class="headerlink" title="执行提交"></a>执行提交</h4><p><strong>发送提交请求：</strong>进入这一阶段，如果协调者正常工作，并且接收到了所有协调者的 Ack 响应，那么协调者将从 “预提交” 状态变为 “提交” 状态，并向所有的参与者发送 doCommit 请求 。<br><strong>事务提交：</strong>参与者收到 doCommit 请求后，会正式执行事务提交操作，并在完成之后释放在整个事务执行期间占用的事务资源。<br><strong>反馈事务提交结果：</strong>参与者完成事务提交后，向协调者发送 Ack 消息。<br><strong>完成事务：</strong>协调者接收到所有参与者反馈的 Ack 消息后，完成事务。</p><h4 id="中断事务-2"><a href="#中断事务-2" class="headerlink" title="中断事务"></a>中断事务</h4><p>假设有任何参与者反馈了 no 响应，或者超时了，就中断事务。</p><p><strong>发送中断请求：</strong>协调者向所有的参与者节点发送 abort 请求。<br><strong>事务回滚：</strong>参与者接收到 abort 请求后，会利用其在二阶段记录的 undo 信息来执行事务回滚操作，并在完成回滚之后释放整个事务执行期间占用的资源。<br><strong>反馈事务回滚结果：</strong>参与者在完成事务回滚之后，想协调者发送 Ack 消息。<br><strong>中断事务：</strong>协调者接收到所有的 Ack 消息后，中断事务。</p><p>注意：一旦进入阶段三，可能会出现 2 种故障：</p><ul><li>协调者出现问题</li><li>协调者和参与者之间的网络故障</li></ul><p>不论出现了任一一种情况，最终都会导致参与者无法收到 doCommit 请求或者 abort 请求，针对这种情况，参与者都会在等待超时之后，继续进行事务提交。</p><h3 id="3PC优缺点分析"><a href="#3PC优缺点分析" class="headerlink" title="3PC优缺点分析"></a>3PC优缺点分析</h3><p><strong>优点：</strong>相比较 2PC，最大的优点是减少了参与者的阻塞范围（第一个阶段是不阻塞的），并且能够在单点故障后继续达成一致（2PC 在提交阶段会出现此问题，而 3PC 会根据协调者的状态进行回滚或者提交）。</p><p><strong>缺点：</strong>如果参与者收到了 preCommit 消息后，出现了网络分区，那么参与者等待超时后，都会进行事务的提交，这必然会出现事务不一致的问题。</p><hr><p>参考链接</p><ul><li><a href="http://item.jd.com/11622772.html" target="_blank" rel="noopener">从Paxos到 Zookeeper——分布式一致性原理和实践  </a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一致性协议之2PC&quot;&gt;&lt;a href=&quot;#一致性协议之2PC&quot; class=&quot;headerlink&quot; title=&quot;一致性协议之2PC&quot;&gt;&lt;/a&gt;一致性协议之2PC&lt;/h2&gt;&lt;p&gt;2PC是 Two-Phase Commit的缩写，即两阶段提交 ，主要目的就是为了保
      
    
    </summary>
    
      <category term="分布式" scheme="https://9191rs.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="2PC" scheme="https://9191rs.me/tags/2PC/"/>
    
      <category term="3PC" scheme="https://9191rs.me/tags/3PC/"/>
    
  </entry>
  
  <entry>
    <title>分布式学习之CAP和BASE理论</title>
    <link href="https://9191rs.me/posts/14366/"/>
    <id>https://9191rs.me/posts/14366/</id>
    <published>2018-11-25T08:00:59.000Z</published>
    <updated>2018-11-25T09:21:41.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从集中式到分布式"><a href="#从集中式到分布式" class="headerlink" title="从集中式到分布式"></a>从集中式到分布式</h3><p><strong>集中式：</strong>由一台或者多台主计算机组成主节点，数据存储于中心节点之中，并且整个系统所有的业务单元都集中部署到这个中心节点之上，系统所有的功能均有其集中处理。换句话说，就是在集中式系统中，每个终端或者客户端只负责数据的录入和输出，而数据的存储和控制完全交由主机处理。集中式系统<strong>最大的特点</strong>就是部署结构简单，由于集中式系统往往基于底层性能卓越的大型主机，因此无需考虑如何对服务进行多个节点的部署，也就不用考虑多个节点之间的分布式协作问题。</p><p><strong>分布式：</strong>分布式系统是指位于<strong>联网计算机上的组件</strong>仅<strong>通过传递消息来通信和协调其动作</strong>的系统(A distributed system is one in which components located at networked computers communicate and coordinate their actions only by passing messages)。严格讲，同一个分布式系统中的计算机在空间部署上是可以随意分布的，这些计算机可能被放在不同的机柜上，也可能在不同的机房中，甚至分布在不同的城市。无论如何，一个标准的分布式系统在没有任何特定业务逻辑约束的情况下，都会有以下几个特征：</p><ul><li><strong>分布性:</strong>分布式系统中的多台计算机都会在空间上随意分布，同时，及其的分布情况也会随时变动。</li><li><p><strong>对等性:</strong> 分布式系统中的计算机没有主/从之分，既没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有节点都是对等的。<strong>副本（Replica）</strong>是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。在常见的分布式系统中，为了对外提高可用的服务，我们往往会对数据和服务进行副本处理。<strong>数据副本</strong>是指在不同的节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取到该数据，这是解决分布式系统数据丢失问题最为有效的手段。另一类副本是<strong>服务副本</strong>，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。</p></li><li><p><strong>并发性：</strong> 在一个计算机网络中，程序运行过程中的并发性操作是非常常见的行为，例如同一个分布式系统的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储等。</p></li><li><p><strong>缺乏全局时钟：</strong>  一个典型的分布式系统是由一系列空间上随意分布的多个进程组成的，具有明显的分布性，这些进程之间通过交换消息来进行相互通信。因此，在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的始终控制序列。</p></li><li><p><strong>故障总是会发生：</strong> 组成分布式系统的所有计算机，都有可能发生任何形式的故障。</p></li><li><p><strong>处理单点故障：</strong> 在整个分布式系统中，如果某个角色或者功能只有某台单机在支撑，那么这个节点称为单点，其发生的故障称为单点故障，也就是通常说的SPoF（Single Point of Failure），避免单点而对关键就是把这个功能从单机实现变为集群实现。如果不能把单点变为集群实现，那么一般还有两种选择：给这个单点做好备份，能够在出现问题时进行恢复，并且尽量做到自动恢复或者是降低单点故障的影响范围。</p></li></ul><h3 id="分布一致性"><a href="#分布一致性" class="headerlink" title="分布一致性"></a>分布一致性</h3><p>在分布式系统中要解决的一个重要问题就是数据的复制 ,分布式系统对于数据的复制需求一般都来自于以下两个原因：</p><ul><li>为了<strong>增加系统的可用性</strong>，以防止单点故障引起的系统不可用。</li><li><strong>提高系统的整体性能</strong>，通过负载均衡技术，能够让分布在不同地方的数据副本都能够为用户提供服务。</li><li>但是数据复制也带来了的<strong>数据的一致性问题</strong>：在分布式环境中引入数据复制机制之后，不同数据节点之间可能出现的，并无法依靠计算机应用程序自身解决的数据不一致的情况。简单讲，数据一致性就是指在对一个副本数据进行更新的时候，必须确保也能够更新其他的副本，否则不同副本之间的数据将不一致。 那么如何解决这个问题？<strong>一种思路是*”既然是由于延时动作引起的问题，那可以将写入的动作阻塞，直到数据复制完成后，才完成写入动作”</strong>。但这个思路在解决一致性问题的同时，又带来了新的问题：写入的性能。如果应用场景有非常多的写请求，那么使用这个思路之后，后续的写请求都将会阻塞在前一个请求的写操作上，导致系统整体性能急剧下降。</li></ul><p>总得来说，我们无法找到一种能够满足分布式系统所有系统属性的分布式一致性解决方案。因此，如何既保证数据的一致性，同时又不影响系统运行的性能，是每一个分布式系统都需要重点考虑和权衡的。于是，一致性级别由此诞生：</p><ul><li><strong>强一致性：</strong>这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大。</li><li><strong>弱一致性 ：</strong>这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态。</li><li><strong>最终一致性：</strong>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型。</li></ul><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p> <strong>CAP理论是一个经典的分布式系统理论。</strong></p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p><strong>在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一直的状态。</strong></p><p>对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数据），这就是典型的分布式数据不一致的情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性。</p><h4 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h4><p><strong>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是”有限时间内”和”返回结果”。</strong></p><p><strong>有限时间内</strong>是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的 。<br><strong>返回结果</strong>要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出队请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。</p><h4 id="分区容错性（Partition-Tolerance）"><a href="#分区容错性（Partition-Tolerance）" class="headerlink" title="分区容错性（Partition Tolerance）"></a>分区容错性（Partition Tolerance）</h4><p><strong>分区容错性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</strong></p><p><strong>网络分区是指</strong>在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。</p><h4 id="CAP理论核心内容"><a href="#CAP理论核心内容" class="headerlink" title="CAP理论核心内容"></a>CAP理论核心内容</h4><p> <strong>一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项。</strong></p><p><div align="center"> <img src="/posts/14366/1543136011523.png" alt="Alt text"></div></p><table><thead><tr><th style="text-align:center">选择</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">CA</td><td>放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</td></tr><tr><td style="text-align:center">AP</td><td>放弃一致性（强一致性），追求分区容错性和可用性</td></tr><tr><td style="text-align:center">CP</td><td>放弃可用性，追求一致性和分区容错性，但是基本不会选择</td></tr></tbody></table><h4 id="为什么只能3选2"><a href="#为什么只能3选2" class="headerlink" title="为什么只能3选2"></a>为什么只能3选2</h4><p>考虑下面一种情况：整个系统由两个节点配合组成，之间通过网络通信，当节点 A 进行更新数据库操作的时候，需要同时更新节点 B 的数据库（这是一个原子的操作）。</p><p><div align="center"> <img src="/posts/14366/1543137490973.png" alt="Alt text"></div></p><p>上面这个系统怎么满足 CAP 呢？C：当节点A更新的时候，节点B也要更新，A：必须保证两个节点都是可用的，P：当节点 A,B 出现了网络分区，必须保证对外可用。</p><p>可见，根本完成不了，只要出现了网络分区，A 就无法满足，因为节点 A 根本连接不上节点 B。如果强行满足 C 原子性，就必须停止服务运行，从而放弃可用性 C。<br>所以，最多满足两个条件。</p><p>需要明确的一点是，对于一个分布式系统而言，<strong>分区容错性是一个最基本的要求</strong>。因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此分布式系统往往需要根据业务特点在C（一致性）和A（可用性）之间寻求平衡。</p><p>但是，分区是百分之百出现的吗？如果不出现分区，那么就能够同时满足 CAP。如果出现了分区，可以根据策略进行调整。比如 C 不必使用那么强的一致性，可以先将数据存起来，稍后再更新，实现所谓的 “最终一致性”。这个理论 就是Base 理论。</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。<strong>BASE理论是对CAP中一致性和可用性权衡的结果</strong>，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。<br><strong>BASE理论的核心思想是：</strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素：</p><h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—-注意，这绝不等价于系统不可用。比如：</p><ul><li>响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒。</li><li>系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul><h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><hr><p>参考链接</p><ul><li><a href="http://item.jd.com/11622772.html" target="_blank" rel="noopener">从Paxos到 Zookeeper——分布式一致性原理和实践  </a></li><li><a href="https://www.cnblogs.com/xrq730/p/4944768.html" target="_blank" rel="noopener">从分布式一致性谈到CAP理论、BASE理论</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;从集中式到分布式&quot;&gt;&lt;a href=&quot;#从集中式到分布式&quot; class=&quot;headerlink&quot; title=&quot;从集中式到分布式&quot;&gt;&lt;/a&gt;从集中式到分布式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;集中式：&lt;/strong&gt;由一台或者多台主计算机组成主节点，数据存储于中心节
      
    
    </summary>
    
      <category term="分布式" scheme="https://9191rs.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="CAP理论" scheme="https://9191rs.me/tags/CAP%E7%90%86%E8%AE%BA/"/>
    
      <category term="BASE理论" scheme="https://9191rs.me/tags/BASE%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配的Boyer-Moore算法</title>
    <link href="https://9191rs.me/posts/21269/"/>
    <id>https://9191rs.me/posts/21269/</id>
    <published>2018-11-22T13:17:23.000Z</published>
    <updated>2018-11-22T15:06:04.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Boyer-Moore算法简介"><a href="#Boyer-Moore算法简介" class="headerlink" title="Boyer-Moore算法简介"></a>Boyer-Moore算法简介</h3><p>在用于查找子字符串的算法当中，BM（Boyer-Moore）算法是目前被认为最高效的字符串搜索算法，它由Bob Boyer和J Strother Moore设计于1977年。 一般情况下，比KMP算法快3-5倍。该算法常用于文本编辑器中的搜索匹配功能。</p><p>BM算法的<strong>精华就在于BM(text, pattern),也就是BM算法当不匹配的时候一次性可以跳过不止一个字符。即它不需要对被搜索的字符串中的字符进行逐一比较，而会跳过其中某些部分</strong>。通常搜索关键字越长，算法速度越快。它的效率来自于这样的事实：对于每一次失败的匹配尝试，算法都能够使用这些信息来排除尽可能多的无法匹配的位置。即它充分利用待搜索字符串的一些特征，加快了搜索的步骤。<br>BM算法实际上包含两个并行的算法（也就是两个启发策略）：坏字符算法（bad-character shift）和好后缀算法（good-suffix shift）。这两种算法的目的就是让模式串每次向右移动尽可能大的距离。</p><p>假设文本串text长度为n，模式串pattern长度为m，BM算法的主要特征为：</p><ul><li>从右往左进行比较匹配（一般的字符串搜索算法如KMP都是从从左往右进行匹配）</li><li>算法分为两个阶段：预处理阶段和搜索阶段</li><li>预处理阶段时间和空间复杂度都是是O(m+sigma)，sigma是字符集大小</li><li>搜索阶段时间复杂度是O(mn)</li><li>当模式串是非周期性的，在最坏的情况下算法需要进行3n次字符比较操作</li><li>算法在最好的情况下达到O(n / m)，比如在文本串bn中搜索模式串am-1b ，只需要n/m次比较</li></ul><h3 id="BM算法的理论"><a href="#BM算法的理论" class="headerlink" title="BM算法的理论"></a>BM算法的理论</h3><h4 id="坏字符算法"><a href="#坏字符算法" class="headerlink" title="坏字符算法"></a>坏字符算法</h4><p>当出现一个坏字符时, BM算法向右移动模式串, 让模式串中最靠右的对应字符与坏字符相对，然后继续匹配。坏字符算法有两种情况。<br>Case1：模式串中有对应的坏字符时，让模式串中最靠右的对应字符与坏字符相对（PS：BM不可能走回头路，因为若是回头路，则移动距离就是负数了，肯定不是最大移动步数了），如下图。</p><p><div align="center"><img src="/posts/21269/1542898185744.png" alt="Alt text"></div></p><p>Case2：模式串中不存在坏字符，很好，直接右移整个模式串长度这么大步数，如下图。</p><p><div align="center"><img src="/posts/21269/1542898194867.png" alt="Alt text"></div></p><h4 id="好后缀算法"><a href="#好后缀算法" class="headerlink" title="好后缀算法"></a>好后缀算法</h4><p>如果程序匹配了一个好后缀, 并且在模式中还有另外一个相同的后缀或后缀的部分, 那把下一个后缀或部分移动到当前后缀位置。假如说，pattern的后u个字符和text都已经匹配了，但是接下来的一个字符不匹配，我需要移动才能匹配。如果说后u个字符在pattern其他位置也出现过或部分出现，我们将pattern右移到前面的u个字符或部分和最后的u个字符或部分相同，如果说后u个字符在pattern其他位置完全没有出现，很好，直接右移整个pattern。这样，好后缀算法有三种情况，如下图所示：</p><p>Case1：模式串中有子串和好后缀完全匹配，则将最靠右的那个子串移动到好后缀的位置继续进行匹配。</p><p><div align="center"><img src="/posts/21269/1542898245702.png" alt="Alt text"></div></p><p>Case2：如果不存在和好后缀完全匹配的子串，则在好后缀中找到具有如下特征的最长子串,使得P[m-s…m]=P[0…s]。</p><p><div align="center"><img src="/posts/21269/1542898268759.png" alt="Alt text"></div></p><p>Case3：如果完全不存在和好后缀匹配的子串，则右移整个模式串。</p><h4 id="移动规则"><a href="#移动规则" class="headerlink" title="移动规则"></a>移动规则</h4><p>BM算法的移动规则是：按照好后缀算法和坏字符算法计算得到的最大值。shift（好后缀）和shift（坏字符）通过模式串的预处理数组的简单计算得到。</p><h3 id="BM算法的实现"><a href="#BM算法的实现" class="headerlink" title="BM算法的实现"></a>BM算法的实现</h3><h4 id="坏字符的实现"><a href="#坏字符的实现" class="headerlink" title="坏字符的实现"></a>坏字符的实现</h4><p>BM算法子串比较失配时，按坏字符算法计算pattern需要右移的距离,这里注意的一定是最右的位置。如下图：</p><p><div align="center"><img src="/posts/21269/1838568299.jpg" alt="Alt text"></div></p><h4 id="好后缀的实现"><a href="#好后缀的实现" class="headerlink" title="好后缀的实现"></a>好后缀的实现</h4><p>Case1：对应好后缀算法case1，如下图，K是好后缀之前的那个位置。</p><p><div align="center"><img src="/posts/21269/54643645898.jpg" alt="Alt text"></div></p><p>Case2：对应好后缀算法case2：如下图所示： </p><p><div align="center"><img src="/posts/21269/135411310351.jpg" alt="Alt text"></div></p><p>Case3：对应与好后缀算法case3，bmGs[i] = len（pattern）= m </p><p>在上面求的过程中用到了suffix数组，上suffix[i]就是求pattern中以i位置字符为后缀和以最后一个字符为后缀的公共后缀串的长度。</p><h3 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class BM &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">HashMap</span>&lt;Character,Integer&gt; bmBc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] bmGs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> boyerMoore(<span class="keyword">String</span> <span class="built_in">text</span>,<span class="keyword">String</span> pattern)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> n = <span class="built_in">text</span>.length();</span><br><span class="line">        <span class="built_in">int</span> m = pattern.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// proprocessing</span></span><br><span class="line">        preBmBc(pattern, m);</span><br><span class="line">        preBmGs(pattern, m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// searching</span></span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= n - m)&#123;</span><br><span class="line">            i = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; pattern.charAt(i) == <span class="built_in">text</span>.charAt(i + j))</span><br><span class="line">                i--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)  <span class="comment">// [j , j+m-1]</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j += Math.<span class="built_in">max</span>(bmGs[i], getBmBc(<span class="built_in">text</span>.charAt(i + j), m) - m + <span class="number">1</span> + i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算坏字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> getBmBc(<span class="built_in">char</span> c,<span class="built_in">int</span> m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bmBc.containsKey(c))</span><br><span class="line">            <span class="keyword">return</span> bmBc.<span class="built_in">get</span>(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> preBmBc(<span class="keyword">String</span> pattern,<span class="built_in">int</span> m)&#123;</span><br><span class="line"></span><br><span class="line">        bmBc = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=m<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!bmBc.containsKey(pattern.charAt(i)))</span><br><span class="line">                bmBc.put((pattern.charAt(i)),m-i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算好后缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> preBmGs(<span class="keyword">String</span> pattern, <span class="built_in">int</span> m)</span><br><span class="line">    &#123;</span><br><span class="line">        bmGs = <span class="keyword">new</span> <span class="built_in">int</span>[m];</span><br><span class="line">        <span class="built_in">int</span> i, j;</span><br><span class="line">        <span class="built_in">int</span>[] suffix =suffix(pattern,m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Case3: 模式串中没有子串匹配上好后缀，也找不到一个最大前缀</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            bmGs[i] = m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Case2: 模式串中没有子串匹配上好后缀，但找到一个最大前缀</span></span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (suffix[i] == i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; m - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (bmGs[j] == m)</span><br><span class="line">                        bmGs[j] = m- <span class="number">1</span> - i;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Case1: 模式串中有子串匹配上好后缀</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">            bmGs[m- <span class="number">1</span> - suffix[i]] = m - <span class="number">1</span> - i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="built_in">int</span>[] suffix(<span class="keyword">String</span> pattern, <span class="built_in">int</span> m)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[] suff = <span class="keyword">new</span> <span class="built_in">int</span>[m];</span><br><span class="line">        <span class="built_in">int</span> i, j,k;</span><br><span class="line"></span><br><span class="line">        suff[m - <span class="number">1</span>] = m;</span><br><span class="line">        <span class="keyword">for</span>(i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; pattern.charAt(j) == pattern.charAt(m - <span class="number">1</span> - i + j))</span><br><span class="line">                j--;</span><br><span class="line"></span><br><span class="line">            suff[i] = i - j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> suff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><ul><li><a href="http://www.cnblogs.com/lanxuezaipiao/p/3452579.html" target="_blank" rel="noopener">grep之字符串搜索算法Boyer-Moore由浅入深（比KMP快3-5倍）</a></li><li><a href="https://blog.csdn.net/nmgrd/article/details/51697567" target="_blank" rel="noopener">字符串搜索算法Boyer-Moore的Java实现</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="noopener">阮一峰:字符串匹配的Boyer-Moore算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Boyer-Moore算法简介&quot;&gt;&lt;a href=&quot;#Boyer-Moore算法简介&quot; class=&quot;headerlink&quot; title=&quot;Boyer-Moore算法简介&quot;&gt;&lt;/a&gt;Boyer-Moore算法简介&lt;/h3&gt;&lt;p&gt;在用于查找子字符串的算法当中，BM（
      
    
    </summary>
    
      <category term="算法" scheme="https://9191rs.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="Boyer-Moore" scheme="https://9191rs.me/tags/Boyer-Moore/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配的KMP算法</title>
    <link href="https://9191rs.me/posts/12689/"/>
    <id>https://9191rs.me/posts/12689/</id>
    <published>2018-11-20T02:52:47.000Z</published>
    <updated>2018-11-20T06:53:35.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KMP算法的引出"><a href="#KMP算法的引出" class="headerlink" title="KMP算法的引出"></a>KMP算法的引出</h3><p>KMP(<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">Knuth-Morris-Pratt</a>)算法经常被用来解决字符串匹配的问题。<br>下面举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，如何判断里面是否包含另一个字符串”ABCDABD”？</p><p><strong>首先</strong>，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p><p><div align="center"><img src="/posts/12689/1542683196120.png" alt="Alt text"></div></p><p>接下来，因为B与A不匹配，搜索词再往后移。</p><p><div align="center"><img src="/posts/12689/1542683238725.png" alt="Alt text"></div></p><p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。</p><p><div align="center"><img src="/posts/12689/1542683247215.png" alt="Alt text"></div></p><p>接着比较字符串和搜索词的下一个字符，还是相同。</p><p><div align="center"><img src="/posts/12689/1542683334584.png" alt="Alt text"></div></p><p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p><p><div align="center"><img src="/posts/12689/1542683360690.png" alt="Alt text"></div></p><p><strong>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，时间复杂度为O( m * n)。因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</strong></p><p><div align="center"><img src="/posts/12689/1542683397329.png" alt="Alt text"></div></p><p>但是，通过观察可以发现，当空格与D不匹配时，其实已经知道了前面六个字符是”ABCDAB”。<strong>KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。时间复杂度为O( m *+ n)。</strong></p><h3 id="KMP算法的实现"><a href="#KMP算法的实现" class="headerlink" title="KMP算法的实现"></a>KMP算法的实现</h3><p>KMP算法的实现是先为要搜索的字符串算出一个部分匹配表( Partial Match Table)，当空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p><blockquote><p><div align="center"><strong>移动位数 = 已匹配的字符数 - 对应的部分匹配值</strong></div></p></blockquote><p>因为 6 - 2 等于4，所以将搜索词向后移动4位。用这种方法就实现了一次移动k位。</p><p>部分匹配的实质是，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。字符串的”前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。下面以”ABCDABD”为例介绍部分匹配表是如何产生的。</p><p><div align="center"> <img src="/posts/12689/1542685565462.png" alt="Alt text"></div></p><h3 id="Java代码的实现过程"><a href="#Java代码的实现过程" class="headerlink" title="Java代码的实现过程"></a>Java代码的实现过程</h3><p><strong>首先贴出完整的代码</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> KMP &#123;</span><br><span class="line">    <span class="comment">//字符串pattern为要匹配的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> kmp(String origin,String pattern)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = origin.length(),n = pattern.length();</span><br><span class="line">        <span class="keyword">if</span>(m &lt; n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] <span class="keyword">next</span> = getNext(pattern);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp;pattern.charAt(k) != origin.charAt(i))</span><br><span class="line">                k = <span class="keyword">next</span>[k-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pattern.charAt(k) == origin.charAt(i))</span><br><span class="line">                k++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(k == n) <span class="comment">// [i-m+1 , i]</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//部分匹配表的实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getNext(String s)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] <span class="keyword">next</span> = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">next</span>[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] p = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">1</span>;q&lt;p.length;q++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; p[k] != p[q])</span><br><span class="line">                k = <span class="keyword">next</span>[k-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(p[q] == p[k])</span><br><span class="line">                k++;</span><br><span class="line">            <span class="keyword">next</span>[q] = k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        KMP k = <span class="keyword">new</span> KMP();</span><br><span class="line"></span><br><span class="line">        System.out.<span class="keyword">println</span>(k.kmp(<span class="string">"BBC ABCDAB ABCDABCDABDE"</span>,<span class="string">"ABCDABD"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接着来看下部分匹配表实现思路(主要是while循环)</strong></p><ol><li>已知前一步计算时最大相同的前后缀长度为k（k&gt;0），即P[0]···P[k-1])。</li><li>此时比较第k项P[k]与P[q],如图1所示:</li><li>如果P[K]等于P[q]，那么很简单跳出while循环。</li><li><strong>如果不相等呢</strong>，此时就以该应该利用已经得到的next[0]···next[k-1]来求P[0]···P[k-1]这个子串中最大相同前后缀。此时，P[k]已经和P[q]失配，但是P[q-k] ··· P[q-1]又与P[0] ···P[k-1]相同，看来P[0]···P[k-1]这么长的子串是用不了了，那么要找的同样也是P[0]打头、P[k-1]结尾的子串即P[0]···P<a href="j==next[k-1]">j-1</a>，看看它的下一项P[j]是否能和P[q]匹配。如果匹配就跳出循环，否则继续查找下一个k。如图2所示。</li></ol><p><div align="center"><img src="/posts/12689/1542685327288.png" alt="Alt text"></div></p><hr><p>参考文章</p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法– 阮一峰</a></li><li><a href="http://www.cnblogs.com/c-cloud/p/3224788.html" target="_blank" rel="noopener"> KMP  深入讲解next数组的求解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;KMP算法的引出&quot;&gt;&lt;a href=&quot;#KMP算法的引出&quot; class=&quot;headerlink&quot; title=&quot;KMP算法的引出&quot;&gt;&lt;/a&gt;KMP算法的引出&lt;/h3&gt;&lt;p&gt;KMP(&lt;a href=&quot;https://en.wikipedia.org/wiki/Knu
      
    
    </summary>
    
      <category term="算法" scheme="https://9191rs.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="KMP" scheme="https://9191rs.me/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>前缀树--Trie</title>
    <link href="https://9191rs.me/posts/16324/"/>
    <id>https://9191rs.me/posts/16324/</id>
    <published>2018-11-19T11:16:27.000Z</published>
    <updated>2018-11-19T13:27:21.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前缀树–Trie"><a href="#前缀树–Trie" class="headerlink" title="前缀树–Trie"></a>前缀树–Trie</h3><p> Trie树即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。缺点是占用空间比较大。</p><p> Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的， 它有3个基本性质：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><p><div align="center"><img src="/posts/16324/1.jpg" alt=" "></div></p><p>对于有n个字符的单词序列来说，如果使用树结构，查询的时间复杂度是O(log n);如果使用哈希表存储，则有可能 出现大量的哈希冲突；而使用Trie存储，查询每个条目的复杂度和字典中一共有多少条目无关，之和字符串的长度有关。</p><h3 id="Trie的Java实现"><a href="#Trie的Java实现" class="headerlink" title="Trie的Java实现"></a>Trie的Java实现</h3><h4 id="Trie树结点的结构"><a href="#Trie树结点的结构" class="headerlink" title="Trie树结点的结构"></a>Trie树结点的结构</h4><p>用isWord表示是否当前结点是否为一个字符串的结尾。</p><h4 id="Trie树的添加"><a href="#Trie树的添加" class="headerlink" title="Trie树的添加"></a>Trie树的添加</h4><p>基本思想：<br>从根结点开始, 向下依次寻找当前结点的next中, 是否有与关键字key中相应位置的字母相同的next</p><ul><li>如果有，直接到下一层继续寻找</li><li>如果没有，则新建一个node, 插入当前结点的next中,然后到下一层继续寻找</li></ul><p>向下遍历到key的末尾时, 修改该结点的boolean指示值,表示是关键字末尾</p><h4 id="Trie树的单词查找"><a href="#Trie树的单词查找" class="headerlink" title="Trie树的单词查找"></a>Trie树的单词查找</h4><p>从单词的第一个单词开始，沿着Trie树进行查找，如果在某一层中查找不到，则直接返回false，否则，如果到达单词的结尾，判断当前层是否为一个单词的结尾。</p><h4 id="Trie树的前缀查找"><a href="#Trie树的前缀查找" class="headerlink" title="Trie树的前缀查找"></a>Trie树的前缀查找</h4><p>思路和单词查找差不多，只是不用判断是否为单词的结尾。</p><h4 id="辅助操作"><a href="#辅助操作" class="headerlink" title="辅助操作"></a>辅助操作</h4><p>记录Trie树中单词的个数。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Trie &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> class Node&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Node(<span class="keyword">boolean</span> isWord)&#123;</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            next = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Node()&#123;</span><br><span class="line">            <span class="keyword">this</span>(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Trie()&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得Trie中存储的单词数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getSize()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向Trie中添加一个新的单词word</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> add(<span class="keyword">String</span> <span class="keyword">word</span>)&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">word</span>.length() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = <span class="keyword">word</span>.charAt(i);</span><br><span class="line">            <span class="built_in">if</span>(cur.next.<span class="built_in">get</span>(c) == null)</span><br><span class="line">                cur.next.<span class="built_in">put</span>(c, <span class="keyword">new</span> Node());</span><br><span class="line">            cur = cur.next.<span class="built_in">get</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">if</span>(!cur.isWord)&#123;</span><br><span class="line">            cur.isWord = true;</span><br><span class="line">            <span class="built_in">size</span> ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归实现</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> add(<span class="keyword">String</span> <span class="keyword">word</span>,Node cur,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="built_in">if</span>(k == <span class="keyword">word</span>.length())&#123;</span><br><span class="line">            cur.isWord = true;</span><br><span class="line">            <span class="built_in">size</span> ++;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = <span class="keyword">word</span>.charAt(k);</span><br><span class="line">        <span class="built_in">if</span>(cur.next.<span class="built_in">get</span>(c) == null)</span><br><span class="line">            cur.next.<span class="built_in">put</span>(c, <span class="keyword">new</span> Node());</span><br><span class="line"></span><br><span class="line">        add(<span class="keyword">word</span>,cur.next.<span class="built_in">get</span>(c),k++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询单词word是否在Trie中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> contains(<span class="keyword">String</span> <span class="keyword">word</span>)&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">word</span>.length() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = <span class="keyword">word</span>.charAt(i);</span><br><span class="line">            <span class="built_in">if</span>(cur.next.<span class="built_in">get</span>(c) == null)</span><br><span class="line">                <span class="built_in">return</span> false;</span><br><span class="line">            cur = cur.next.<span class="built_in">get</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> cur.isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// //递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> contains(<span class="keyword">String</span> <span class="keyword">word</span>,Node cur,<span class="keyword">int</span> k)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">if</span>(<span class="keyword">word</span>.length() == k)</span><br><span class="line">            <span class="built_in">return</span> cur.isWord;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = <span class="keyword">word</span>.charAt(k);</span><br><span class="line">        <span class="built_in">if</span>(cur.next.<span class="built_in">get</span>(c) == null)</span><br><span class="line">            <span class="built_in">return</span> false;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> contains(<span class="keyword">word</span>,cur.next.<span class="built_in">get</span>(c),k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询是否在Trie中有单词以prefix为前缀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isPrefix(<span class="keyword">String</span> prefix)&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prefix.length() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="built_in">if</span>(cur.next.<span class="built_in">get</span>(c) == null)</span><br><span class="line">                <span class="built_in">return</span> false;</span><br><span class="line">            cur = cur.next.<span class="built_in">get</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isPrefix(<span class="keyword">String</span> <span class="keyword">word</span>,Node cur,<span class="keyword">int</span> k)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">if</span>(<span class="keyword">word</span>.length() == k)</span><br><span class="line">            <span class="built_in">return</span> true;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = <span class="keyword">word</span>.charAt(k);</span><br><span class="line">        <span class="built_in">if</span>(cur.next.<span class="built_in">get</span>(c) == null)</span><br><span class="line">            <span class="built_in">return</span> false;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> contains(<span class="keyword">word</span>,cur.next.<span class="built_in">get</span>(c),k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Trie的海量数据中的应用"><a href="#Trie的海量数据中的应用" class="headerlink" title="Trie的海量数据中的应用"></a>Trie的海量数据中的应用</h3><ul><li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li><li>1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</li><li>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li></ul><h3 id="leetcode中的一些练习题"><a href="#leetcode中的一些练习题" class="headerlink" title="leetcode中的一些练习题"></a>leetcode中的一些练习题</h3><ul><li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree)</a></li><li><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/description/" target="_blank" rel="noopener">211. Add and Search Word - Data structure design</a></li><li><a href="https://leetcode.com/problems/map-sum-pairs/description/" target="_blank" rel="noopener">677. Map Sum Pairs</a></li></ul><hr><p>参考文章</p><ul><li><a href="https://www.cnblogs.com/luosongchao/p/3239521.html" target="_blank" rel="noopener">trie树（前缀树）</a></li><li><a href="https://blog.csdn.net/l947069962/article/details/77650918" target="_blank" rel="noopener">Trie (Prefix Tree) 前缀树</a></li><li><a href="https://blog.csdn.net/v_july_v/article/details/6685962" target="_blank" rel="noopener">海量数据处理面试题集锦</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前缀树–Trie&quot;&gt;&lt;a href=&quot;#前缀树–Trie&quot; class=&quot;headerlink&quot; title=&quot;前缀树–Trie&quot;&gt;&lt;/a&gt;前缀树–Trie&lt;/h3&gt;&lt;p&gt; Trie树即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用
      
    
    </summary>
    
      <category term="数据结构" scheme="https://9191rs.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
      <category term="数据结构" scheme="https://9191rs.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第802题 Find Eventual Safe States</title>
    <link href="https://9191rs.me/posts/31267/"/>
    <id>https://9191rs.me/posts/31267/</id>
    <published>2018-11-09T08:24:29.000Z</published>
    <updated>2018-11-09T09:51:46.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p><div align="center"><img src="/posts/31267/1.jpg" alt=" "><br>根据题意，安全点的定义是经过有限条路径，可以到达终点。</div></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题可以用DFS的思路去解决。只要能判断一个点不成环，那么就可以认为这个点是一个安全点。所以如何判断是否成环就很关键。</p><p>下面开始我的心酸历程。</p><h3 id="最初的想法：-Time-Limit-Exceeded"><a href="#最初的想法：-Time-Limit-Exceeded" class="headerlink" title="最初的想法： Time Limit Exceeded"></a>最初的想法： Time Limit Exceeded</h3><p>刚开始，我的想法比较简单，就是我从节点i出发，经过dfs遍历，又会回到节点i，则认为节点i已经成环，也就是一个不安全的点。但是，这个想法会重复遍历很多节点。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>  List&lt;Integer&gt; eventualSafeNodes(<span class="built_in">int</span>[][] graph) &#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">HashMap</span>&lt;Integer,List&lt;Integer&gt;&gt; hm = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;graph.length;i++)&#123;</span><br><span class="line">           hm.put(i,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">           List&lt;Integer&gt; t = hm.<span class="built_in">get</span>(i);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="built_in">int</span> s : graph[i])</span><br><span class="line">               t.<span class="built_in">add</span>(s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;graph.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(dfs(hm,i,i,<span class="keyword">false</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">           res.<span class="built_in">add</span>(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回true代表从from出发形成了环</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span>  <span class="built_in">boolean</span> dfs(<span class="keyword">HashMap</span>&lt;Integer,List&lt;Integer&gt;&gt; hm,<span class="built_in">int</span> from ,<span class="built_in">int</span> to,<span class="built_in">boolean</span> flag)&#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Integer&gt; t = hm.<span class="built_in">get</span>(from);</span><br><span class="line">       <span class="keyword">if</span>(t.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(flag &amp;&amp; from == to)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> s : t)</span><br><span class="line">           <span class="keyword">if</span>(dfs(hm,s,to,<span class="keyword">true</span>))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="改进1：-Time-Limit-Exceeded"><a href="#改进1：-Time-Limit-Exceeded" class="headerlink" title="改进1： Time Limit Exceeded"></a>改进1： Time Limit Exceeded</h3><p>所以有了第一个改进，就是把遍历过程中所有的不安全点记录下来，如果再次碰到，就直接返回。然而，这个想法依然是 Time Limit Exceeded。仔细想了想，原因是把不安全的点分为两种：还没有访问过的点和安全点。在这里，仍然安全点仍然会被访问。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  List&lt;Integer&gt; eventualSafeNodes(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>)  <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] memo = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length]; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(graph,i,memo)) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        res.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回true代表从from出发形成了环</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> dfs(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> <span class="keyword">from</span>, <span class="keyword">boolean</span>[] memo)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(memo[<span class="keyword">from</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    memo[<span class="keyword">from</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s : graph[<span class="keyword">from</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[s] || dfs(graph, s, memo))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memo[<span class="keyword">from</span>] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="改进2：Accepted"><a href="#改进2：Accepted" class="headerlink" title="改进2：Accepted"></a>改进2：Accepted</h3><p>将所有的分为三类：未访问过的点、安全点和非安全点。在判断过程中当碰到已经访问过的点，就可以直接返回这个点的状态。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  List&lt;Integer&gt; <span class="title">eventualSafeNodes</span>(<span class="params"><span class="keyword">int</span>[][] graph</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(graph == <span class="literal">null</span> || graph.length == <span class="number">0</span>)  <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length]; <span class="comment">//0 未访问 1 不安全 2 安全</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(dfs(graph,i,memo)) <span class="keyword">continue</span>;</span><br><span class="line">           </span><br><span class="line">           res.<span class="keyword">add</span>(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回true代表从from出发形成了环</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  boolean <span class="title">dfs</span>(<span class="params"><span class="keyword">int</span>[][] graph, <span class="keyword">int</span> <span class="keyword">from</span>, <span class="keyword">int</span>[] memo</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(memo[<span class="keyword">from</span>] &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> memo[<span class="keyword">from</span>] == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       memo[<span class="keyword">from</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> s : graph[<span class="keyword">from</span>]) &#123;</span><br><span class="line">           <span class="keyword">if</span>(memo[<span class="keyword">from</span>]==<span class="number">2</span>) <span class="comment">//如果再循环中可以群人memo[from]为安全点，则退出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ( memo[s]==<span class="number">1</span> || dfs(graph, s, memo))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       memo[<span class="keyword">from</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>一点思考：</strong>在用DFS算法解决问题中，如果出现对一些数据重复使用，可以采用记忆化搜索和动态规划的方法去提高算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;/posts/31267/1.jpg&quot; alt=&quot; &quot;&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第743题 Network Delay Time</title>
    <link href="https://9191rs.me/posts/14185/"/>
    <id>https://9191rs.me/posts/14185/</id>
    <published>2018-11-07T06:22:22.000Z</published>
    <updated>2018-11-07T06:48:01.767Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><div align="center"><img src="/posts/14185/1.jpg" alt=" "></div></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p> Dijkstra算法经常被用来求解有权图中的最短路径问题。而本题要求的是网络的最大延迟，思路基本一致，求出从源点到每个节点的最短路径，然后取出最大的那个即可。</p><h4 id="DFS算法"><a href="#DFS算法" class="headerlink" title="DFS算法"></a>DFS算法</h4><p>维护一个从源点到每个节点的距离数组，初始值都为 MAX_VALUE，然后从源点开始遍历整个图，在遍历的过程如果到节点的值小于当前的值，就更新，反之则结束。</p><p>注：上述两种方法都把图用HashMap存了起来，这样的话加快了在后面的查找速度。</p><h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><h4 id="Dijkstra算法-1"><a href="#Dijkstra算法-1" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span>(<span class="params"><span class="keyword">int</span>[][] times, <span class="keyword">int</span> n, <span class="keyword">int</span> k</span>) </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(<span class="params">Node o1, Node o2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.d - o2.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: times) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!graph.containsKey(edge[<span class="number">0</span>]))</span><br><span class="line">                graph.put(edge[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;());</span><br><span class="line">            graph.<span class="keyword">get</span>(edge[<span class="number">0</span>]).<span class="keyword">add</span>(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;edge[<span class="number">1</span>], edge[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    Node[] nodes = <span class="keyword">new</span> Node[n];</span><br><span class="line">    <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    dis[i] = <span class="number">-1</span>;</span><br><span class="line">    dis[k<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    nodes[k<span class="number">-1</span>] = <span class="keyword">new</span> Node(k, <span class="number">0</span>);</span><br><span class="line">    pq.<span class="keyword">add</span>(nodes[k<span class="number">-1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">    Node v = pq.poll();</span><br><span class="line">    <span class="keyword">if</span>(graph.containsKey(v.s))&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: graph.<span class="keyword">get</span>(v.s))&#123;</span><br><span class="line">        <span class="keyword">int</span> w = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> d = dis[v.s - <span class="number">1</span>] + edge[<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dis[w<span class="number">-1</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">        dis[w<span class="number">-1</span>]  = d;</span><br><span class="line">        nodes[w<span class="number">-1</span>] =  <span class="keyword">new</span> Node(w, d);</span><br><span class="line">        pq.<span class="keyword">add</span>(nodes[w<span class="number">-1</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dis[w<span class="number">-1</span>] &gt; d)&#123;</span><br><span class="line">        pq.<span class="keyword">remove</span>(nodes[w<span class="number">-1</span>] );</span><br><span class="line">        dis[w<span class="number">-1</span>] = d;</span><br><span class="line">        nodes[w<span class="number">-1</span>] =  <span class="keyword">new</span> Node(w, d);</span><br><span class="line">        pq.<span class="keyword">add</span>(nodes[w<span class="number">-1</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = dis[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[i] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dis[i] &gt; max)</span><br><span class="line">    max = dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"><span class="keyword">int</span> s,<span class="keyword">int</span> d</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line"><span class="keyword">this</span>.d = d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DFS算法-1"><a href="#DFS算法-1" class="headerlink" title="DFS算法"></a>DFS算法</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span>[] dis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> networkDelayTime(<span class="built_in">int</span>[][] times, <span class="built_in">int</span> n, <span class="built_in">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        Map&lt;Integer, List&lt;<span class="built_in">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span>[] edge: times) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!graph.containsKey(edge[<span class="number">0</span>]))</span><br><span class="line">                graph.put(edge[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;<span class="built_in">int</span>[]&gt;());</span><br><span class="line">            graph.<span class="built_in">get</span>(edge[<span class="number">0</span>]).<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">int</span>[]&#123;edge[<span class="number">1</span>], edge[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> node: graph.keySet()) &#123;</span><br><span class="line">            Collections.<span class="built_in">sort</span>(graph.<span class="built_in">get</span>(node), (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    dis = <span class="keyword">new</span> <span class="built_in">int</span>[n]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    dis[i] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    dfs(graph,k,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">max</span> = dis[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[i] == Integer.MAX_VALUE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dis[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">    <span class="built_in">max</span> = dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> dfs(Map&lt;Integer, List&lt;<span class="built_in">int</span>[]&gt;&gt; graph, <span class="built_in">int</span> node, <span class="built_in">int</span> d) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[node<span class="number">-1</span>] &lt;= d) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">dis[node<span class="number">-1</span>] = d;</span><br><span class="line"><span class="keyword">if</span>(graph.containsKey(node))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span>[] edge : graph.<span class="built_in">get</span>(node))</span><br><span class="line">dfs(graph, edge[<span class="number">0</span>], edge[<span class="number">1</span>] + d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>参见数据结构与算法经典问题描解析第226页</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;/posts/14185/1.jpg&quot; alt=&quot; &quot;&gt;&lt;/di
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode Insert Delete GetRandom O(1) </title>
    <link href="https://9191rs.me/posts/38306/"/>
    <id>https://9191rs.me/posts/38306/</id>
    <published>2018-11-06T03:28:33.000Z</published>
    <updated>2018-11-06T06:51:51.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode第380题-Insert-Delete-GetRandom-O-1"><a href="#leetcode第380题-Insert-Delete-GetRandom-O-1" class="headerlink" title="leetcode第380题 Insert Delete GetRandom O(1)"></a>leetcode第380题 Insert Delete GetRandom O(1)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><div align="center"><img src="/posts/38306/1.jpg" alt=""></div></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>用HashMap和ArrayList组合来模拟三个操作：</p><p><strong>insert</strong>： 如果val已经存在与HashMap中，则直接返回false。反之，则以val为键，以val在ArrayList中的索引为值作为键值对插入到HashMap中，返回true。</p><p><strong>remove</strong>：根据val的键进行定位。如果不存在，则返回false。然后取出对应的值，这个值代表了其在ArrayList的位置，如果不是最后一个，则将其和ArrayList中的最后一个进行交换。</p><p><strong>getRandom</strong>：利用nextInt( )函数随机生成一个[0,list.size()-1]之间的数，并返回在ArrayList中对应的值。<br>O(1)时间分析：HashMap的查找和插入操作都是O(1)的，ArrayList的查找也是O(1)。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"></span><br><span class="line">HashMap&lt;Integer, Integer&gt; hs = null;</span><br><span class="line">ArrayList&lt;Integer&gt; <span class="built_in">list</span> = null;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hs.containsKey(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        hs.put(val, <span class="built_in">list</span>.size());</span><br><span class="line">        <span class="built_in">list</span>.add(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!hs.containsKey(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = hs.get(val);</span><br><span class="line">    <span class="keyword">if</span>(t &lt; <span class="built_in">list</span>.size()<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">list</span>.get(<span class="built_in">list</span>.size()<span class="number">-1</span>);</span><br><span class="line">    hs.put(l, t);</span><br><span class="line">    <span class="built_in">list</span>.<span class="built_in">set</span>(t, l);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    hs.remove(val);</span><br><span class="line">    <span class="built_in">list</span>.remove(<span class="built_in">list</span>.size()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>.get(rand.nextInt(<span class="built_in">list</span>.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode第381题-Insert-Delete-GetRandom-O-1-Duplicates-allowed"><a href="#leetcode第381题-Insert-Delete-GetRandom-O-1-Duplicates-allowed" class="headerlink" title="leetcode第381题 Insert Delete GetRandom O(1) - Duplicates allowed"></a>leetcode第381题 Insert Delete GetRandom O(1) - Duplicates allowed</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><div align="center"><img src="/posts/38306/2.jpg" alt=""></div></p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>用HashMap和ArrayList以及LinkedList组合来模拟三个操作：</p><p><strong>insert</strong>： 如果val已经存在与HashMap中，则取出对应的LinkedList，将其在ArrayList中的索引值放在尾部，更新对应的记录，并返回false。反之，则以val为键，新建一个LinkedList，将其在ArrayList中的索引值放在尾部，插入对应的记录，并返回true。</p><p><strong>remove</strong>：根据val的键进行定位。如果不存在，则返回false。然后取出对应的LinkedList尾部的值，这个值代表了其在ArrayList的位置，如果不是最后一个，则需要取出ArrayList中的最后一个元素对应的LinkedList，并用这个LinkedList的首部和其进行交换。如果val对应的LinkedList的size为1，则移除这条记录。</p><p><strong>getRandom</strong>：利用nextInt( )函数随机生成一个[0,list.size()-1]之间的数，并返回在ArrayList中对应的值。</p><p>O(1)时间分析：HashMap的查找和插入操作都是O(1)的，ArrayList的查找也是O(1)的，LinkedList只在首尾进行操作，也是O(1)。</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class RandomizedCollection &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">HashMap</span>&lt;Integer, LinkedList&lt;Integer&gt;&gt; hs = <span class="keyword">null</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">null</span>;</span><br><span class="line">Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">public</span> RandomizedCollection() &#123;</span><br><span class="line">    hs = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> insert(<span class="built_in">int</span> val) &#123;</span><br><span class="line">        </span><br><span class="line">    LinkedList&lt;Integer&gt; t = hs.getOrDefault(val, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        t.<span class="built_in">add</span>(list.<span class="built_in">size</span>());</span><br><span class="line">        hs.put(val, t);</span><br><span class="line">        list.<span class="built_in">add</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">size</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> remove(<span class="built_in">int</span> val) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(!hs.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    LinkedList&lt;Integer&gt; t = hs.<span class="built_in">get</span>(val);</span><br><span class="line">    <span class="built_in">int</span> p = t.<span class="built_in">get</span>(t.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p &lt; list.<span class="built_in">size</span>() <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">int</span> l = list.<span class="built_in">get</span>(list.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    LinkedList&lt;Integer&gt; tl = hs.<span class="built_in">get</span>(l);</span><br><span class="line">      </span><br><span class="line">    tl.removeFirst();</span><br><span class="line">    tl.<span class="built_in">add</span>(p);</span><br><span class="line">    hs.put(l, tl);</span><br><span class="line">    list.<span class="built_in">set</span>(p, l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    list.remove(list.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(t.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">    hs.remove(val);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    t.remove(t.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    hs.put(val, t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> getRandom() &#123;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="built_in">get</span>(rand.nextInt(list.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;leetcode第380题-Insert-Delete-GetRandom-O-1&quot;&gt;&lt;a href=&quot;#leetcode第380题-Insert-Delete-GetRandom-O-1&quot; class=&quot;headerlink&quot; title=&quot;leetcode第3
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第179题 Largest Number</title>
    <link href="https://9191rs.me/posts/26752/"/>
    <id>https://9191rs.me/posts/26752/</id>
    <published>2018-11-01T09:00:57.000Z</published>
    <updated>2018-11-01T09:20:40.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数数组，把数组里的所有数字拼接成为一个数，求能拼接出的所有数字中最大的那个。</p><p><div align="center"><img src="/posts/26752/1.jpg" alt=""></div></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题的暴力解法是先求出这个数组中所有数字的全排列，然后把每个排列拼接起来，最后求出拼起来的数字的最大值。<br>但是如果能找到一个排序规则，使得根据这个规则排出来的数组能排成一个最大的数字。要确定排序规则，就得比较两个数字，也就是给出两个数字m和n，我们需要确定一个规则m和n哪个更大，而不是仅仅只是比较这两个数字的数值哪个更大。<br>根据题目的要求，两个数字m和n能够拼接成数字mn和nm。如果mn &lt; nm,则应该打印nm。也就是n应该在m前面。反之，m应该在n前面。<br>同时应该注意两个数字的拼接过程中可能会出现溢出，而一个解决大数问题的思路就是把数字转换为字符串。同时mn和nm的长度相等，按照字符串大小的比较规则就可以。</p><h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  public  String largestNumber(int[] nums) &#123;</span><br><span class="line">      </span><br><span class="line">  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">  StringBuilder <span class="keyword">sb </span>= new StringBuilder()<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  int z = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">  for(int t : nums)&#123;</span><br><span class="line">  list.<span class="keyword">add(t);</span></span><br><span class="line"><span class="keyword"> </span> if(t == <span class="number">0</span>)</span><br><span class="line">  z++<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">      if(z==nums.length)</span><br><span class="line">  return <span class="string">"0"</span><span class="comment">;</span></span><br><span class="line">      </span><br><span class="line">  Collections.sort(list,new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int <span class="built_in">compare</span>(Integer <span class="built_in">t1</span>, Integer <span class="built_in">t2</span>) &#123;</span><br><span class="line">String <span class="built_in">s1</span> = <span class="built_in">t1</span>.toString() + <span class="built_in">t2</span>.toString()<span class="comment">;</span></span><br><span class="line">String <span class="built_in">s2</span> = <span class="built_in">t2</span>.toString() + <span class="built_in">t1</span>.toString()<span class="comment">;</span></span><br><span class="line">return <span class="built_in">s2</span>.compareTo(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  for(int t : list)</span><br><span class="line">  <span class="keyword">sb.append(t);</span></span><br><span class="line"><span class="keyword"> </span> </span><br><span class="line">  return <span class="keyword">sb.toString();</span></span><br><span class="line"><span class="keyword"> </span> &#125;</span><br></pre></td></tr></table></figure><hr><ul><li><strong>详情请参见剑指offer第二版面试题45</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一个正整数数组，把数组里的所有数字拼接成为一个数，求能拼接出的所有数字中最大的那个。&lt;/p&gt;
&lt;p&gt;&lt;div align
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
      <category term="剑指offer" scheme="https://9191rs.me/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第84题 Largest Rectangle in Histogram</title>
    <link href="https://9191rs.me/posts/44614/"/>
    <id>https://9191rs.me/posts/44614/</id>
    <published>2018-10-31T08:58:12.000Z</published>
    <updated>2018-10-31T09:30:23.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>直方图是由排列在同一基线上的一系列矩形组成的多边形。为了简单起见，假设这些矩形的宽度相等但高度可能不同。</p><p><div align="center"><img src="/posts/44614/1.jpg" alt=""></div></p><h3 id="一种解题思路"><a href="#一种解题思路" class="headerlink" title="一种解题思路"></a>一种解题思路</h3><p>这个问题有多种解法，包含枚举、动态规划、分治等等。现在采用一种巧妙的方法，使用堆栈，将复杂度降到最低。</p><p><strong>算法思想：</strong></p><ol><li>新建一个空栈，栈中存放数组的下标。</li><li>hs[i] 与栈顶元素比较。如果hs[i] 大与等于栈顶元素，那么将i其入栈。如果A[i]小于当前栈顶元素，说明已经找到第一个位于栈顶右边的比它小的值（此时这个较小的元素还未入栈），在它的左边（在栈内就是它脚下的元素）即为第一个左边比它小的值。此时需要这样做：<ul><li>以栈顶元素为最小高度计算最大矩形面积，并更新现在的最大面积，宽度为左边界到右边界。</li><li>弹出栈顶元素。</li><li>重复第2步。</li></ul></li></ol><p>3.扫描完后，一般会剩下一个单调递增的堆栈，那么一个一个出栈计算面积就可以了。</p><ul><li>时间复杂度：O(n)(高效率)</li><li>空间复杂度：O(n)(栈开销)</li></ul><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> largestRectangleArea(<span class="keyword">int</span>[] hs) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(hs==<span class="keyword">null</span> || hs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> n = hs.length;</span><br><span class="line">    Stack&lt;Integer&gt; sk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    sk.<span class="keyword">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;n&amp;&amp;hs[i] &gt;= hs[sk.peek()])&#123;</span><br><span class="line">    sk.<span class="keyword">push</span>(i);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;n&amp;&amp;hs[sk.peek()] &lt;= hs[i])</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cur = sk.<span class="keyword">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!sk.isEmpty()) l = sk.peek() + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r = i - <span class="number">1</span>;</span><br><span class="line">    res = Math.max(res, hs[cur] * (r-l+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    sk.<span class="keyword">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">           </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><ul><li><a href="https://blog.csdn.net/u012534831/article/details/74356851" target="_blank" rel="noopener">算法-直方图中的最大矩形</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;直方图是由排列在同一基线上的一系列矩形组成的多边形。为了简单起见，假设这些矩形的宽度相等但高度可能不同。&lt;/p&gt;
&lt;p&gt;&lt;d
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Trapping Rain Water</title>
    <link href="https://9191rs.me/posts/32607/"/>
    <id>https://9191rs.me/posts/32607/</id>
    <published>2018-10-25T13:34:07.000Z</published>
    <updated>2018-10-26T01:39:31.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trapping-Rain-Water-I"><a href="#Trapping-Rain-Water-I" class="headerlink" title="Trapping Rain Water I"></a>Trapping Rain Water I</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定n个非负整数表示每个条的宽度为1的高度图，计算下雨后能够捕获多少水。<br><img src="/posts/32607/1.png" alt="Alt text"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>采用双指针的办法，使右指针不断向后移动，知道第一个出现比左指针位置大的地方，计算左右指针之间可以放多少水，不断重复这个过程直到结束。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span> trap(<span class="keyword">int</span>[] h) &#123;</span><br><span class="line"> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> len = h.length;</span><br><span class="line"> <span class="keyword">if</span>(h.length&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(r&lt;len&amp;&amp;l&lt;=r&amp;&amp;h[l]==<span class="number">0</span>)     </span><br><span class="line"> l = ++r;</span><br><span class="line"> </span><br><span class="line"> Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"> <span class="keyword">while</span>(r&lt;len)&#123;</span><br><span class="line"> r++;</span><br><span class="line"> <span class="keyword">if</span>(r==len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(h[r]&gt;=h[l])&#123;</span><br><span class="line"> res += h[l] * (r-l-<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">res -= s.<span class="keyword">pop</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> l = r;  </span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"> &#125;     </span><br><span class="line"> s.<span class="keyword">push</span>(h[r]);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">int</span> tem = s.<span class="keyword">size</span>();</span><br><span class="line"> <span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[tem+<span class="number">1</span>];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tem;i++)</span><br><span class="line"> m[i] = s.<span class="keyword">pop</span>(); </span><br><span class="line"> </span><br><span class="line"> m[tem] = h[l];  </span><br><span class="line"> t = trap(m);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res + t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trapping-Rain-Water-II"><a href="#Trapping-Rain-Water-II" class="headerlink" title="Trapping Rain Water II"></a>Trapping Rain Water II</h2><h3 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定m x n正整数矩阵表示2D平面图中每个单元格的高度，计算下雨后它能够捕获的水量。<br><strong>注意：</strong>m和n均小于110.每个单元格的高度大于0且小于20,000。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>二维的原理和一维的思路基本是一样的。在一维中只需从两个端点选一个即可，而在二维中可选的点就扩大成了整个矩形的边．根据上一题知道同样每次应该先选取边界最小的高度，所以很自然的可以想到应该用优先队列来保存周围边界（小顶堆）．在访问过了一个点之后要继续往矩形内部遍历，这样还需要保存一个点的位置．为了防止再次访问已经访问过的点还需要用一个数组来标记每个点的访问状态。时间复杂度应该是O(m<em>n</em>log(m+n))．</p><p><a href="http://www.cnblogs.com/grandyang/p/5928987.html" target="_blank" rel="noopener">详细可以参考这篇文章</a></p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] <span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">map</span>.length;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">map</span>[<span class="number">0</span>].length;</span><br><span class="line">        boolean used[][] = <span class="keyword">new</span> boolean[m][n];</span><br><span class="line">        <span class="keyword">int</span>[][] idx = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        PriorityQueue&lt;Cell&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Cell&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> compare(Cell c1, Cell c2) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c1.h - c2.h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">        <span class="comment">//第一列  最后一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        used[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        minHeap.offer(<span class="keyword">new</span> Cell(i, <span class="number">0</span>, <span class="built_in">map</span>[i][<span class="number">0</span>]));</span><br><span class="line">        used[i][n<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">        minHeap.offer(<span class="keyword">new</span> Cell(i, n<span class="number">-1</span>, <span class="built_in">map</span>[i][n<span class="number">-1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一行 最后一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        used[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        minHeap.offer(<span class="keyword">new</span> Cell(<span class="number">0</span>, i, <span class="built_in">map</span>[<span class="number">0</span>][i]));</span><br><span class="line">        used[m<span class="number">-1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        minHeap.offer(<span class="keyword">new</span> Cell(m<span class="number">-1</span>, i, <span class="built_in">map</span>[m<span class="number">-1</span>][i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!minHeap.isEmpty())&#123;</span><br><span class="line">        Cell cur = minHeap.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = cur.x + idx[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny = cur.y + idx[i][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;nx&lt;m&amp;&amp;ny&lt;n&amp;&amp;!used[nx][ny])&#123;</span><br><span class="line">        used[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.h &gt; <span class="built_in">map</span>[nx][ny]) </span><br><span class="line">        res += cur.h - <span class="built_in">map</span>[nx][ny];</span><br><span class="line">        </span><br><span class="line">        minHeap.offer(<span class="keyword">new</span> Cell(nx, ny, Math.max(cur.h, <span class="built_in">map</span>[nx][ny])));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cell</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line"><span class="keyword">this</span>.h = h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><ul><li><a href="http://www.cnblogs.com/grandyang/p/5928987.html" target="_blank" rel="noopener">Trapping Rain Water II 收集雨水之二</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Trapping-Rain-Water-I&quot;&gt;&lt;a href=&quot;#Trapping-Rain-Water-I&quot; class=&quot;headerlink&quot; title=&quot;Trapping Rain Water I&quot;&gt;&lt;/a&gt;Trapping Rain Water I&lt;/
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot&amp;Netty实现仿微信网页版</title>
    <link href="https://9191rs.me/posts/15239/"/>
    <id>https://9191rs.me/posts/15239/</id>
    <published>2018-10-10T01:44:28.000Z</published>
    <updated>2019-04-03T01:26:34.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Netty是一个基于基于Java NIO的网络应用框架和client-server框架，提供了对TCP、UDP和文件传输的支持。Netty不仅能实现消息的转发，而且可以主动推送消息给客户端。在学习过程中，突然想到可以用Netty作为核心，用WebSocket为应用层通信协议做一个互联网聊天系统。<br>WebSocket是一种基于Http协议开发的一种支持浏览器和服务端进行全双工通信的协议。它的特点是支持服务端的主动推送和通信的开销比较小（长连接，首部信息量小）。但是由于是基于Http开发，所以只能由客户端发起连接请求，在建立Http连接之后，会有一次额外的握手操作，将Http协议转为WebSocket协议。</p><h2 id="整体说明"><a href="#整体说明" class="headerlink" title="整体说明"></a>整体说明</h2><p>本次开发采用了前后端分离的想法，前端通过向后端发送AjAx请求获取相应的信息。在部署到服务器的时候，前端页面放到了Tomcat之下实现访问，后端的工程通过Maven打成了jar包，利用SpringBoot提供的内置Tomcat运行。</p><p>SpringBoot和MyBatis构成了后端的主要架构。主要用来处理用户的相关请求，比如登录、获取好友列表、获取聊天记录等等。而SprngBoot整合的Netty WebSockt服务主要处理用户消息通信的WebSocket类型请求，用户通过浏览器登录后，根据用户id建立一条WebSocket连接并保存在后端以便进行实时通信。当一个用户向另一用户发起通信，服务器会根据消息内容中的对话方用户id，找到保存的WebSocket连接，通过该连接发送消息，对方就能够收到即时收到消息。当用户注销或退出时，释放WebSocket连接。</p><p>同时利用用户和服务器之间的 WebSockt连接实现了心跳检测功能，当用户登录后，前端会定时向后端发送心跳请求，如果在约定的时间没有收到，就释放该WebSockt连接。</p><p>整个系统采用了<a href="https://github.com/bingoohuang/idworker-client" target="_blank" rel="noopener">Idworker</a>为数据库中的每一条记录生成唯一的记录。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>系统采用B/S结构，主要事务逻辑在服务器端实现。</p><p>项目后端结构：<br><img src="/posts/15239/1.jpg" alt=""></p><p>项目前端结构：<br><img src="/posts/15239/2.jpg" alt=""></p><p>数据库结构：<br><img src="/posts/15239/6.jpg" alt=""></p><h3 id="后端功能模块"><a href="#后端功能模块" class="headerlink" title="后端功能模块"></a>后端功能模块</h3><h4 id="登录注册模块"><a href="#登录注册模块" class="headerlink" title="登录注册模块"></a>登录注册模块</h4><p>用户在登录的时，先到Users表中查询用户是否存在，如果不存在或者密码错误，返回相应的提示信息，如果正确，则返回用户的完整信息。<br>用户在注册的时候，也先到Users表中查询用户是否存在，如果已经存在就不能继续创建了，返回一个提示信息，如果不存在就在Users表中插入一条记录，并且返回到该用户的初始信息。</p><h4 id="查找并添加好友"><a href="#查找并添加好友" class="headerlink" title="查找并添加好友"></a>查找并添加好友</h4><p>根据用户的用户名进行查找，满足用户存在，不是自己，不是自己的好友三个条件，则返回要查找的用户，否则只能返回相迎的提示信息。<br>在得到要添加的好友信息，进行添加时，需要在friends_request表中添加相应的记录，一个添加请求只会在保存一次。<br>在收到添加好友请求后，用户可以选择接受或者拒绝，如果拒绝，删除friends_request表中相应的记录。如果接受，先删除friends_request表中添加相应的记录，并且在my_friends表中添加相应的记录。<br>要获取用户的所有好友，则需要先在my_friends表中根据用户的ID查找好友的ID，然后去Users表中查找并返回所有的好友信息。</p><h4 id="修改呢称和修改用户头像"><a href="#修改呢称和修改用户头像" class="headerlink" title="修改呢称和修改用户头像"></a>修改呢称和修改用户头像</h4><p>修改呢称和修改用户头像的思路基本一致，都是将根据用户的ID在Users表中将相应的信息进行更改即可。<br>用户上传的头像保存在用FastDFS搭建的图片服务器上，它在用户上传完图像之后都会返回一个地址，只要将该地址保存在数据库中即可。</p><h4 id="Netty-WebSockt服务模块"><a href="#Netty-WebSockt服务模块" class="headerlink" title="Netty WebSockt服务模块"></a>Netty WebSockt服务模块</h4><p>详细的Netty创建WebSockt服务的过程可以参考这篇<a href="https://blog.csdn.net/javadhh/article/details/66477423" target="_blank" rel="noopener">文章</a>。<br>对于接收到的信息分为5种：</p><ul><li><strong>登录</strong><br>用户登录的后，前端初始化WebSockt服务，并向后端送消息，后端接收到以后，将用户ID和channnel信息保存到一个HashMap中，且在保存之前要进行判断HashMap是否已经保存了一个对应的信息，如果有的话，则应该通过向该channel发送一个<strong>ISLOGIN类型</strong>的信息，强制让旧的用户下线。</li><li><strong>聊天类型的消息</strong><br>先将消息保存到chat_msg表中，同时标记消息未签收。如果接收者在线，同时将消息发给接收者。</li><li><strong>消息签收</strong><br>对消息进行签收的目的是确定消息已经到达了对方的电脑。没有签收的消息，会在用户下次登录的过程中，全部被改用户所接受。</li><li><strong>心跳包</strong><br>Netty提供了空闲状态事件，如果在一定时间内收不到心跳包，就可以认为用户已经下线，应该移除相应的WebSockt连接。</li></ul><h3 id="前端功能模块"><a href="#前端功能模块" class="headerlink" title="前端功能模块"></a>前端功能模块</h3><p>前端主要分为两个模块：登录和注册模块和聊天模块。</p><h4 id="登录和注册模块"><a href="#登录和注册模块" class="headerlink" title="登录和注册模块"></a>登录和注册模块</h4><p>登录和注册模块主要是进行用户信息管理，登录或者注册成功后，会将用户的信息保存到本地。</p><h4 id="聊天模块"><a href="#聊天模块" class="headerlink" title="聊天模块"></a>聊天模块</h4><p>聊天模块又可以分为三个小的模块：聊天快照、联系人列表和聊天窗口。</p><ul><li><strong>聊天窗口</strong><br>根据缓存好的好友信息，唯一的生成每个好友的聊天窗口，并且动态的嵌入到网页中，根据用户的选择进行显示。在每次进行窗口显示的过程中，又会读取缓存的聊天录，并且动态的显示在聊天窗口之中。<br>缓存的好友信息会随着心跳包定时进行更新，或者在通过用户好友请求后进行更新。缓存的好友消息会在接收到消息之后就进行更新。</li><li><strong>联系人列表</strong><br>联系人列表分为好友请求和好友，都是通过缓存好的信息进行动态加载和显示。缓存的信息是随着心跳包在不断定时更新。</li><li><strong>聊天快照</strong><br>聊天快照会在用户收到消息或者发送消息的时候进行动态更新。</li></ul><h2 id="实现效果及演示"><a href="#实现效果及演示" class="headerlink" title="实现效果及演示"></a>实现效果及演示</h2><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>现在通过把Netty和SpringBoot整合，实现的功能有以下几点：</p><ul><li>用户的登录和注册</li><li>修改登录用户的呢称，头像</li><li>添加好友</li><li>一对一聊天</li><li>心跳检测，定时刷新用户信息</li><li>同一个用户只能在一处登录</li></ul><p><strong>待完善的功能：</strong></p><ul><li>前端页面的美化<br>现在的界面主要是参考<a href="http://www.jqueryfuns.com/resource/3492" target="_blank" rel="noopener">素材火</a>这个界面实现的，为了实现功能写的比较烂（主要是拼凑，无奈）。</li><li>实现表情包，文件的发送</li><li>完善搜索功能</li><li>实现群聊</li></ul><p>登录界面：<br><img src="/posts/15239/3.jpg" alt=""></p><p>聊天界面：<br><img src="/posts/15239/4.jpg" alt=""></p><p><img src="/posts/15239/5.jpg" alt=""></p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>git源码地址: <a href="https://github.com/LLLRS/SpringBoot-Netty" target="_blank" rel="noopener">LLLRS GitHub</a></p><p><a href="http://157.230.149.25:8080/Netty/login.html" target="_blank" rel="noopener">在线演示地址</a><br><strong>账户1: mian  密码： main</strong><br><strong>账户2: test1  密码： test1</strong><br><strong>账户3: test2  密码： test2</strong></p><p><strong>注意：</strong><br>由于前端会把用户的信息都会缓存到本地浏览器，如果在同一台电脑上测试的话，需要用不同的浏览器登录不同的用户。</p><hr><p>参考链接</p><ul><li><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">WebSocket 是什么原理？为什么可以实现持久连接？</a></li><li><a href="https://blog.csdn.net/javadhh/article/details/66477423" target="_blank" rel="noopener">Netty应用</a></li><li><a href="https://segmentfault.com/a/1190000015681145#articleHeader8" target="_blank" rel="noopener"> SpringBoot整合Netty</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Netty是一个基于基于Java NIO的网络应用框架和client-server框架，提供了对TCP、UDP和文件传输的支持。Netty不
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://9191rs.me/categories/SpringBoot/"/>
    
    
      <category term="Netty" scheme="https://9191rs.me/tags/Netty/"/>
    
      <category term="FastDFS" scheme="https://9191rs.me/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第10题 Regular Expression Matching</title>
    <link href="https://9191rs.me/posts/36828/"/>
    <id>https://9191rs.me/posts/36828/</id>
    <published>2018-09-20T11:17:04.000Z</published>
    <updated>2018-09-20T12:44:26.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p><img src="/posts/36828/1.jpg" alt=""></p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>回溯法是一种暴力解法，把“*”的所有可能性都测试一遍看是否有满足的。<br>从后往前匹配,用两个指针 si, pi来表明当前s和p的字符。 </p><ul><li>如果pi对应的字符是”*”，根据s[i] 和 p[j-1]是否相同，分两种情况：<ul><li>如果相同，则先尝试匹配掉s的这个字符，继续尝试匹配</li><li>不管相同不相同，不匹配s的这个字符，继续尝试匹配</li></ul></li><li><p>如果pi对应的字符不是是”*”，直接看s[i]和p[j]是否相等</p></li><li><p>边界条件</p><ul><li>如果si和pi都小于0，说明匹配。</li><li>如果pi小于0，si大于零，说明不能匹配</li></ul></li></ul><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || p == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isMatch(s.toCharArray(),s.length() - <span class="number">1</span>,p.toCharArray(),p.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span>[] s,<span class="keyword">int</span> si,<span class="keyword">char</span>[] p,<span class="keyword">int</span> pi)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(si &lt; <span class="number">0</span> &amp;&amp; pi &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(pi &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p[pi] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(si &gt;= <span class="number">0</span> &amp;&amp;( p[pi - <span class="number">1</span>] == s[si] || p[pi - <span class="number">1</span>] == <span class="string">'.'</span> ) </span><br><span class="line">           &amp;&amp; isMatch(s,si<span class="number">-1</span>,p,pi))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">isMatch</span><span class="params">(s,si,p,pi<span class="number">-2</span>)</span></span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(si &gt;= <span class="number">0</span> &amp;&amp; (p[pi] == s[si] || p[pi] == <span class="string">'.'</span> ))</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">isMatch</span><span class="params">(s,si<span class="number">-1</span>,p,pi<span class="number">-1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>dp[i][j]的含义是s[0-i] 与 s[0-j]是否匹配</p><ul><li>若s[i] == p[j] 或者p[j] == ‘ . ‘,则dp[i][j]  =  dp[i-1][j-1]</li><li>若p[j] == ‘ * ‘,则需要分情况讨论<ul><li>s[i]  !=  p[j-1]， 则 dp[i][j] = dp[i][j-2]   –&gt;忽略掉 p[j-1] 和*</li><li>s[i]  ==  p[j-1] 或者p[j] == ‘ . ‘<ul><li>dp[i][j] = dp[i-1][j]    –&gt;  p[j-1] 和* 匹配多次</li><li>dp[i][j] = dp[i][j-1]    –&gt;  p[j-1] 和*匹配一次</li><li>dp[i][j] = dp[i][j-2]    –&gt;  忽略掉 p[j-1] 和*</li></ul></li></ul></li></ul><h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(<span class="symbol">String</span> st, <span class="symbol">String</span> pt) &#123;</span><br><span class="line">    if(st==null || pt == null) </span><br><span class="line">        return false;</span><br><span class="line">    int m = st.length();</span><br><span class="line">    int n = pt.length();</span><br><span class="line">    char[] s = st.toCharArray();</span><br><span class="line">    char[] p = pt.toCharArray();</span><br><span class="line">    </span><br><span class="line">    boolean[][] dp = new boolean[m+<span class="number">1</span>][n+<span class="number">1</span>]; //dp[i][j]的含义是s[<span class="number">0</span>-i] 与 s[<span class="number">0</span>-j]是否匹配</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = true; ////初始化第<span class="number">0</span>行,除了[<span class="number">0</span>][<span class="number">0</span>]全为false</span><br><span class="line">    </span><br><span class="line">    //初始化第<span class="number">0</span>列，只有<span class="symbol">X</span>*能匹配空串，如果有*，它的真值一定和p[<span class="number">0</span>][j<span class="number">-2</span>]的相同（略过它之前的符号）</span><br><span class="line">    for (int j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j &gt; <span class="number">1</span> &amp;&amp; <span class="string">'*'</span> == p[j - <span class="number">1</span>] &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    for(int i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        for(int j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            if(p[j<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">2</span>] || (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>) </span><br><span class="line">                                &amp;&amp; dp[i - <span class="number">1</span>][j];</span><br><span class="line">            else</span><br><span class="line">                dp[i][j] = (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><ul><li><a href="https://blog.csdn.net/hk2291976/article/details/51165010" target="_blank" rel="noopener">《LeetBook》leetcode题解(10): Regular Expression Matching——DP解决正则匹配</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/posts/36828/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;回溯法&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第5题 Longest Palindromic Substring</title>
    <link href="https://9191rs.me/posts/39014/"/>
    <id>https://9191rs.me/posts/39014/</id>
    <published>2018-09-20T02:07:16.000Z</published>
    <updated>2018-09-20T02:03:13.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定一个字符串，求它的一个最长回文子串。</p><p><img src="/posts/39014/1.jpg" alt=""></p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。</li><li>暴力解法的时间复杂度是O(n^3)。</li><li>可以从最长的字串开始枚举，如果回文，就停止</li></ul><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String <span class="keyword">s</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">s</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=s.length()-i;j++)&#123;</span><br><span class="line">                String st = s.substring(j,i+j);</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(st))</span><br><span class="line">                    <span class="keyword">return</span> st;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean isPalindrome(String <span class="function"><span class="keyword">sub</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="function"><span class="keyword">sub</span>.<span class="title">length</span>() / 2</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="function"><span class="keyword">sub</span>.<span class="title">charAt</span>(<span class="title">k</span>) != <span class="title">sub</span>.<span class="title">charAt</span>(<span class="title">sub</span>.<span class="title">length</span>() - <span class="title">k</span> - 1))</span></span><br><span class="line"><span class="function">                <span class="title">return</span> <span class="title">false</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>遍历字符串中的每一个字符，以它为中心开始向左右两边拓展，直到左右两边的字符不同，或者达到边界。</li><li>此算法的时间复杂度是O(n^2)</li></ul><h4 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> st = <span class="number">0</span>,maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> longestPalindrome(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = s.length();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>&lt;=<span class="number">1</span>) return s;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">len</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(i+<span class="number">1</span>))</span><br><span class="line">                palindromeAux(s,i,i+<span class="number">1</span>);</span><br><span class="line">             </span><br><span class="line">            palindromeAux(s,i,i);                </span><br><span class="line">        &#125; </span><br><span class="line">        return s.substring(st,st+maxLen);    </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> void palindromeAux(<span class="built_in">String</span> s,<span class="built_in">int</span> l,<span class="built_in">int</span> r) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;r&lt;<span class="built_in">len</span>&amp;&amp;s.charAt(l)==s.charAt(r))&#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;     </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxLen &lt; r - l- <span class="number">1</span>) &#123;</span><br><span class="line">    st = l + <span class="number">1</span>;</span><br><span class="line">    maxLen = r - l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h3><p>具体介绍见这篇<a href="https://segmentfault.com/a/1190000003914228#articleHeader8" target="_blank" rel="noopener">文章</a></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">String</span> longestPalindrome(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//字符串预处理</span></span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="string">'#'</span>);</span><br><span class="line">    list.<span class="built_in">add</span>(s.charAt(i));</span><br><span class="line">    &#125;    </span><br><span class="line">    list.<span class="built_in">add</span>(<span class="string">'#'</span>);</span><br><span class="line">        <span class="built_in">int</span> MaxRight = <span class="number">0</span>;<span class="comment">//现在访问到的最右边的字符</span></span><br><span class="line">    <span class="built_in">int</span> pos = <span class="number">0</span>; <span class="comment">//maxRight位置对应的轴位置</span></span><br><span class="line">    <span class="built_in">int</span> MaxLen = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> n = list.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">int</span>[] RL = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;MaxRight)</span><br><span class="line">    RL[i] = Math.<span class="built_in">min</span>(RL[<span class="number">2</span>*pos-i], MaxRight-i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    RL[i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//尝试扩展，注意处理边界</span></span><br><span class="line">            <span class="keyword">while</span> (i-RL[i]&gt;=<span class="number">0</span> &amp;&amp;i+RL[i]&lt;n &amp;&amp; </span><br><span class="line">            list.<span class="built_in">get</span>(i-RL[i]) == list.<span class="built_in">get</span>(i+RL[i]))</span><br><span class="line">                RL[i] +=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新MaxRight,pos</span></span><br><span class="line">            <span class="keyword">if</span> (RL[i]+i<span class="number">-1</span>&gt;MaxRight)&#123;</span><br><span class="line">                MaxRight = RL[i]+i<span class="number">-1</span>;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新最长回文串的长度</span></span><br><span class="line">            MaxLen=Math.<span class="built_in">max</span>(MaxLen, RL[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(RL[i] != MaxLen) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    pos = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">String</span> res = <span class="string">""</span>;</span><br><span class="line">     <span class="keyword">if</span>(list.<span class="built_in">get</span>(pos)!=<span class="string">'#'</span>)</span><br><span class="line">     res +=  list.<span class="built_in">get</span>(pos);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">for</span>(<span class="built_in">int</span> i=pos+<span class="number">1</span>;i&lt;pos + MaxLen ;i++)&#123;</span><br><span class="line"> <span class="built_in">char</span> ch = list.<span class="built_in">get</span>(i);</span><br><span class="line"> <span class="keyword">if</span>(ch==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"> res = ch + res + ch;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>pal[i,j]（表示以i开始以j结束的子串）是否为回文字符串。</li><li>算法复杂度是O(N^2)</li><li>状态方程和转移方程：<pre><code>pal[i, j] = pal[i+1, j-1]， if ( s[i]==s[j] )pal[i, j] = false，if ( s[i] != s[j] )</code></pre></li></ul><h4 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="function">String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] pal = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="comment">//pal[i][j] 表示s[i...j]是否为回文串</span></span><br><span class="line">        pal[i][j] = <span class="keyword">false</span> 表示不是回文串</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j)&amp;&amp;(i-j&lt;<span class="number">2</span>||pal[j+<span class="number">1</span>][i<span class="number">-1</span>]))&#123;</span><br><span class="line">                    pal[j][i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (maxLen &lt; i-j+<span class="number">1</span>)&#123;</span><br><span class="line">                        maxLen = i-j+<span class="number">1</span>;</span><br><span class="line">                        r = i;</span><br><span class="line">                        l = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">return</span> s.<span class="title">substring</span><span class="params">(l,r+<span class="number">1</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><ul><li><a href="https://segmentfault.com/a/1190000003914228#articleHeader8" target="_blank" rel="noopener">最长回文子串——Manacher 算法</a></li><li><a href="https://blog.csdn.net/wangbaochu/article/details/53861833" target="_blank" rel="noopener">动态规划：最长回文字符串</a></li><li><a href="https://blog.csdn.net/qq_32354501/article/details/80084325" target="_blank" rel="noopener">最长回文子串（Longest Palindromic Substring）——三种时间复杂度的解法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;p&gt;给定一个字符串，求它的一个最长回文子串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/39014/1.jpg&quot; alt=
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第3题 Longest Substring Without Repeating Characters </title>
    <link href="https://9191rs.me/posts/53116/"/>
    <id>https://9191rs.me/posts/53116/</id>
    <published>2018-09-19T03:00:09.000Z</published>
    <updated>2018-09-19T06:05:13.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>求一个字符串中有不重复字母的字符串个数。<br><img src="/posts/53116/1.jpg" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>采用双指针的思想，并且用一个HashMap保存每一个字符出现的位置。移动右指针扫描字符串并且更新映射关系。如果在HashMap中已经存在这个字符，就将左字符移动到最后找到的同一字符的右边。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> lengthOfLongestSubstring(<span class="keyword">String</span> s) &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">int</span> l =<span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">HashMap</span>&lt;Character,Integer&gt; hm = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(r&lt;s.length())&#123;</span><br><span class="line">       <span class="built_in">char</span> ch = s.charAt(r);</span><br><span class="line">       <span class="keyword">if</span>(hm.containsKey(ch))</span><br><span class="line">           l =  Math.<span class="built_in">max</span>(l,hm.<span class="built_in">get</span>(ch) + <span class="number">1</span>);</span><br><span class="line">       hm.put(ch,r);</span><br><span class="line">       </span><br><span class="line">       res = Math.<span class="built_in">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">       r++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;p&gt;求一个字符串中有不重复字母的字符串个数。&lt;br&gt;&lt;img src=&quot;/posts/53116/1.jpg&quot; alt=&quot;&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>不用四则运算符号做加减乘除</title>
    <link href="https://9191rs.me/posts/30160/"/>
    <id>https://9191rs.me/posts/30160/</id>
    <published>2018-09-07T03:53:36.000Z</published>
    <updated>2018-09-07T06:14:11.623Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>加减乘除是在写程序过程中，经常会遇到的。如果不能使用四则运算符号（+ - / * ）做运算，那么我们只能考虑用位运算。且由于减法和乘法一般可用加法推出，所以现在只介绍用位运算实现加法和除法。</p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先看十进制是如何做的： 5+7=12，三步走<br>第一步：相加各位的值，不算进位，得到2。<br>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p><p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p><p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p><p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。<br>     继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Add(<span class="built_in">int</span> num1,<span class="built_in">int</span> num2) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span>,carry;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">sum</span> = num1 ^ num2;</span><br><span class="line">        carry = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        num1 = <span class="built_in">sum</span>;</span><br><span class="line">        num2 = carry;</span><br><span class="line">    &#125;<span class="keyword">while</span>(num2<span class="comment">!=0);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>用将15除以3举例，先将3向左移动1位（相当于乘以2），得到新除数6。15大于6，再次使得除数左移一位变为12。15大于12，再次使得除数左移一位变为24。15小于24，则用（15-12）重新开始这一个过程。在求解过程中用一个数记录循环的次数就可以得到解。</p><h4 id="Java代码实现-1"><a href="#Java代码实现-1" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int <span class="keyword">divide(int </span><span class="keyword">dividend, </span>int <span class="keyword">divisor) </span>&#123;</span><br><span class="line">     </span><br><span class="line">     if(<span class="keyword">divisor==0 </span><span class="title">||</span> (<span class="keyword">dividend </span>== Integer.MIN_VALUE&amp;&amp; <span class="keyword">divisor==-1))</span></span><br><span class="line"><span class="keyword"> </span>        return Integer.MAX_VALUE<span class="comment">;</span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     int sign = (<span class="keyword">dividend </span>&lt; <span class="number">0</span>) ^ (<span class="keyword">divisor </span>&lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">     long dvd = Math.abs((long) <span class="keyword">dividend);</span></span><br><span class="line"><span class="keyword"> </span>    long dvs = Math.abs((long) <span class="keyword">divisor);</span></span><br><span class="line"><span class="keyword"> </span>    int res = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">     </span><br><span class="line">     while(dvd &gt;= dvs)&#123;</span><br><span class="line">         long temp = dvs, <span class="keyword">mul </span>= <span class="number">1</span><span class="comment">;</span></span><br><span class="line">         while(dvd &gt;= (temp&lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">             temp &lt;&lt;= <span class="number">1</span><span class="comment">;</span></span><br><span class="line">             <span class="keyword">mul </span>&lt;&lt;= <span class="number">1</span><span class="comment">;  //翻倍</span></span><br><span class="line">         &#125;</span><br><span class="line">         dvd -= temp<span class="comment">;</span></span><br><span class="line">         res += <span class="keyword">mul;</span></span><br><span class="line"><span class="keyword"> </span>    &#125;</span><br><span class="line">     </span><br><span class="line">     return sign == <span class="number">1</span> ? res : -res<span class="comment">;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Multiply-Strings"><a href="#Multiply-Strings" class="headerlink" title="Multiply Strings"></a>Multiply Strings</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>先按照元素规则计算出每一位的和，最后在考虑进位问题。</p><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span>(<span class="params">String num1, String num2</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num1==<span class="literal">null</span>||num2==<span class="literal">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(num1.<span class="keyword">equals</span>(<span class="string">""</span>)||num2.<span class="keyword">equals</span>(<span class="string">""</span>)) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(num1.<span class="keyword">equals</span>(<span class="string">"0"</span>)||num2.<span class="keyword">equals</span>(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len1 = num1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = num2.length();</span><br><span class="line">    <span class="keyword">if</span>(len1==<span class="number">0</span>||len2==<span class="number">0</span>)  <span class="keyword">return</span>  <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">if</span>(len1&gt;len2)  <span class="comment">//确num1是较短那个短</span></span><br><span class="line">        <span class="keyword">return</span> multiply(num2,num1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + len2 - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            res[i+j] = res[i+j] + t1 * t2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> du = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=res.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        res[i] = res[i] + du;</span><br><span class="line">        </span><br><span class="line">        du = res[i] / <span class="number">10</span>;</span><br><span class="line">        res[i] = res[i] % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(du!=<span class="number">0</span>) sb.append(du);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)</span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><ul><li><a href="https://leetcode.com/problems/divide-two-integers/description/" target="_blank" rel="noopener"> leetcode – Divide Two Integers</a></li><li><a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&amp;tqId=11201&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网 – 不用加减乘除做加法</a></li><li><a href="https://leetcode.com/problems/multiply-strings/description/" target="_blank" rel="noopener">leetcode – Multiply Strings</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;加减乘除是在写程序过程中，经常会遇到的。如果不能使用四则运算符号（+ - / * ）做运算，那么我们只能考虑用位运算。且由于减法和乘法一般可
      
    
    </summary>
    
      <category term="算法" scheme="https://9191rs.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
      <category term="剑指offer" scheme="https://9191rs.me/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第60题 Permutation Sequence</title>
    <link href="https://9191rs.me/posts/56083/"/>
    <id>https://9191rs.me/posts/56083/</id>
    <published>2018-09-04T07:43:56.000Z</published>
    <updated>2018-09-04T08:36:52.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>将1-n按照从小到大的顺序进行全排列，求解第k个排列结果。<br>如n=3,它的全排列顺序如下：</p><p><img src="/posts/56083/1.jpg" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先想到的肯定是求出整个全排列，然后返回第K个即可，这种做法当然可行，但是对于本题来书并不是最优解。leetcode上有一种十分<a href="https://leetcode.com/problems/permutation-sequence/discuss/22507/%22Explain-like-I&#39;m-five%22-Java-Solution-in-O(n" target="_blank" rel="noopener">巧妙的解法</a>)，它的思路如下(以n=4,k=16举例)：</p><p>当n = 4时，全排列序列可以看作以下几种情况的组合：<br>&#8195;&#8195; 1 + (permutations of 2, 3, 4)<br>&#8195;&#8195;2 + (permutations of 1, 3, 4)<br>&#8195;&#8195;3 + (permutations of 1, 2, 4)<br>&#8195;&#8195;4 + (permutations of 1, 2, 3)</p><p>对于每一个子排列来说，有6种可能。也就是说，在这个特殊的情况下总共会有24个排列。因此，当k＝14时，所要求的排列将在 3 + (permutations of 1, 2, 4) 这个子排列中。这里求第几个会有一个公式：</p><blockquote><p>index = k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2</p></blockquote><p>然后相当于实在求 permutations of {1, 2, 4} 中的一个子序列,新的k可以通过下述公式计算：</p><blockquote><p> k = k - (index from previous) <em> (n-1)! = k - 2</em>(n-1)! = 13 - 2*(3)! = 1</p></blockquote><p>第二步中的全排列序列：<br>&#8195;&#8195;1 + (permutations of 2, 4)<br>&#8195;&#8195;2 + (permutations of 1, 4)<br>&#8195;&#8195;4 + (permutations of 1, 2)<br>根据公式求出新的index = k / (n - 2)! = 1 / (4-2)! = 1 / 2! = 0，</p><p>这样的话下一步应该在1 + (permutations of 2, 4)中，<br>&#8195;&#8195;2 + (permutations of  4)<br>&#8195;&#8195;4 + (permutations of 2)<br> 再次根据公式计算k的值为1，index的值为1。</p><p>最后一步的子序列为(permutations of 2)，也可以计算的k的值为0，index的值为0(走个流程，最后结果都是这个)。</p><p>综上: index的自每一步中取值分别为：2 0 1 0，结合每一次的去安排列序列，可以得出最终的结果为： 3142 ！！ </p><h3 id="Java参考代码"><a href="#Java参考代码" class="headerlink" title="Java参考代码"></a>Java参考代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> getPermutation(<span class="built_in">int</span> n, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="built_in">int</span>[] fn = <span class="keyword">new</span> <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            nums.<span class="built_in">add</span>(i);</span><br><span class="line">        </span><br><span class="line">        fn[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum *= i;</span><br><span class="line">            fn[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        k--;  <span class="comment">//减去1，因为总是计数是从0开始</span></span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> idx = k/fn[n-i];</span><br><span class="line">            sb.<span class="built_in">append</span>(<span class="keyword">String</span>.valueOf(nums.<span class="built_in">get</span>(idx)));</span><br><span class="line">            nums.remove(idx);</span><br><span class="line">            k = k - idx*fn[n-i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;p&gt;将1-n按照从小到大的顺序进行全排列，求解第k个排列结果。&lt;br&gt;如n=3,它的全排列顺序如下：&lt;/p&gt;
&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="https://9191rs.me/posts/41468/"/>
    <id>https://9191rs.me/posts/41468/</id>
    <published>2018-08-14T12:06:43.000Z</published>
    <updated>2018-08-31T12:23:30.451Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h3><p>事务的概念来自于两个独立的需求：并发数据库访问，系统错误恢复。一个事务是可以被看作一个单元的一系列SQL语句的集合。事务通常指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p><img src="/posts/41468/1.jpg" alt=""> </p><h3 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h3><ul><li><strong>原子性（Atomicity）</strong>：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li><li><strong>一致性（Consistency）</strong>：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li><li><strong>隔离性（Isolation）</strong>：一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</li></ul><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><p><img src="/posts/41468/2.jpg" alt=""> </p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>如果不对数据库进行并发控制，可能会产生异常情况：</p><ol><li><p><strong>脏读(Dirty Read)：</strong><br>当一个事务读取另一个事务尚未提交的修改时，产生脏读。同一事务内不是脏读。<br>一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。如T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><p><img src="/posts/41468/3.jpg" alt=""> </p></li><li><p><strong>不可重复读(Nonrepeatable Read)</strong> ：一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。如T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><img src="/posts/41468/4.jpg" alt=""> </p></li><li><p><strong>幻读(Phantom Reads)</strong> ：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。如T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同</p><p><img src="/posts/41468/5.jpg" alt=""> </p></li><li><p><strong>丢失修改(Lost Update)：</strong><br>第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。<br>第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。如T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><p><img src="/posts/41468/6.jpg" alt=""> </p></li></ol><p>为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）。</p><ol><li><p><strong>未提交读(Read Uncommitted)</strong><br>直译就是”读未提交”，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。<br>Read Uncommitted允许脏读。</p></li><li><p><strong>已提交读(Read Committed)</strong><br>直译就是”读提交”，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。<br>Read Commited 不允许脏读，但会出现非重复读。</p></li><li><p><strong>可重复读(Repeatable Read)：</strong><br>直译就是”可以重复读”，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。<br>Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。</p></li><li><p><strong>串行读(Serializable)</strong><br>直译就是”序列化”，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。<br>Serializable 不允许不一致现象的出现。</p></li></ol><h3 id="事务隔离的实现——锁"><a href="#事务隔离的实现——锁" class="headerlink" title="事务隔离的实现——锁"></a>事务隔离的实现——锁</h3><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li><p><strong>排它锁（Exclusive）</strong>: 简写为 X 锁，又称写锁。一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。</p></li><li><p><strong>共享锁（Shared）</strong>: 简写为 S 锁，又称读锁。用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。</p></li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，</li></ul><p><strong>Read Uncommited</strong> : 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。</p><p><strong>Read Committed</strong> : 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。</p><p><strong>Repeatable Read:</strong> 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。</p><p><strong>Serializable</strong>: 读加共享锁，写加排他锁，读写互斥。</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。<br>在MySQL存储引擎InnoDB中，意向锁是表级锁。</p><ul><li><strong>意向共享锁（IS）：</strong>在对一个数据行<strong>加共享锁前</strong>必须取得该表的IS锁。</li><li><strong>意向排他锁（IX）：</strong>在对一个数据行<strong>加排他锁前</strong>必须取得该表的IX锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><h3 id="MySQL-的-InnoDB-存储引擎提供的锁"><a href="#MySQL-的-InnoDB-存储引擎提供的锁" class="headerlink" title="MySQL 的 InnoDB 存储引擎提供的锁"></a>MySQL 的 InnoDB 存储引擎提供的锁</h3><h4 id="单行记录锁（Record-Locks）"><a href="#单行记录锁（Record-Locks）" class="headerlink" title="单行记录锁（Record Locks）"></a>单行记录锁（Record Locks）</h4><p>锁定一个记录上的<strong>索引</strong>，而不是记录本身。<br>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。</p><h4 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h4><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><blockquote><p>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</p></blockquote><h4 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h4><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定范围内的索引.</p><h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>范式理论是为了解决数据库操作中的异常：</p><ul><li>冗余数据：例如一行数据出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。</li><li>插入异常</li></ul><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。<br> <img src="/posts/41468/7.jpg" alt=""> </p><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。<br>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。<strong>简而言之，第一范式就是无重复的列。</strong></p><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。<br>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。<strong>简而言之，第二范式就是非主属性非部分依赖于主关键字。</strong></p><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。<strong>简而言之，第三范式就是属性不依赖于其它非主属性。</strong></p><hr><p>参考链接</p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/数据库系统原理.md" target="_blank" rel="noopener">CyC2018/Interview-Notebook</a></li><li><a href="https://hit-alibaba.github.io/interview/basic/db/Transaction.html" target="_blank" rel="noopener">事务的概念</a></li><li><a href="https://blog.csdn.net/huangshulang1234/article/details/79523354" target="_blank" rel="noopener">java面试之数据库面试知识点</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务概述&quot;&gt;&lt;a href=&quot;#事务概述&quot; class=&quot;headerlink&quot; title=&quot;事务概述&quot;&gt;&lt;/a&gt;事务概述&lt;/h3&gt;&lt;p&gt;事务的概念来自于两个独立的需求：并发数据库访问，系统错误恢复。一个事务是可以被看作一个单元的一系列SQL语句的集合。事务通常
      
    
    </summary>
    
      <category term="数据库" scheme="https://9191rs.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://9191rs.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>http与https</title>
    <link href="https://9191rs.me/posts/51855/"/>
    <id>https://9191rs.me/posts/51855/</id>
    <published>2018-08-13T11:28:53.000Z</published>
    <updated>2018-08-13T12:59:57.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。</p><ul><li>URI（Uniform Resource Identifier，统一资源标识符）</li><li>URL（Uniform Resource Locator，统一资源定位符）</li><li>URN（Uniform Resource Name，统一资源名称）</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP(Hyper Text Transfer Protocol,超文本传输协议)是基于TCP/IP进行数据传输数据的，默认端口号是80。HTTP的特点：无连接、无状态、媒体独立。</p><ul><li><strong>无连接</strong>：指的是每次链接只处理一个请求。如果说服务端处理完客户端的一次请求后页收到了来自客户端的应答了，就会断开请求。</li><li><strong>无状态</strong>：对于后续需要前面的相关信息就会需要重新传送。</li><li><strong>媒体独立</strong>：只要服务端和客户端知道处理数据的方式，那么任何类型的数据都会通过HTTP发送。</li></ul><p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><ol><li>首先客户机与服务器需要建立连接。如单击某个链接，HTTP的工作开始。</li><li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li><li>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</li></ol><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>HTTP 请求分为三个部分：请求行（包括请求方法、URI、HTTP版本信息）、请求头、消息主体。类似于下面这样：</p><p><img src="http与https/1.jpg" alt=""> </p><p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。</p><p><strong>常用的HTTP方法：</strong></p><ul><li><strong>GET</strong>： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。</li><li><strong>POST：</strong>用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li><li><strong>PUT：</strong> 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li><li><strong>DELETE</strong>：删除文件，与PUT方法相反，删除对应URI位置的文件。</li><li><strong>HEAD：</strong> 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li><li><strong>OPTIONS：</strong>查询相应URI支持的HTTP方法。</li></ul><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>HTTP 响应分为三个部分：状态行（包括HTTP版本、状态码、状态码的原因短语）、响应头、消息主体。类似于下面这样：</p><p><img src="http与https/2.jpg" alt=""> </p><p><strong>HTTP 状态码</strong></p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">类别</th><th style="text-align:center">原因短语</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">Informational（信息性状态码）</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">Success（成功状态码）</td><td style="text-align:center">请求正常处理完毕</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">Redirection（重定向状态码）</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">Client Error（客户端错误状态码）</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">Server Error（服务器错误状态码）</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><p><strong>常见的HTTP相应状态码</strong></p><ul><li>100 Continue 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li><li>200 OK 客户端请求成功</li><li>301 Moved Permanently 请求永久重定向</li><li>302 Moved Temporarily 请求临时重定向</li><li>304 Not Modified 文件未修改，可以直接使用缓存的文件。</li><li>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</li><li>401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li><li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li><li>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</li><li>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><h4 id="Secure-和-HttpOnly"><a href="#Secure-和-HttpOnly" class="headerlink" title="Secure 和 HttpOnly"></a>Secure 和 HttpOnly</h4><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 Document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码；</li><li>如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><img src="http与https/3.jpg" alt=""></p><h4 id="短连接与长连接"><a href="#短连接与长连接" class="headerlink" title="短连接与长连接"></a>短连接与长连接</h4><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。<h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</li></ul><p>流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。</p><h3 id="HTTP-1-0-与-HTTP-1-1-的区别"><a href="#HTTP-1-0-与-HTTP-1-1-的区别" class="headerlink" title="HTTP/1.0 与 HTTP/1.1 的区别"></a>HTTP/1.0 与 HTTP/1.1 的区别</h3><ul><li>HTTP/1.1 默认是长连接</li><li>HTTP/1.1 支持管线化处理</li><li>HTTP/1.1 支持同时打开多个 TCP 连接</li><li>HTTP/1.1 支持虚拟主机</li><li>HTTP/1.1 新增状态码 100</li><li>HTTP/1.1 支持分块传输编码</li><li>HTTP/1.1 新增缓存处理指令 max-age</li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><h4 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h4><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的.在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应消息对应的完整的一系列帧。</li><li>帧（Fram）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h4><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。<br>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩.</p><h3 id="GET-和-POST-比较"><a href="#GET-和-POST-比较" class="headerlink" title="GET 和 POST 比较"></a>GET 和 POST 比较</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中<strong>。但是不能因为 POST</strong> 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参考支持标准字符集。</p><p>Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据），而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>注意：</p><ul><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li></ul><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。<br>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><p>GET请求可以被浏览器缓存，POST不能</p><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p><strong>HTTPS</strong>：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="HTTPS的工作过程"><a href="#HTTPS的工作过程" class="headerlink" title="HTTPS的工作过程"></a>HTTPS的工作过程</h3><p><img src="http与https/4.jpg" alt=""> </p><ol><li><strong>客户端发起HTTPS请求</strong><br>这个没什么好说的，就是用户在浏览器里输入一个HTTPS网址，然后连接到服务端的443端口。</li><li><strong>服务端的配置</strong><br>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li><li><strong>传送证书</strong><br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li><li><strong>客户端解析证书</strong><br>这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个<strong><em>随机值</em></strong>。然后用证书（也就是公钥）对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li><li><strong>传送加密信息</strong><br>这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li><li><strong>服务端解密信息</strong><br>服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li><li><strong>传输加密后的信息</strong><br>这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。</li><li><strong>客户端解密信息</strong><br>客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</li></ol><p><strong>HTTPs 采用的加密方式</strong></p><p>HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。</p><h3 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h3><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><hr><p>参考链接：</p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/HTTP.md" target="_blank" rel="noopener">CyC2018/Interview-Notebook</a></li><li><a href="https://juejin.im/entry/58d7635e5c497d0057fae036" target="_blank" rel="noopener">详细解析 HTTP 与 HTTPS 的区别</a></li><li><a href="https://juejin.im/post/5a4f4884518825732b19a3ce" target="_blank" rel="noopener">HTTPS加密过程和TLS证书验证</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UR
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://9191rs.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://9191rs.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="http" scheme="https://9191rs.me/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://9191rs.me/posts/28758/"/>
    <id>https://9191rs.me/posts/28758/</id>
    <published>2018-08-13T07:25:35.000Z</published>
    <updated>2019-01-16T06:15:30.143Z</updated>
    
    <content type="html"><![CDATA[<p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="/posts/28758/1.jpg" alt=""> </p><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><ul><li><strong>应用层 ：</strong>为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li><strong>运输层 ：</strong>提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层 ：</strong>为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层 ：</strong>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层 ：</strong>考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层 ：</strong>数据压缩、加密以及数据描述，这使得应用程序不必担心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层 ：</strong>建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><img src="/posts/28758/2.jpg" alt=""> </p><h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。<br>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。 </p><p><img src="/posts/28758/3.jpg" alt=""> </p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li><strong>封装成帧：</strong>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</li><li><strong>透明传输：</strong>透明表示一个实际存在的事物看起来好像不存在一样。<br>&#8195;&#8195;帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</li><li><strong>差错检测：</strong>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。<br>网络层使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。<br><img src="/posts/28758/4.jpg" alt=""> </p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h3 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h3><ol><li>分类<br>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。<strong>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}。</strong></li></ol><p><img src="/posts/28758/5.jpg" alt=""> </p><ol start="2"><li>子网划分<br>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。<strong>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}。</strong>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。<strong>注意，外部网络看不到子网的存在。</strong></li><li>无分类<br>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。<strong>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</strong>。CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。</li></ol><h3 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h3><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。ARP 实现由 IP 地址得到 MAC 地址。<strong>每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</strong></p><ol><li><p>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。</p></li><li><p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p></li><li><p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p></li></ol><p><img src="/posts/28758/6.jpg" alt=""> </p><h3 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h3><p>ICMP是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由器是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP报文有两种：差错报告报文和询问报文</p><p>ICMP的应用</p><ul><li><strong>Ping：</strong>测试两台主机之间的连通性。</li><li><strong>Traceroute：</strong>跟踪一个分组从源点到终点的路径。</li></ul><h3 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h3><p>NAT（Network Address Translation，网络地址转换）是一种网络地址翻译技术，将内部私有IP地址改变成可以在公网上使用的 IP。</p><p>NAT三种实现方式</p><ul><li><strong>静态地址转换</strong>：一个公网IP对应一个内部IP,一对一转换</li><li><strong>动态地址转换：</strong>N个公网IP对应M个内部Ip,不固定的一对一IP转换关系．同一时间，有M-N个主机无法联网．</li><li><strong>端口多路复用</strong>：对外只有一个公网IP,通过端口来区别不同内部IP主机的数据．转换 NAPT。</li></ul><p><strong>DHCP协议</strong>：动态主机设置协议（Dynamic Host ConfigurationProtocol, DHCP）<br>是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道。</p><h3 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h3><ul><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。<strong>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</strong></li></ul><h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p><img src="/posts/28758/7.jpg" alt=""> </p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，<strong>连接建立</strong>。</li></ul><p><strong>三次握手的原因</strong><br>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h3 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h3><p><img src="/posts/28758/8.jpg" alt=""> </p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><p>TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。<h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4></li></ul><p>发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。<br><img src="/posts/28758/9.jpg" alt=""> </p><h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><p><img src="/posts/28758/10.jpg" alt=""> </p><h2 id="常见的几道面试题"><a href="#常见的几道面试题" class="headerlink" title="常见的几道面试题"></a>常见的几道面试题</h2><h3 id="TCP对应的协议和UDP对应的协议"><a href="#TCP对应的协议和UDP对应的协议" class="headerlink" title="TCP对应的协议和UDP对应的协议"></a>TCP对应的协议和UDP对应的协议</h3><h4 id="TCP对应的协议："><a href="#TCP对应的协议：" class="headerlink" title="TCP对应的协议："></a>TCP对应的协议：</h4><p>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</p><h4 id="UDP对应的协议："><a href="#UDP对应的协议：" class="headerlink" title="UDP对应的协议："></a>UDP对应的协议：</h4><p>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p><h3 id="DNS域名系统，简单描述其工作原理。"><a href="#DNS域名系统，简单描述其工作原理。" class="headerlink" title="DNS域名系统，简单描述其工作原理。"></a>DNS域名系统，简单描述其工作原理。</h3><p>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。</p><h3 id="了解交换机、路由器、网关的概念，并知道各自的用途"><a href="#了解交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="了解交换机、路由器、网关的概念，并知道各自的用途"></a>了解交换机、路由器、网关的概念，并知道各自的用途</h3><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。只有当目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。</p><h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。</p><p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p><p>在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。</p><p>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。</p><p>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p><h4 id="交换机与路由器有什么区别？"><a href="#交换机与路由器有什么区别？" class="headerlink" title="交换机与路由器有什么区别？"></a>交换机与路由器有什么区别？</h4><ul><li>工作所处的OSI层次不一样，交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层。</li><li>寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址。</li><li>转发速不同：交换机的转发速度快，路由器转发速度相对较慢。</li></ul><h3 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h3><p>　　TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。</p><p>　　<strong>对于可靠性，TCP通过以下方式进行保证：</strong></p><ul><li><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据。</li><li><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层。</li><li><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据。</li><li><strong>应答机制：</strong>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</li><li><strong>超时重发：</strong>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><h3 id="IP地址与物理地址"><a href="#IP地址与物理地址" class="headerlink" title="IP地址与物理地址"></a>IP地址与物理地址</h3><p>　　物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。</p><hr><p>参考链接：</p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/HTTP.md" target="_blank" rel="noopener">CyC2018/Interview-Notebook</a></li><li><a href="https://zhuanlan.zhihu.com/p/24001696" target="_blank" rel="noopener">常见面试题整理–计算机网络篇</a></li><li><a href="https://blog.csdn.net/u013408431/article/details/62442670" target="_blank" rel="noopener">面试中常见的计算机网络的问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。&lt;/p&gt;
&lt;h2 id=&quot;计算机网络体系结构&quot;&gt;&lt;a href=&quot;#计算机网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;计算机网络体系结构&quot;&gt;&lt;/a&gt;计算机网络体系结构&lt;/
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://9191rs.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://9191rs.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySql中的索引</title>
    <link href="https://9191rs.me/posts/64683/"/>
    <id>https://9191rs.me/posts/64683/</id>
    <published>2018-08-08T11:43:37.000Z</published>
    <updated>2018-08-31T12:39:54.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引是一种数据结构，一个索引是存储的表中一个特定列或者某几个特定列的值数据结构，索引是在列上创建的。</p><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h3 id="MySql的存储引擎"><a href="#MySql的存储引擎" class="headerlink" title="MySql的存储引擎"></a>MySql的存储引擎</h3><p>MySql的存储引擎主要有两种：MyISAM和InnoDB。</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>MySql5.5之前的默认引擎，特点如下：</p><ul><li>不支持行锁，读取是需要对读到的所有表加锁，写入时则对表加排他锁。</li><li>不支持事务和外键。</li><li>不支持崩溃后的安全恢复。</li><li>在表有读取查询的同时，支持往表中插入新纪录。</li><li>支持BLOB和TEXT的前600个字符索引，支持全文索引。</li><li>支持延迟更新索引，极大的提升了写入性能。</li><li>对于不会进行修改的表，支持压缩表，减少了磁盘空间占用。</li></ul><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>MySql5.5之后的默认引擎，特点如下：</p><ul><li>支持行锁，采用MVCC来支持高并发，可能死锁。</li><li>支持事务和外键。</li><li>支持崩溃后的安全恢复。</li><li>不支持全文索引。</li></ul><p>总而言之，MyISAM适合读密集的表，而InnoDB适合写密集的表。</p><p>MyISAM和InnoDB都可以采用B+ Tree作为索引，但是其实现方式是不同的。</p><p><strong>MylSAM：</strong> B+Tree叶节点的data域存放的是数据记录的地址。检索时，首先 ，按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称非聚簇索引。</p><p><strong>InnoDB:</strong>其数据文件本身就是就是索引文件，树的叶子节点的data域保存了完整的数据记录。如果这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为聚簇索引。而其余的索引都被称为辅助索引，辅助索引的data域记录相应的主键的值。根据主索引搜索时，直接到key所在的节点索引，即可取出数据。再根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</p><h2 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h2><p>B+ Tree 是Btree(Balance Tree)的变体，也是一种多路平衡的搜索树。B+树所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。</p><p><img src="/posts/64683/1.png" alt=""> </p><h3 id="B-Tree的查找和删除"><a href="#B-Tree的查找和删除" class="headerlink" title="B+ Tree的查找和删除"></a>B+ Tree的查找和删除</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p><p>插入删除操作记录会破坏平衡树的平衡性，因此在插入删除时，需要对树进行一个分裂、合并、旋转等操作。</p><h3 id="为什么是B-Tree"><a href="#为什么是B-Tree" class="headerlink" title="为什么是B+ Tree"></a>为什么是B+ Tree</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><ol><li>B+的磁盘读写代价更低</li></ol><p>&#8195;&#8195;B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><ol start="2"><li>B+-tree的查询效率更加稳定</li></ol><p>&#8195;&#8195;由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h3><p>B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。B+Tree 索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><ul><li>普通索引：最基本的索引类型，而且它没有唯一性之类的限制。</li><li>UNIQUE索引：表示唯一的，不允许重复的索引，可以为NULL值，一个表可以有多个唯一索引。</li><li>主键索引：主键是一种唯一性索引，不能为NULL值，只能有一个。</li></ul><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找；<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li></ul><h3 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h3><p>MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ol><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和创建临时表（B+Tree 索引是有序的，可以用来做 ORDER BY 和 GROUP BY 操作）；</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，也就将相邻的数据都存储在一起）。</li></ol><p>索引能够极大地提高数据检索效率，也能够改善排序分组操作的性能，但有不能忽略的一个问题就是索引是完全独立于基础数据之外的一部分数据。假设在Table ta 中的Column ca 创建了索引 idx_ta_ca，那么任何更新 Column ca 的操作，MySQL在更新表中 Column ca的同时，都须要更新Column ca 的索引数据，调整因为更新带来键值变化的索引信息。而如果没有对 Column ca 进行索引，MySQL要做的仅仅是更新表中 Column ca 的信息。这样，最明显的资源消耗就是增加了更新所带来的 IO 量和调整索引所致的计算量。此外，Column ca 的索引idx_ta_ca须要占用存储空间，而且随着 Table ta 数据量的增加，idx_ta_ca 所占用的空间也会不断增加，所以索引还会带来存储空间资源消耗的增加。</p><h3 id="索引选择原则"><a href="#索引选择原则" class="headerlink" title="索引选择原则"></a>索引选择原则</h3><ol><li>较频繁的作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li><li>更新非常频繁的字段不适合创建索引</li><li>不会出现在 WHERE 子句中的字段不该创建索引</li></ol><blockquote><ul><li>选择在哪个列上创建索引是最非常重要的。可以考虑使用索引的主要有 两种类型的列：在where子句中出现的列，在join子句中出现的列，而不是在SELECT关键字后选择列表的列。</li><li>索引列的基数越大(不重复的索引值)，索引的效果越好。</li><li>使用短索引(前缀索引)，如果对字符串列进行索引，应该指定一个前缀长度，可节省大量索引空间，提升查询速度。</li><li>多列索引。在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。</li></ul></blockquote><h3 id="索引选择注意事项"><a href="#索引选择注意事项" class="headerlink" title="索引选择注意事项"></a>索引选择注意事项</h3><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。</p><ol><li>表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。</li><li>索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：Index Selectivity = Cardinality / #T。显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，对于选择性太小的列没必要创建索引。</li><li>MySQL只对一下操作符才使用索引：&lt;,&lt;=,=,&gt;,&gt;=,between,in, 以及某些时候的like(不以通配符%或_开头的情形)。</li><li>不要过度索引，只保持所需的索引。每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。 在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。</li><li>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</li></ol><hr><p>参考链接： </p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook" target="_blank" rel="noopener">CyC2018/Interview-Notebook</a></li><li><a href="https://segmentfault.com/a/1190000003072424" target="_blank" rel="noopener">MYSQL-索引</a></li><li><a href="https://segmentfault.com/a/1190000004690721" target="_blank" rel="noopener">由 B-/B+树看 MySQL索引结构</a></li><li><a href="https://blog.csdn.net/hxpjava1/article/details/55803923" target="_blank" rel="noopener">请说出数据库索引实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引是一种数据结构，一个索引是存储的表中一个特定列或者
      
    
    </summary>
    
      <category term="MySql" scheme="https://9191rs.me/categories/MySql/"/>
    
    
      <category term="索引" scheme="https://9191rs.me/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="https://9191rs.me/posts/40484/"/>
    <id>https://9191rs.me/posts/40484/</id>
    <published>2018-08-07T09:28:24.000Z</published>
    <updated>2018-08-13T12:55:41.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#8195;&#8195;虚拟机的类加载机制就是虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。在Java语言里面，类型的加载、连 接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些 性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言 特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>&#8195;&#8195;类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加 载（Loading)、验证（Verification)、准备（Preparation)、解析（Resolution)、初始化 (Initialization)、使用（Using)和卸载（Unloading) 7个阶段。其中验证、准备、解析3个部分统称为连接（Linking),这7个阶段的发生顺序如下图所示。<br><img src="/posts/40484/1.jpg" alt=""></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化 阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。但是这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、 激活另外一个阶段。</p><p>对于加载过程， Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化过程，有且只有5种情况必须立即对类进行“初始化”：</p><ul><li>使用new 关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果 放人常量池的静态宇段除外）的时候，以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化， 则需要先触发其初始化。</li><li>初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父 类的初始化。 </li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含mainO方法的那个类），虚 拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><p>以上5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式（被动引用）都不会触发初始化。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">       System.<span class="keyword">out</span>.println(<span class="string">"Father init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span>  <span class="title">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">       System.<span class="keyword">out</span>.println(<span class="string">"Son init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> final String HELLO = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       Son.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       Father[] nums = <span class="keyword">new</span> Father[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       System.<span class="keyword">out</span>.println(Son.HELLO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用test1()方法后，输出“Father init”，而不会输出“Son init”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静 态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p>当调用test2()方法后，没有输出 “Father init”，这说明没有触发Father类的初始化。这是因为数组类本身不通过类加载器创建，它是由Java虚拟 机直接创建的，创建数组的动作是由字节码指令newairay触发。</p><p>当调用test3()方法后，没有输出 “Son init”，这说明没有触发Father类的初始化。这是因为在编译阶段通过常量传播优化，已经将此常量的值“hello”存储到了 Test类的•常量池中，以后Test类对常量 Son.HELLO的引拥实际都被转化为Test类对自身常量池的引用。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加栽阶段，虚拟机需要完成以下3件亊情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问人口。</li></ul><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中， 对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面）， 这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p><p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加栽阶段尚未完成，连接阶段可能已经开始，但这拽夹在加栽阶段之中进行的动作，仍然属 予连接阶段的内容，这两个阶段的开始时间仍然保持着同定的先后顺序。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含时信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成4个阶段的检验动作:文件格式验证、元数据验证、字节码验证和符号引用验证。</p><p>文件格式验证阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处 理。元数据验证阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规 范的元数据信息。字节码验证阶段的主要目的是通过数据流和控制流分析， 确定程序语义是合法的、符合逻辑的。符号引用验证阶段可以可以看做是对类自身以外（常量池中 的各种符号引用）的信息进行匹配性校验。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值.假设一个类变量的定义为：<br>public static int value = 3；<br>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器&amp;ltclinit&amp;gt（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</li></ol><p>下图列出了Java中所有基本数据类型以及reference类型的默认零值：</p><p>   <img src="/posts/40484/2.jpg" alt=""></p><p>  这里还需要注意如下几点：</p><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><p>假设当前代码所处的类为D,如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：</p><ol><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加栽 器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他 相关类的加载动作，例如加载这个类的父类或实现的接口 •一旦这个加载过程出现了任何异 常，解析过程就宣告失败。<br>2.如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似 “[Ljava/lang/hiteger”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述 符如前面所假设的形式，需要加载的元素类型就是“Java.lang.Integer”，接着由虚拟机生成一 个代表此数组维度和元素的数组对象。<br>3.如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的 类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。 如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li></ol><h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。<br>从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">public static int m = <span class="number">11</span>;</span><br><span class="line">static&#123;</span><br><span class="line"><span class="type">System</span>.out.println(<span class="string">"执行了super类静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">public static int m = <span class="number">33</span>;</span><br><span class="line">static&#123;</span><br><span class="line"><span class="type">System</span>.out.println(<span class="string">"执行了父类静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">static&#123;</span><br><span class="line"><span class="type">System</span>.out.println(<span class="string">"执行了子类静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</span><br><span class="line">public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line"><span class="type">System</span>.out.println(<span class="type">Child</span>.m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 执行结果如下：</p><blockquote><p>  执行了super类静态语句块<br>    执行了父类静态语句块<br>    33</p></blockquote><p>如果注释掉Father类中对m定义的那一行，则输出结果如下：</p><blockquote><p>执行了super类静态语句块<br>    11</p></blockquote><p>分析如下：static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。</p><h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p><h4 id="接口方法解"><a href="#接口方法解" class="headerlink" title="接口方法解"></a>接口方法解</h4><p>与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p> 初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器&amp;ltclinit&amp;gt()方法的过程。</p><ul><li>&amp;ltclinit&amp;gt()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。</li><li>&amp;ltclinit&amp;gt()方法与实例构造器&amp;ltinit&amp;g()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&amp;ltclinit&amp;gt()方法执行之前，父类的&amp;ltclinit&amp;g()方法已经执行完毕。因此，在虚拟机中第一个被执行的&amp;ltclinit&amp;gt()方法的类肯定是java.lang.Object。</li><li>&amp;ltclinit&amp;gt()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&amp;ltclinit&amp;gt()方法。</li><li>接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成&amp;ltclinit&amp;gt()方法。但是接口鱼类不同的是：执行接口的&amp;ltclinit&amp;gt()方法不需要先执行父接口的&amp;ltclinit&amp;gt()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&amp;ltclinit&amp;gt()方法。 </li><li>虚拟机会保证一个类的&amp;ltclinit&amp;gt()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&amp;ltclinit&amp;gt()方法，其他线程都需要阻塞等待，直到活动线程执行&amp;ltclinit&amp;gt()方法完毕。如果在一个类的&amp;ltclinit&amp;gt()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(Child.b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 执行上面的代码，会打印出2，也就是说b的值被赋为了2。</p></blockquote><p>首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用&amp;ltclinit&amp;gt()方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的&amp;ltclinit&amp;gt()方法，根据规则2，在此之前，要先执行完其父类Father的&amp;ltclinit&amp;gt()方法，又根据规则1，在执行&amp;ltclinit&amp;gt()方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的&amp;ltclinit&amp;gt()方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的&amp;ltclinit&amp;gt()方法，这样便会将b的赋值为2。</p><blockquote><p>   如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。原因同上。 另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。</p></blockquote><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类 加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚 拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通 俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有 意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们 的类加载器不同，那这两个类就必定不相等。这里所指的“相等’ 包括代表类的Class对象的equals()方法、isAssignableFrom()方法、 islnstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p><p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</p><ul><li>启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。</li><li>所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li></ul><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><ul><li>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li><li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li><li>自定义的类加载器。</li></ul><p>这几种类加载器的层次关系如下图所示：<br>   <img src="/posts/40484/3.jpg" alt=""></p><p> 这种层次关系称为类加载器的双亲委派模型。把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。</p><p> 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>  使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。</p><p>此外，类加载器全盘负责机制：当一个类加载器加载一个Class的时候，这个Class所依赖的和引用的所有Class也由这个类加载器负责载入，除非是显式的使用另外一个类加载器载入。</p><hr><p>详情请参见</p><ul><li>深入理解Java虚拟机第二版</li><li><a href="https://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">【深入Java虚拟机】之四：类加载机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&amp;#8195;&amp;#8195;虚拟机的类加载机制就是虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形
      
    
    </summary>
    
      <category term="JVM" scheme="https://9191rs.me/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <link href="https://9191rs.me/posts/15805/"/>
    <id>https://9191rs.me/posts/15805/</id>
    <published>2018-08-05T07:56:06.000Z</published>
    <updated>2018-08-05T13:59:34.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> &#8195;&#8195; Java 内存运行时区域的可分为程序计数器、虚拟机栈、本地方法栈、Java堆和方法区等5个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而 生，随线程而灭；栈中的栈帧随着方法的进人和退出而有条不紊地执行着出栈和入栈操作。 每一个找帧中分配多少内存基本上是在类结构确定下来时就已知的， 因此这几个区域的内存分配和回收都具备确定性，在方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一 样，一个接口中的多个实现类需要的内存可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，而垃圾收集器所关注的正是这部分内存。</p><h2 id="哪些对象需要回收"><a href="#哪些对象需要回收" class="headerlink" title="哪些对象需要回收"></a>哪些对象需要回收</h2><p> &#8195;&#8195;在堆里面存放着Java程序中几乎所有的对象，垃圾收集器在对堆进行回收前，第一 件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”。常见的方法有两个：引用计数算法和可达性分析算法。</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p> &#8195;&#8195;引用计数算法（Reference Counting）的判定方式很简单：给对象中增加一个引用计数器，每当有 一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器允 0的对象就是不可能再被使用的。一般地说，引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是至少主流的 Java虚拟机里面没有选则引用计数算法来管理内存，其中最主要的原因是它很难解决对象之 间相互循环引用的问题。</p><pre><code> public class ReferenceCountingGC{        public Object instance = null;        private static final int _1MB = 1024 * 1024;        public static void testGC() {            ReferenceCountingGC objA = new ReferenceCountingGCO ;             ReferenceCountingGC objB = new ReferenceCountingGCO;             objA.instance = objB;             objB.instance = objA;            objA = null;             objB = null;            //假设在这行发生GC, objA和ObjB是否能被回收？            System.gc();        }        }</code></pre><p>  &#8195;&#8195; 如以上代码所示testGC()方法, 对象objA和objB都有宇段instance, 赋值令objA.instance = objB=及 objB.instance  = objA。除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着方，导致它们引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>&#8195;&#8195; 可达性分析（ReacffabilityAnaljLsisy）算法的基本思 路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所通过的路径称为引用链(Reference Chain),等一个对象到GC Roots没有任何引用链相连时，则明此对象是不可用的。如 下图所示，对象object5、object6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是对回收的对象。<br><br><img src="/posts/15805/1.jpg" alt=""><br><br><br>&#8195;&#8195; 在可达性分析箅法中不可达的对象，也并非是一定要被回收的。要真正回收一个对象，至少要经历两次标记过程。如果对象在进行可 达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做 F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它,这<strong>里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束</strong>。</p><p>稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中重新与引用链上 的任何一个对象建立关联，譬如把自己（this关键字）陚值给某个类变量或者对象的成 员变量，那在第二次标记时它将被移除出“即将回收”的集合。如果对象这时候仍然被标记， 那基本上它就真的被回收了。<br><strong>务必注意，finalize()方法都最多只会被系统自动调用一次。</strong></p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>&#8195;&#8195;方法区（或者HotSpot虚拟机中的永久代）主要回收两部分内容：废弃常量和无用的类。</p><p>回收废弃常量与回收 Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进 人了常量池中，但是当前系统没有任何一个String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这 时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><p>类需要同时满足下面3个条件才能算是“无用的类”：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访 问该类的方法。</li></ul><p><strong>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是 和对象一样，不使用了就必然会回收。</strong></p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>&#8195;&#8195;最基础的收集算法是“标记-清除”（Marie-Sweep)算法，如同它的名字一样，算法分 为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一 个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后 在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次 垃圾收集动作。标记—清除算法的执行过程如下图所示。<br><img src="/posts/15805/2.jpg" alt=""></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>&#8195;&#8195;为了解决效率问题，一种称为“复制”（Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都 是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶 指针，按顺序分配内存即可，实现简单，运行髙效。只是这种算法的代价是将内存缩小为了 原来的一半，未免太高了一点。复制算法的执行过程如下图所示。<br><img src="/posts/15805/3.jpg" alt=""></p><p>这种收集算法主要被用来回收新生代，新 生代中的对象98%是“朝生夕死”的，所以并不需要按照1 ：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一 块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块 Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden 和Survivor的大小比例是8 : 1,也就是每次新生代中可用内存空间为整个新生代容量的90%,只有10%的内存会被“浪费”。如果另外一块Survivor空间没有足够空间在放上一次新生代收集下来的存活对象 时，这些对象将直接通过分配担保机制进人老年代。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>&#8195;&#8195;根据老年代的特点，提出7另外一种“标记_-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的 示意图如下所示。<br><img src="/posts/15805/4.jpg" alt=""></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>&#8195;&#8195;“分代收集”（Generational Collection)算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代 中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付 出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间 对它进行分配担保，就必须使用“标记一清理”或者“标记一整理”算法来进行回收。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>&#8195;&#8195;垃圾收集器就是内存回收的具体实现。Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚 拟机所提供的垃圾收集器都可能会有很大差别，这里讨论的收集器基于JDK 1.7 Update 14之 后的HotSpot虚拟机，这个虚拟机包含的所有收集器下如图所示（如果两个收集器之间存在连线，就说明它 们可以搭配使用。）。<br><img src="/posts/15805/5.jpg" alt=""></p><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>&#8195;&#8195;Serial收集器是一个单线程的收集器，它的 “单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作， 更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。下面是 Serial / Serial Old收集器运行示意图。<br><img src="/posts/15805/6.jpg" alt=""></p><p>Serial收集器的优点是简单而高效（与其他收集器的单线程比），对于限定 单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集可以 获得最高的单线程收集效率。缺点则是因内存回收而导致GC停顿。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>&#8195;&#8195;ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集 之外.其余行为包括Serial收集器可用的所有控制参数、收集算法、StopTheWorld、 对象分配规则、回收策略等都与Serial收集器完全一样。ParNew / Serial Old收集器运行示意图如下。<br><img src="/posts/15805/7.jpg" alt=""></p><p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于 存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分 之百地保证可以超越Serial收集器.但是，随着可以使用的CPU的数量的增加，它对于 GC时系统资源的有效利用还是很有好处的。</p><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>&#8195;&#8195;Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标則是达到一个可控制的吞叶量（Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间）。停顿时间越短就越适合需耍与用户交互的程序，良好的响应速度能提升用户体验，而 吞吐量则可以髙效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记一整理”算法。这个收集器是在JDK 1.6中才开始提供的，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。<br><img src="/posts/15805/9.jpg" alt=""></p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>&#8195;&#8195;CMS(Concurrent Mark Sweep)收集器是一秤以获取最短回收停顿时间为目标的收集器。，CMS收集器是基于”标记—清除”算法实现的，它的运作过程相分为四个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发消除</li></ul><p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快,：并.发;向己阶段就是进行GC Roots  Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产牛变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一 些，但远比并发标记的时间短。</p><p><img src="/posts/15805/10.jpg" alt=""></p><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起 工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>CMS主要优点在于：并发收集和低停顿。但是CMS以下3个明显的缺点：</p><ul><li>对CPU资源非常敏感</li><li>无法处理浮动垃圾（Floating Garbage)，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生</li><li>收集结束 时，可能会有大量空间碎片产生</li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>&#8195;&#8195;G1 (Garbage-First)收集器是当今收集器技术发展的最前沿成果之一，是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如 下特点。</p><ul><li><p><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU (CPU 或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿 Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p></li><li><p><strong>分代收集：</strong>与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需 要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建 的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p></li><li><strong>空间整合:</strong> 与CMS的“标记一清理”算法不同，G1从整体来看是基于“标记一整理” 算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的， 但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提 供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找 到连续内存空间而提前触发下一次GC。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共 同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N毫秒。</li></ul><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这 样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region),虽然还保留有新生代和老年代的概念，但新生代和 老年代不再是物理隔离的了，它们都是一部分Region (不需要连续）的集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进#全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价値大小（回收.所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许 的收集时间，优先回收价值最大的Region。</p><p>G1收集器的运作大致可划分为以下几个步骤： </p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS (Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</p><p>并发标记阶段是从GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发 执行。</p><p>而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面， 最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停 顿线程，但是可并行执行。</p><p>最后在筛选回收阶段首先对各个Region的回收价值和成本进行排 序，根据用户所期望的GC停顿时间来制定回收计划，</p><p><img src="/posts/15805/11.jpg" alt=""></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>&#8195;&#8195;对象的内存分配，往大方向讲，就是在堆上分配：对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。下面是几条最普遍的内存分配规则。</p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>&#8195;&#8195;大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><p>Minor GC和FullGC的区别：</p><ul><li>新生代GC(Minor GC): 指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝 生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC (Major GC/FullGC〉：指发生在老年代的GC, 出现了 Major GC,经常会伴 随至少一次的MinorGC (但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接 进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>&#8195;&#8195;所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长 的字符串以及数组，经常出现大对象容易 导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>&#8195;&#8195;既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义 了一个对象年龄（Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对 象在Survivor区中每“熬过”一次MinorGC,年龄就增加1岁，当它的年龄增加到一定程 度（默认为15岁），就将会被晋升到老年代中。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>&#8195;&#8195;为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进人老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>&#8195;&#8195;在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生 代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成 立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么 会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果 大于，将尝试着进行一次Minor GC,尽管这次Minor GC是有风险的：如果小于或者 HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p><p>下面解释一下“冒险”是冒了什么风险，前面提到过，新生代使用复制收集算法，但 为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在 Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就 需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</p><p>老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容童的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是 否进Full GC来让老年代腾出更多空间。</p><p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存 活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure)。 如果出现了 HandlePromotionFailure失败，那就只好在失败后重新发起一次FullGC。虽然 担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotkmFailure开关打 开，避免Full GC过于频繁。</p><p><strong>关于JVM参数设置与分析详见<a href="https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="noopener">这篇文章</a>。</strong></p><hr><p>详情请参见深入理解Java虚拟机第二版 &#8195;&#8195;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt; &amp;#8195;&amp;#8195; Java 内存运行时区域的可分为程序计数器、虚拟机栈、本地方法栈、Java堆和方法区等5个部分，其中程序计数
      
    
    </summary>
    
      <category term="JVM" scheme="https://9191rs.me/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="https://9191rs.me/posts/35314/"/>
    <id>https://9191rs.me/posts/35314/</id>
    <published>2018-08-05T05:51:30.000Z</published>
    <updated>2018-08-05T07:44:52.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间：有的区域随着虚拟机进程的启动而 存在.有些区域则依赖用户线程的启动和结朿而建立和销毁。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示。</p><p><img src="/posts/35314/1.jpg" alt=""></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p> &#8195;&#8195;程序计数器（Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>&#8195;&#8195;程序计数器属于“线程私有”的内存。这是因为Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的， 在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线 程中的指令。因此，为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立 的程序计数器，各条线程之间的计数器互不影响，独立存储。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>&#8195;&#8195;Java虚拟机栈（Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frames，方法运行时的基础数据结构) 用于存储局部变量表、操作数栈、动态链接、方法出 口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中人桟到 出栈的过程。</p><p>&#8195;&#8195;局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、 float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对 象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 retumAddress类型（指向了一条字节码指令的地址)。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot),其余的数 据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进人一个方法时， 这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部 变童表的大小。</p><p>&#8195;&#8195;在Java虚拟机规范中，对这个区域规定了<strong>两种异常</strong>状况：</p><ul><li>StackOverflowError异常 : 线程请求的栈深度大于虚 拟机所允许的深度。</li><li>OutOfMemoryError异常 : 虚拟机栈可以动态扩展且在扩展时无法申请到足够的内存。</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>&#8195;&#8195;本地方法栈（Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为 虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法找中方法使用的语言、使用方 式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（例如HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法 栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>&#8195;&#8195;Java堆(Java Heap)是Java虚拟机所管理的内存中最犬块,且 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就 是存放实例，几乎所有的对象实例都在这里分配。这里<strong>要注意</strong>不过堆中的数据无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例。</p><p>&#8195;&#8195;Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>&#8195;&#8195;方法区（Methof Area)也是各个线程共享的内存区域，它甩管存储已被虚拟机加载的类信息、常量、静态变量即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出 OutOfMemory Error 异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>&#8195;&#8195;运行时常量池（Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table)，用于 存放编译期生成的各种字面量和符号引用，这部分内容将在<strong>类加载后</strong>进人方法区的运行时常量池中存放。运行时常量池具备动态性，Java语言并 不要求常量一定只有编译期才能产生，也就是并非预置人Class文件中常量池的内容才能进 人方法区运行时常量池，运行期间也可能将新的常量放人池中。</p><p>&#8195;&#8195;当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>&#8195;&#8195;直接内存（DirectMemoiy)并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。早在JDK 1.4中新加人了 NIO (New Input/Output)类，引人了一种基于通道（Channel) 与缓冲区（Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一 个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场 景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>&#8195;&#8195;本直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是 会受到本机总内存大小以及处理器寻址空间的限 制。因此在动态扩展时也会出现OutOfMemoryError异常。</p><h2 id="HotSpot虚拟机在Java堆中堆对象的操作"><a href="#HotSpot虚拟机在Java堆中堆对象的操作" class="headerlink" title="HotSpot虚拟机在Java堆中堆对象的操作"></a>HotSpot虚拟机在Java堆中堆对象的操作</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>&#8195;&#8195;在Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建过程却没有那么容易。</p><ol><li>虚拟机遇到一条new指令时，首先将去检査这个指令的参数是否能在常量池中定位到一 个类的符号引用，并且检査这个符号引用代表的类是否已被加载、解析和初始化过。如果没 有，那必须先执行相应的类加载过程。</li><li>在类加栽检査通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在 类加载完成后便可完全确定，为对象分配空间的任务等同于 把一块确定大小的内存从Java堆中划分出来。划分的方式又有两种：假设Java堆中内存是绝对规整的，所有用过 的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方 式称为“指针碰撞”（Bump the Pointer)。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，则虚拟机就必须维护一个列 表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象 实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List〉。与此同时，由于Java堆被所有线程共享，还应该考虑在并发情况下为对象分配内存的线程安全 性：一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存 分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配二小块内 存，称为本地线程分配缓冲。</li><li>内存分配完成后.虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</li><li>虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找 到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对 象头（Object Header）之中。</li><li>经过以上步骤，new操作就已经完成，但是只有对象进行了初始化，一个真正可用的对象才算完全产生出来。</li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>&#8195;&#8195;在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header)、 实例数据（Instance Data)和对齐填充（Padding)。</p><p>&#8195;&#8195;HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指 针来确定这个对象是哪个类的实例。</p><p>&#8195;&#8195;接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种 类型的字段内容。无论是从父类继承下来的，还是在于类中定义的，都需要记录起来。</p><p>&#8195;&#8195;第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用（HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍）。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>&#8195;&#8195;Java程序需要通过栈上的reference数据来操作堆上 的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式 也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p><ul><li>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。<br><img src="/posts/35314/2.jpg" alt=""></li><li>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如下图所示。<br><img src="/posts/35314/3.jpg" alt=""></li></ul><hr><p>详情请参见深入理解Java虚拟机第二版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间：有的区域
      
    
    </summary>
    
      <category term="JVM" scheme="https://9191rs.me/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下编译OpenJDK7</title>
    <link href="https://9191rs.me/posts/14724/"/>
    <id>https://9191rs.me/posts/14724/</id>
    <published>2018-08-03T08:21:04.000Z</published>
    <updated>2018-08-13T12:55:41.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备开发包"><a href="#准备开发包" class="headerlink" title="准备开发包"></a>准备开发包</h2><ul><li>OpenJDK7u75官方源码包，<a href="https://jdk7.java.net/source.html" target="_blank" rel="noopener">下载地址</a></li><li>Bootstrap JDK为Oraclejdk7u80， <a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html#jdk-7u80-oth-JPR" target="_blank" rel="noopener">下载地址</a></li><li>NetBeans7.0.1的C++版，<a href="https://netbeans.org/downloads/7.0.1/" target="_blank" rel="noopener">下载地址</a></li></ul><h2 id="编译OpenJDK7源码"><a href="#编译OpenJDK7源码" class="headerlink" title="编译OpenJDK7源码"></a>编译OpenJDK7源码</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><blockquote><p> sudo apt-get install build-essential gawk m4 libasound2-dev<br>libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev<br>binutils libmotif3 libmotif-dev ant</p></blockquote><h3 id="编写编译脚本"><a href="#编写编译脚本" class="headerlink" title="编写编译脚本"></a>编写编译脚本</h3><p>创建一个build.sh，并把下面的内容放进去，再把build.sh放到OpenJDK源码的目录下。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash   </span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">LANG</span>=C  </span><br><span class="line"><span class="comment"># Oracle JDK7的目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ALT_BOOTDIR</span>=/usr/lib/jvm/jdk1.7.0_80</span><br><span class="line">  </span><br><span class="line"><span class="comment">#允许自动下载依赖包  </span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ALLOW_DOWNLOADS</span>=<span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#使用预编译头文件，以提升便以速度 </span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">USE_PRECOMPILED_HEADER</span>=<span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#要编译的内容  </span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">BUILD_LANGTOOLS</span>=<span class="literal">true</span>  </span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">BUILD_JAXP</span>=<span class="literal">true</span>  </span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">BUILD_JAXWS</span>=<span class="literal">true</span>  </span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">BUILD_CORBA</span>=<span class="literal">true</span>  </span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">BUILD_HOSTPOT</span>=<span class="literal">true</span>  </span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">BUILD_JDK</span>=<span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#要编译的版本  </span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">SKIP_DEBUG_BUILD</span>=<span class="literal">false</span>  </span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">SKIP_FASTDEBUG_BUILD</span>=<span class="literal">true</span>  </span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DEBUG_NAME</span>=debug  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#避免javaws和浏览器Java插件等的build  </span></span><br><span class="line"><span class="attribute">BUILD_DEPLOY</span>=<span class="literal">false</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#不build安装包</span></span><br><span class="line"><span class="attribute">BUILD_INSTALL</span>=<span class="literal">false</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#设置存放编译结果的目录,一定要放在一个可以读写的路径 </span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ALT_OUTPUTDIR</span>=/home/re/openjdk7/build  </span><br><span class="line">  </span><br><span class="line">unset CLASSPATH  </span><br><span class="line">unset JAVA_HOME  </span><br><span class="line">make sanity   </span><br><span class="line">make 2&gt;&amp;1 | tee <span class="variable">$ALT_OUTPUTDIR</span>/build.log</span><br></pre></td></tr></table></figure></p><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>在命令行里切换到OpenJDK源码的目录下，运行脚本。</p><blockquote><p>sh build.sh</p></blockquote><p>经过一段时间的运行之后，出现下图时，就是编译完成了。<br><img src="/posts/14724/res.jpg" alt=""></p><h3 id="编译过程中遇到的问题"><a href="#编译过程中遇到的问题" class="headerlink" title="编译过程中遇到的问题"></a>编译过程中遇到的问题</h3><ul><li>内核版本不支持</li></ul><blockquote><p>echo “<strong><em> This OS is not supported:” <code>uname -a</code>; exit 1;</em></strong> This OS is not supported: Linux bcc66964b45e 4.9.27-moby </p></blockquote><p>解决办法：编辑 hotspot/make/linux/Makefile，在改SUPPORTED_OS_VERSION一行后面添加4%。</p><blockquote><p> SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7% 3% 4%</p></blockquote><ul><li>时间问题<blockquote><p>Error: time is more than 10 years from present: 1136059200000<br>java.lang.RuntimeException: time is more than 10 years from present: 1136059200000</p></blockquote></li></ul><p>解决办法：修改/jdk/src/share/classes/java/util/CurrencyData.properties中的几行参数，将其改为0年内的一个时间。</p><blockquote><p>AZ=AZM;2010-12-31-20-00-00;AZN </p></blockquote><p>MZ=MZM;2011-06-30-22-00-00;MZN</p><blockquote></blockquote><p>RO=ROL;2011-06-30-21-00-00;RON</p><blockquote><p>TR=TRL;2011-12-31-22-00-00;TRY</p></blockquote><p>VE=VEB;2012-01-01-04-00-00;VEF</p><h2 id="在NetBeans-IDE工具中进行HotSpot调试实例"><a href="#在NetBeans-IDE工具中进行HotSpot调试实例" class="headerlink" title="在NetBeans IDE工具中进行HotSpot调试实例"></a>在NetBeans IDE工具中进行HotSpot调试实例</h2><ol><li>在NetBeans中新建基于源码c/c++项目</li></ol><p><img src="/posts/14724/1.jpg" alt=""></p><ol start="2"><li>选择OpenJDK下关于hotspot的源码文件夹地址，以及选择定制</li></ol><p><img src="/posts/14724/2.jpg" alt=""></p><ol start="3"><li>选择hotspot的make目录下makefile的路径</li></ol><p><img src="/posts/14724/3.jpg" alt=""></p><ol start="4"><li>下一步要填写一些生成命令：</li></ol><p><img src="/posts/14724/4.jpg" alt=""></p><blockquote><p>${MAKE} -f Makefile clean jvmg ALT_BOOTDIR=/usr/lib/jvm/jdk1.7.0_80 ARCH_DATA_MODEL=64 LANG=C </p></blockquote><p>其中ALT_BOOTDIR就是编译脚本Oracle JDK7的目录的路径。</p><ol start="5"><li>一直点下一步，在ide中会出现hotspot项目,右键点击项目，选择属性，再点运行，又出来三个需要配置的地方。</li></ol><p><img src="/posts/14724/5.jpg" alt=""></p><p>设置运行命令为：</p><blockquote><p>/home/re/openjdk7/build/hotspot/outputdir/linux_amd64_compiler2/jvmg/gamma  Queens  -XX:+TraceBytecodes -XX:StopInterpreterAt=<n></n></p></blockquote><p>设置运行目录为：</p><blockquote><p>/home/re/openjdk7/build/hotspot/outputdir/linux_amd64_compiler2/jvmg/gamma</p></blockquote><p>设置环境变量为：</p><blockquote><p>  JAVA_HOME  ：/usr/lib/jvm/jdk1.7.0_80</p><p>CLASSPATH：.: \$ {JAVA_HOME}/lib/dt.jar:\${JAVA_HOME}/lib/tools.jar</p></blockquote><p>LD_LIBRARY_PATH： /home/re/openjdk7/build/hotspot/outputdir/linux_amd64_compiler2/jvmg</p><ol start="6"><li>完成以上配置之后，一个可修改、编译、调试的HotSpot 工程就完全建立起来了，启动器的执行入口是java.c的main()方法，读者可以设置断点单步跟踪，如下图所示。<br><img src="/posts/14724/6.jpg" alt=""></li></ol><hr><p>参考链接：</p><ul><li><a href="https://juejin.im/entry/582016462e958a0054f45660" target="_blank" rel="noopener">Ubuntu14.04 下编译 OpenJDK</a></li><li><a href="https://www.linuxidc.com/Linux/2017-12/149077.htm" target="_blank" rel="noopener">Java虚拟机HotSpot调试实例</a></li><li>深入理解Java虚拟机</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备开发包&quot;&gt;&lt;a href=&quot;#准备开发包&quot; class=&quot;headerlink&quot; title=&quot;准备开发包&quot;&gt;&lt;/a&gt;准备开发包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OpenJDK7u75官方源码包，&lt;a href=&quot;https://jdk7.java.net/sour
      
    
    </summary>
    
      <category term="JVM" scheme="https://9191rs.me/categories/JVM/"/>
    
    
      <category term="OpenJDK7" scheme="https://9191rs.me/tags/OpenJDK7/"/>
    
      <category term="java" scheme="https://9191rs.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口的最大值</title>
    <link href="https://9191rs.me/posts/8268/"/>
    <id>https://9191rs.me/posts/8268/</id>
    <published>2018-08-02T08:23:48.000Z</published>
    <updated>2018-08-03T10:03:16.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。均不匹配.</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>对于这个题目而言，暴力解法是比较遍历整个数组，求出每一个滑动窗口的最大值，但是这样做的话带来了大量的重复计算。<br>因此，如果考虑滑动窗口之间的相关性，可以用一个队列来模拟整个过程。</p><p>对新来的元素k，将其与队列中的元素相比较<br>1、前面比k小的，直接移出队列（因为不再可能成为后面滑动窗口的最大值了!）,<br>2、前面比k大的X，比较两者下标，判断X是否已不在窗口之内，不在了，直接移出队列<br>注意：队列中存放的是每个元素对应的索引</p><p>重复下来，队列的第一个元素是滑动窗口中的最大值</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;Integer&gt; maxInWindows(<span class="built_in">int</span> [] nums, <span class="built_in">int</span> <span class="built_in">size</span>)&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>||<span class="built_in">size</span>==<span class="number">0</span>||<span class="built_in">size</span>&gt;len) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()&amp;&amp;nums[i]&gt;nums[q.getLast()])</span><br><span class="line">            q.removeLast();</span><br><span class="line">        q.addLast(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="built_in">size</span><span class="number">-1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()&amp;&amp;nums[i]&gt;nums[q.getLast()])</span><br><span class="line">            q.removeLast();</span><br><span class="line">        q.addLast(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i-q.getFirst() + <span class="number">1</span>&gt;<span class="built_in">size</span>)</span><br><span class="line">            q.removeFirst();</span><br><span class="line">        </span><br><span class="line">        res.<span class="built_in">add</span>(nums[q.getFirst()]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://9191rs.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="剑指offer" scheme="https://9191rs.me/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式匹配</title>
    <link href="https://9191rs.me/posts/16074/"/>
    <id>https://9191rs.me/posts/16074/</id>
    <published>2018-08-02T02:51:07.000Z</published>
    <updated>2018-08-03T09:50:26.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括’.’和’ <em> ‘的正则表达式。模式中的字符’ . ‘表示任意一个字符，而’ </em> ‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>要判断是否匹配，首先对’ . ‘  和 ‘ * ‘的作用进行分析：</p><p>‘ . ‘比较简单，就是可以指代任意字符，切不可忽略。</p><p>‘ <em> ‘一般出现在一个字符的后面，表示它前面的字符可以出现0次或者多次。<br>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。<br>如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：<br>1、模式后移2字符，相当于x</em>被忽略<br>2、字符串后移1字符，模式后移2字符，即只匹配一次<br>3、字符串后移1字符，模式不变，即继续匹配字符下一位</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="built_in">match</span>(<span class="built_in">char</span>[] s, <span class="built_in">char</span>[] p)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s==null||p==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">match</span>(s,<span class="number">0</span>, p,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean <span class="built_in">match</span>(<span class="built_in">char</span>[] s,int si,<span class="built_in">char</span>[] p,int <span class="built_in">pi</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(si==s.length&amp;&amp;<span class="built_in">pi</span>==p.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(si!=s.length&amp;&amp;<span class="built_in">pi</span>==p.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pi</span>&lt;p.length<span class="number">-1</span>&amp;&amp;p[<span class="built_in">pi</span>+<span class="number">1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((si != s.length &amp;&amp; p[<span class="built_in">pi</span>] == s[si]) || (p[<span class="built_in">pi</span>] == <span class="string">'.'</span> &amp;&amp; si != s.length))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">match</span>(s,si+<span class="number">1</span>, p,<span class="built_in">pi</span>+<span class="number">2</span>)</span><br><span class="line">                || <span class="built_in">match</span>(s,si+<span class="number">1</span>, p,<span class="built_in">pi</span>)</span><br><span class="line">                || <span class="built_in">match</span>(s,si, p,<span class="built_in">pi</span>+<span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">match</span>(s,si, p,<span class="built_in">pi</span>+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((si != s.length &amp;&amp; p[<span class="built_in">pi</span>] == s[si]) || (p[<span class="built_in">pi</span>] == <span class="string">'.'</span> &amp;&amp; si != s.length))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">match</span>(s,si+<span class="number">1</span>, p,<span class="built_in">pi</span>+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;请实现一个函数用来匹配包括’.’和’ &lt;em&gt; ‘的正则表达式。模式中的字符’ . ‘表示任意一个字符，而’ &lt;/em&gt; ‘
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://9191rs.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="剑指offer" scheme="https://9191rs.me/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>数字在排序数组中出现的次数</title>
    <link href="https://9191rs.me/posts/32844/"/>
    <id>https://9191rs.me/posts/32844/</id>
    <published>2018-08-02T02:14:25.000Z</published>
    <updated>2018-08-03T09:51:15.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。<br><strong> 注意：输入的数组是有序的。 </strong></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>对于这个题目，最简单的思路就是顺序扫描整个数组，当找到这个数字时，让相应的计数变量自增。这样的话，算法的时间复杂度为O(n)。但是千万忘了该数组是有序的，因此可以考虑是否可以用上二分搜索。最简单的一种想法就是利用二分搜索找到它第一次出现的位置，再找到它最后一次出现的位置，两个相减既是该数字出现的次数。该算法时间复杂度为O(log n)。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> GetNumberOfK(<span class="built_in">int</span> [] nums , <span class="built_in">int</span> k) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">len</span> = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>==<span class="number">0</span>) return <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> start = getStartK(nums,k,<span class="number">0</span>,nums.length<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">end</span> = getEndK(nums,k,<span class="number">0</span>,nums.length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(start!=<span class="number">-1</span>&amp;&amp;<span class="keyword">end</span>!=<span class="number">-1</span>)</span><br><span class="line">        return <span class="keyword">end</span> - start + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> getStartK(<span class="built_in">int</span>[] nums,<span class="built_in">int</span> k,<span class="built_in">int</span> l,<span class="built_in">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) return <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="built_in">mid</span>]==k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mid</span>&gt;<span class="number">0</span>&amp;&amp;nums[<span class="built_in">mid</span><span class="number">-1</span>]!=k||<span class="built_in">mid</span>==<span class="number">0</span>)</span><br><span class="line">            return <span class="built_in">mid</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = <span class="built_in">mid</span><span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>]&gt;k)&#123;</span><br><span class="line">        r = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return getStartK(nums,k,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> getEndK(<span class="built_in">int</span>[] nums,<span class="built_in">int</span> k,<span class="built_in">int</span> l,<span class="built_in">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) return <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="built_in">mid</span>]==k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mid</span>&lt;nums.length<span class="number">-1</span>&amp;&amp;nums[<span class="built_in">mid</span>+<span class="number">1</span>]!=k||<span class="built_in">mid</span>==nums.length<span class="number">-1</span>)</span><br><span class="line">            return <span class="built_in">mid</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>]&gt;k)&#123;</span><br><span class="line">        r = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return getEndK(nums,k,l,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;统计一个数字在排序数组中出现的次数。&lt;br&gt;&lt;strong&gt; 注意：输入的数组是有序的。 &lt;/strong&gt;&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://9191rs.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="剑指offer" scheme="https://9191rs.me/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>数组中的逆序对</title>
    <link href="https://9191rs.me/posts/33062/"/>
    <id>https://9191rs.me/posts/33062/</id>
    <published>2018-08-02T01:40:51.000Z</published>
    <updated>2018-08-03T09:50:50.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>注意：输入的数组中没有的相同的数字</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>对于这个题目，最简单的思路就是顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小，如果后面的数字比它小，则这两个数字就组成了一个逆序对，对于一个长度为n的数组来说，这个算法的时间复杂度为O(n^2)。</p><p>在这里以数组{7,5,6,4}为例来分析统计逆序对的过程。<br><img src="/posts/33062/101.jpg" alt=""> </p><p>(a) 把长度为4的数组分解成两个长度为2的子数组；<br>(b) 把长度为2的数组分解成两个成都为1的子数组；<br>(c) 把长度为1的子数组 合并、排序并统计逆序对 ；<br>(d) 把长度为2的子数组合并、排序，并统计逆序对；</p><p>在上图（a）和（b）中，先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。其实可以看到，这种做法就是归并排序的一部分操作。</p><p>在每一次归并的时候，如果后半部分指数组针指向的数字比前半部分数组指针指向的数字大，则和归并排序一样，反之，前半部分指向的数字大，则进行统计，此时，前半部分剩下的所有数字都和后半部分当前的数字构成了一个逆序对。算法的时间复杂度是O(n*log n),空间复杂度是O(n)。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> long cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] aux;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> InversePairs(<span class="built_in">int</span> [] nums) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">len</span> = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>&lt;<span class="number">2</span>) return <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    aux = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">len</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">step</span> = <span class="number">1</span>;<span class="keyword">step</span>&lt;<span class="built_in">len</span>;<span class="keyword">step</span> += <span class="keyword">step</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=<span class="number">0</span>;k&lt;<span class="built_in">len</span>-<span class="keyword">step</span>;k += <span class="number">2</span>*<span class="keyword">step</span>)</span><br><span class="line">            merge(nums,k,k+<span class="keyword">step</span><span class="number">-1</span>,Math.min(<span class="built_in">len</span><span class="number">-1</span>,k+<span class="number">2</span>*<span class="keyword">step</span><span class="number">-1</span>));</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    return (<span class="built_in">int</span>)(cnt%<span class="number">1000000007</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void merge(<span class="built_in">int</span>[] nums,<span class="built_in">int</span> l,<span class="built_in">int</span> m,<span class="built_in">int</span> r)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=l;k&lt;=r;k++)</span><br><span class="line">        aux[k] = nums[k];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = l,j = m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=l;k&lt;=r;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;m) nums[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;r) nums[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(aux[j]&gt;aux[i]) nums[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nums[k] = aux[j++];</span><br><span class="line">            cnt += m-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://9191rs.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="剑指offer" scheme="https://9191rs.me/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树转换为双向链表</title>
    <link href="https://9191rs.me/posts/18325/"/>
    <id>https://9191rs.me/posts/18325/</id>
    <published>2018-08-01T12:58:55.000Z</published>
    <updated>2018-08-03T09:52:15.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>&#8195;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>&#8195;核心思想是利用树的中序遍历（递归版）<br>解题思路：<br>1.将左子树构造成双链表，并返回链表头节点。<br>2.定位至左子树双链表最后一个节点。<br>3.如果左子树链表不为空的话，将当前root追加到左子树链表。<br>4.将右子树构造成双链表，并返回链表头节点。<br>5.如果右子树链表不为空的话，将该链表追加到root节点之后。<br>6.根据左子树链表是否为空确定返回的节点。</p><h2 id="Java参考代码"><a href="#Java参考代码" class="headerlink" title="Java参考代码"></a>Java参考代码</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TreeNode &#123;</span><br><span class="line">    <span class="built_in">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode <span class="built_in">left</span> = <span class="literal">null</span>;</span><br><span class="line">    TreeNode <span class="built_in">right</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode(<span class="built_in">int</span> val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode Convert(TreeNode root) &#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">return <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(root.<span class="built_in">left</span>==<span class="literal">null</span>&amp;&amp;root.<span class="built_in">right</span>==<span class="literal">null</span>)</span><br><span class="line">return root;</span><br><span class="line"></span><br><span class="line">TreeNode <span class="built_in">left</span> = Convert(root.<span class="built_in">left</span>);</span><br><span class="line">TreeNode p = <span class="built_in">left</span>;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">null</span>&amp;&amp;p.<span class="built_in">right</span>!=<span class="literal">null</span>)</span><br><span class="line">p = p.<span class="built_in">right</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">left</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">p.<span class="built_in">right</span> = root;</span><br><span class="line">root.<span class="built_in">left</span> = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode <span class="built_in">right</span> = Convert(root.<span class="built_in">right</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">right</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="built_in">right</span>.<span class="built_in">left</span> = root;</span><br><span class="line">root.<span class="built_in">right</span> = <span class="built_in">right</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return <span class="built_in">left</span> == <span class="literal">null</span> ? root : <span class="built_in">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.nowcoder.com/questionTerminal/947f6eb80d944a84850b0538bf0ec3a5" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/947f6eb80d944a84850b0538bf0ec3a5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&amp;#8195;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://9191rs.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="剑指offer" scheme="https://9191rs.me/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://9191rs.me/posts/48940/"/>
    <id>https://9191rs.me/posts/48940/</id>
    <published>2018-08-01T06:29:09.000Z</published>
    <updated>2018-08-03T09:50:37.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，<br>输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>采用二分法解答这个问题，<br>mid = l + (r - l)/2<br>需要考虑三种情况：<br>(1)nums[mid] &gt; nums[r]:<br>&#8195;出现这种情况的nums类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。</p><p>(2)nums[mid] == nums[r]:<br>&#8195;出现这种情况的nums类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边<br>还是右边,这时只好一个一个试 。<br>(3)nums[mid] &lt; nums[r]:<br>&#8195;出现这种情况的nums类似[2,2,3,4,5,6,6],此时最小数字一定就是nums[mid]或者在mid的左边。<br>因为右边必然都是递增的。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> minNumberInRotatenums(<span class="built_in">int</span> [] nums) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">len</span> = nums.length;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>==<span class="number">0</span>) return <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> r = <span class="built_in">len</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">mid</span> = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[<span class="built_in">mid</span>]&gt;nums[r])</span><br><span class="line">l = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>]==nums[r])</span><br><span class="line">r--;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">r = <span class="built_in">mid</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，&lt;br&gt;输出旋转数组的
      
    
    </summary>
    
      <category term="算法" scheme="https://9191rs.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="剑指offer" scheme="https://9191rs.me/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序的三种实现</title>
    <link href="https://9191rs.me/posts/20940/"/>
    <id>https://9191rs.me/posts/20940/</id>
    <published>2018-07-29T01:52:07.000Z</published>
    <updated>2018-08-03T09:51:45.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序介绍"><a href="#冒泡排序介绍" class="headerlink" title="冒泡排序介绍"></a>冒泡排序介绍</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，<br>一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。</p><p>实现过程：<br><br>设数组的长度为N：<br>（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。<br>（2）这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。<br>（3）N=N-1，如果N不为0就重复前面二步，否则排序完成。</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>根据上述介绍，很快就能写出基本实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最基本的冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sort1</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n-i;j++)</span><br><span class="line"><span class="keyword">if</span>(nums[j<span class="number">-1</span>]&gt;nums[j])</span><br><span class="line">swap(nums,j<span class="number">-1</span>,j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进1"><a href="#改进1" class="headerlink" title="改进1"></a>改进1</h2><p>考虑整个排序过程可以发现，如果一趟数据交换过程中没有出现一次数据交换，则可以认为数组已经有序了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一点点改进 只要在一次冒泡中没有发生交换，则认为数组已经有序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">Sort2</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> k = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line"><span class="keyword">if</span>(nums[j<span class="number">-1</span>]&gt;nums[j])&#123;</span><br><span class="line">swap(nums,j<span class="number">-1</span>,j);</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进2"><a href="#改进2" class="headerlink" title="改进2"></a>改进2</h2><p>同样考虑，如果在交换过程中，前面的数据发生了交换，而后面一部分数据没有发生交换（已经有序），那么在下一趟交换过程中，只要对前面的数据进行交换即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接着改进  当后面的元素已经有序了，也不需要再次排序了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sort3</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> t = k;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;t;j++)</span><br><span class="line"><span class="keyword">if</span>(nums[j<span class="number">-1</span>]&gt;nums[j])&#123;</span><br><span class="line">swap(nums,j<span class="number">-1</span>,j);</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://blog.csdn.net/u010853261/article/details/54891710" target="_blank" rel="noopener">https://blog.csdn.net/u010853261/article/details/54891710</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冒泡排序介绍&quot;&gt;&lt;a href=&quot;#冒泡排序介绍&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序介绍&quot;&gt;&lt;/a&gt;冒泡排序介绍&lt;/h2&gt;&lt;p&gt;冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，&lt;br&gt;一次比较两个元素
      
    
    </summary>
    
      <category term="排序" scheme="https://9191rs.me/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="冒泡排序" scheme="https://9191rs.me/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串的排列</title>
    <link href="https://9191rs.me/posts/3080/"/>
    <id>https://9191rs.me/posts/3080/</id>
    <published>2018-07-20T13:17:49.000Z</published>
    <updated>2018-08-01T15:02:40.760Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串(字典序)abc,acb,bac,bca,cab和cba。输入一个字符串,长度不超9(可能有字符重复),字符只包括大小写字母。</p><h2 id="解决思路1-递归算法"><a href="#解决思路1-递归算法" class="headerlink" title="解决思路1-递归算法"></a>解决思路1-递归算法</h2><p>采用递归的方法，根据不同位置上字母的组合，先把结果保存在TreeSet中，这样既可以去掉重复的字符串，又可以保证字符串之间的字典顺序。</p><h2 id="java代码1"><a href="#java代码1" class="headerlink" title="java代码1"></a>java代码1</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;<span class="keyword">String</span>&gt; t = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="built_in">boolean</span>[]  used = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;<span class="keyword">String</span>&gt; Permutation(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">         </span><br><span class="line">        ArrayList&lt;<span class="keyword">String</span>&gt; res = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> len = <span class="built_in">str</span>.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="built_in">boolean</span>[len];</span><br><span class="line">         </span><br><span class="line">        PermutationAux(<span class="built_in">str</span>,len,<span class="number">0</span>,<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> tt : t)</span><br><span class="line">            res.<span class="built_in">add</span>(tt);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> PermutationAux(<span class="keyword">String</span> s,<span class="built_in">int</span> n,<span class="built_in">int</span> cnt,StringBuilder sb)&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(sb.length() == n)&#123;</span><br><span class="line">            t.<span class="built_in">add</span>(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                sb.<span class="built_in">append</span>(s.charAt(i));</span><br><span class="line">                PermutationAux(s,n,cnt+<span class="number">1</span>,sb);</span><br><span class="line">                sb.setLength(sb.length()<span class="number">-1</span>);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解决思路2-字典序排列算法"><a href="#解决思路2-字典序排列算法" class="headerlink" title="解决思路2-字典序排列算法"></a>解决思路2-字典序排列算法</h2><p>一个全排列可看做一个字符串，字符串可有前缀、后缀。<br>生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。<br>这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。</p><p>【例】 如何得到346987521的下一个<br>1，从尾部往前找第一个P(i-1) &lt; P(i)的位置<br>3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1<br>最终找到6是第一个变小的数字，记录下6的位置i-1</p><p>2，从i位置往后找到最后一个大于6的数<br>    3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1<br>最终找到7的位置，记录位置为m</p><p>3，交换位置i-1和m的值<br>    3 4 7 9 8 6 5 2 1<br>4，倒序i位置后的所有数据<br>    3 4 7 1 2 5 6 8 9<br>则347125689为346987521的下一个排列</p><p>详情可以参考<a href="https://www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7" target="_blank" rel="noopener">牛客网</a>上@天天502关于这个揭发这个回答。</p><h2 id="java代码2"><a href="#java代码2" class="headerlink" title="java代码2"></a>java代码2</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;<span class="keyword">String</span>&gt; Permutation(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;<span class="keyword">String</span>&gt; res = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> len = <span class="built_in">str</span>.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">char</span>[] ch =  <span class="built_in">str</span>.toCharArray();</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(ch);</span><br><span class="line">        res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(ch));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> l = len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&gt;<span class="number">0</span>&amp;&amp;ch[l<span class="number">-1</span>]&gt;=ch[l]) l--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">int</span> r = l;</span><br><span class="line">            <span class="keyword">while</span>(r&lt;len&amp;&amp;ch[r]&gt;ch[l<span class="number">-1</span>]) r++;</span><br><span class="line">            </span><br><span class="line">            swap(ch,l<span class="number">-1</span>,r<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">reverse</span>(ch,l);</span><br><span class="line">            </span><br><span class="line">            res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(ch));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="built_in">reverse</span>(<span class="built_in">char</span>[] chars,<span class="built_in">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars==<span class="keyword">null</span> || chars.length&lt;=k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;(len-k)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> m = k+i;</span><br><span class="line">            <span class="built_in">int</span> n = len<span class="number">-1</span>-i;</span><br><span class="line">            <span class="keyword">if</span>(m&lt;=n)&#123;</span><br><span class="line">                swap(chars,m,n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> swap(<span class="built_in">char</span>[] cs,<span class="built_in">int</span> i,<span class="built_in">int</span> j)&#123;</span><br><span class="line">        <span class="built_in">char</span> temp = cs[i];</span><br><span class="line">        cs[i] = cs[j];</span><br><span class="line">        cs[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目要求：&quot;&gt;&lt;a href=&quot;#题目要求：&quot; class=&quot;headerlink&quot; title=&quot;题目要求：&quot;&gt;&lt;/a&gt;题目要求：&lt;/h2&gt;&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://9191rs.me/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="剑指offer" scheme="https://9191rs.me/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第51题  N-Queens</title>
    <link href="https://9191rs.me/posts/26372/"/>
    <id>https://9191rs.me/posts/26372/</id>
    <published>2018-04-08T14:19:14.000Z</published>
    <updated>2018-08-01T11:12:25.876Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>N皇后问题是一个非常经典的问题，即如何能够在N*N的棋盘上放置N个皇后，使得任何一个皇后都无法直接吃掉其他的皇后。为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。注意仅当 N= 1 或N≥ 4 时问题有解。<br><img src="/posts/26372/1.bmp" alt="这里写图片描述"></p><p>这个问题依然可以用递归来解决。由于每一行只能放置一个皇后，所以可以尝试在从每一行的N个位置上尝试放置皇后，直到放满N个皇后。在尝试的过程中，维护三个数组表示该位置是否可以放置皇后，其中列用自身表示，主对角线上用横竖坐标的差表示，副对角线上用横竖坐标的和表示。</p><h2 id="JAVA代码实现"><a href="#JAVA代码实现" class="headerlink" title="JAVA代码实现"></a>JAVA代码实现</h2><pre><code>class Solution {     boolean[] col = null;     boolean[] dia1 = null;     boolean[] dia2 = null;      List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();     public  List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {         col = new boolean[n];         dia1 = new boolean[2*n-1];         dia2 = new boolean[2*n-1];         dfs(n, 0, new ArrayList&lt;&gt;());         return res;              }     public  void dfs(int n,int row,List&lt;Integer&gt; st) {         if(row==n){             res.add(aux(n, st));             return;         }         for(int i=0;i&lt;n;i++){             if(!col[i]&amp;&amp;!dia1[row-i+n-1]&amp;&amp;!dia2[row+i]){                 col[i] = true;                 dia1[row-i+n-1] = true;                 dia2[row+i] = true;                 st.add(i);                 dfs(n, row+1, st);                 st.remove(st.size()-1);                 col[i] = false;                 dia1[row-i+n-1] = false;                 dia2[row+i] = false;             }         }     }     public List&lt;String&gt; aux(int n,List&lt;Integer&gt; st) {         char[] t = new char[n];         List&lt;String&gt; temp = new ArrayList&lt;&gt;();         for(int i=0;i&lt;n;i++) t[i] = &apos;.&apos;;                         for(int i=0;i&lt;n;i++){             int k = st.get(i);             t[k] = &apos;Q&apos;;             temp.add(String.valueOf(t));             t[k] = &apos;.&apos;;          }         return temp;              }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;N皇后问题是一个非常经典的问题，即如何能够在N*N的棋盘上放置N个皇后，使得任何一个皇后都无法直接吃掉其他的皇后。为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。注意仅当 N= 1 或N≥ 4 时问题有解。&lt;br&gt;&lt;img 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第77题 Combinations</title>
    <link href="https://9191rs.me/posts/11001/"/>
    <id>https://9191rs.me/posts/11001/</id>
    <published>2018-04-08T13:53:43.000Z</published>
    <updated>2018-08-01T11:12:25.877Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定两个整数n和k，返回1 … n中所有可能的k个数的组合。</p><p>例如下图：<br><img src="/posts/11001/1.png" alt="这里写图片描述"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于1到n个整数进行k个组合，可以这样构造一个递归树，对与 整数i来说，只要能从i到n中找到k-1个元素即可，在这个递归过程中记录递归结果，等记录到k个结果时，就返回。</p><h2 id="JAVA代码"><a href="#JAVA代码" class="headerlink" title="JAVA代码"></a>JAVA代码</h2><pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {        if(n&lt;=0||k&lt;=0||k&gt;n) return res;        combineAux(n,k,1,new ArrayList&lt;Integer&gt;());        return res;    }    private void combineAux(int n,int k,int sta,List&lt;Integer&gt; t){        if(t.size()==k){            res.add(new ArrayList(t));            return;        }        for(int i = sta;i&lt;=n-(k-t.size())+1;i++){            t.add(i);            combineAux(n,k,i+1,t);            t.remove(t.size()-1);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;p&gt;给定两个整数n和k，返回1 … n中所有可能的k个数的组合。&lt;/p&gt;
&lt;p&gt;例如下图：&lt;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第46题和第47题 全排列问题</title>
    <link href="https://9191rs.me/posts/49137/"/>
    <id>https://9191rs.me/posts/49137/</id>
    <published>2018-04-08T13:41:07.000Z</published>
    <updated>2018-08-01T11:12:25.875Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>leetcode 第46题和第47题 都是求一个给定数组中的全排列问题，不同之处在于47题中数组的元素可以重复。</p><h3 id="leetcode-第46题-解题思路"><a href="#leetcode-第46题-解题思路" class="headerlink" title="leetcode 第46题 解题思路"></a>leetcode 第46题 解题思路</h3><p>这也是一个递归问题。对于数组中的每个元素，它的全排列就等于它本身加上除它以外所有的全排。所以只要这样依次计算全排列就行。</p><h3 id="JAVA代码实现"><a href="#JAVA代码实现" class="headerlink" title="JAVA代码实现"></a>JAVA代码实现</h3><pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    boolean[] used = null;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {        res.clear();        if(nums.length==0) return res;        used = new boolean[nums.length];        permuteAux(nums,0, new ArrayList&lt;&gt;());        return res;    }    private void permuteAux(int[] nums,int index,List&lt;Integer&gt; st) {        if(index == nums.length){            List&lt;Integer&gt; t = new ArrayList&lt;&gt;(st);            res.add(t);            return;        }        for(int i=0;i&lt;nums.length;i++){            if(used[i]) continue;            st.add(nums[i]);            used[i] = true;            permuteAux(nums,index+1,st);            used[i] = false;            st.remove(st.size()-1);        }        return;    }}</code></pre><h3 id="leetcode-第47题-解题思路"><a href="#leetcode-第47题-解题思路" class="headerlink" title="leetcode 第47题 解题思路"></a>leetcode 第47题 解题思路</h3><p>这也是一个递归问题。解题思路与46图题基本一致，但是却必须做出一些，改变，首先必须使得数组有序，在对数组中的每个元素进行全排列的时候，如果该元素与前一个元素相同，且前面一个元素已经完成了全排列，则跳过这个元素。</p><h3 id="JAVA代码实现-1"><a href="#JAVA代码实现-1" class="headerlink" title="JAVA代码实现"></a>JAVA代码实现</h3><pre><code>class Solution {    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    boolean[] used = null;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {        res.clear();        if(nums.length==0) return res;        used = new boolean[nums.length];        Arrays.sort(nums);        permuteAux(nums,0, new ArrayList&lt;&gt;());        return res;    }    private void permuteAux(int[] nums,int index,List&lt;Integer&gt; st) {        if(index == nums.length){            List&lt;Integer&gt; t = new ArrayList&lt;&gt;(st);            res.add(t);            return;        }        for(int i=0;i&lt;nums.length;i++){            if(used[i]) continue;            if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue;            st.add(nums[i]);            used[i] = true;            permuteAux(nums,index+1,st);            used[i] = false;            st.remove(st.size()-1);        }        return;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;leetcode 第46题和第47题 都是求一个给定数组中的全排列问题，不同之处在于47题中数组的元素可以重复。&lt;/p&gt;
&lt;h3 id=&quot;leetcode-第46题-解题思路&quot;&gt;&lt;a href=&quot;#leetcode-第46题-解题思路&quot; 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第17题 Letter Combinations of a Phone Number</title>
    <link href="https://9191rs.me/posts/24625/"/>
    <id>https://9191rs.me/posts/24625/</id>
    <published>2018-04-08T13:08:48.000Z</published>
    <updated>2018-08-01T11:12:25.872Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个数字字符串，返回数字可能表示的所有可能的字母组合。 数字到字母的映射（就像在电话按钮上一样）在下面给出。<br><img src="/posts/24625/1.bmp" alt="这里写图片描述"></p><p>例如： 输入字符串 “23”，输出结果为： “ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是一个典型的可以用递归解决的树形问题。对于每个数字，都分别代表了几个字母。组合在一起就变成了一个树。</p><h2 id="JAVA代码实现"><a href="#JAVA代码实现" class="headerlink" title="JAVA代码实现"></a>JAVA代码实现</h2><pre><code>class Solution {    String[] aux = {&quot; &quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;};    List&lt;String&gt; res = new ArrayList&lt;&gt;();    public List&lt;String&gt; letterCombinations(String digits) {        res.clear();        if(digits.length()==0) return res;        letterCombinationsAux(digits,0,&quot;&quot;);        return res;    }    private void letterCombinationsAux(String d,int index,String s){        if(index==d.length()){            res.add(s);            return ;        }        String t = aux[d.charAt(index)-&apos;0&apos;];        for(int i = 0;i&lt;t.length();i++)            letterCombinationsAux(d,index+1,s+t.charAt(i));        return ;     }}</code></pre><p>原题地址：<a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;p&gt;给定一个数字字符串，返回数字可能表示的所有可能的字母组合。 数字到字母的映射（就像在电话
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树（BST）的相关问题</title>
    <link href="https://9191rs.me/posts/8235/"/>
    <id>https://9191rs.me/posts/8235/</id>
    <published>2018-04-01T14:14:52.000Z</published>
    <updated>2018-08-01T11:12:25.880Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>前言：在二叉搜索树中，对于每个结点，它的所有左子树结点的元素小于当前节点数据，所有右子树结点大于当前结点。<br>二叉搜索树的三种常见操作：查找、删除、插入。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在查找操作中，就可以看到二叉搜索树的优势，它的时间复杂度为O(lg n).</p><pre><code>//查找 public TreeNode find(TreeNode root，int data){     if(root == null)  return null;     if(root.val&gt;data) return find(root.left,data);     if(root.val&lt;data) return find(root.right,data);     return root;         }//查找最小值 public TreeNode findMin(TreeNode root){     if(root == null)  return null;     if(root.left==null) return root;     return findMax(root.left);         }   //查找最大值public TreeNode findMax(TreeNode root) {    if(root==null) return null;    if(root.right==null)  return root;        return findMax(root.right);            }</code></pre><h3 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3><p>思路：首先找到要插入数据的位置，与查找类似。当找到这个位置后，如果数据已经存在，则直接返回即可，否则，将数据插入到走过的最后一个位置上。</p><pre><code>public TreeNode insert(TreeNode root，int data){    if(root == null) {       root  = new TreeMode(data);       root.left = null;       root.right = null;   }     if(root.val&gt;data) root.left = insert(root.left,data);    if(root.val&lt;data) root.right = insert(root.right,data);    return root;        }</code></pre><h3 id="删除：-leetcode第450题-Delete-Node-in-a-BST"><a href="#删除：-leetcode第450题-Delete-Node-in-a-BST" class="headerlink" title="删除： leetcode第450题 Delete Node in a BST"></a>删除： leetcode第450题 Delete Node in a BST</h3><p>思路：首先找到这个结点，然后删除这个结点即可。删除的过程中听注意：如果该节点的为叶子结点，直接删除结点；如果只有一个孩子结点，就用这个结点替代即可；如果该节点有两个结点，可以有两种做法：1，用左子树中最大的结点替换该节点，并在左子树中删除该最大节点。2、用右子树中最小的结点替换该节点，并在右子树中删除该最小节点。</p><p>java代码实现</p><pre><code>class Solution {    //考虑四种情况    public TreeNode deleteNode(TreeNode root, int key) {        if(root ==null) return null;        if(root.val&gt;key){            root.left = deleteNode(root.left, key);        }else if(root.val&lt;key){            root.right = deleteNode(root.right,key);        }else{            if(root.left!=null&amp;&amp;root.right!=null){               TreeNode t = findMax(root.left);               root.val = t.val;               root.left = deleteNode(root.left,t.val);            }else{                               if(root.left==null)                    root = root.right;                else                    root = root.left;            }         }        return   root;      }    public TreeNode findMax(TreeNode root) {        if(root==null) return null;        if(root.right==null)  return root;        return findMax(root.right);                }}</code></pre><h3 id="判断：leetcode第98题-Validate-Binary-Search-Tree"><a href="#判断：leetcode第98题-Validate-Binary-Search-Tree" class="headerlink" title="判断：leetcode第98题 Validate Binary Search Tree"></a>判断：leetcode第98题 Validate Binary Search Tree</h3><p>思路：只要保证当前节点的左子树中的最大值小于当前节点，右子树中的最小值大于当前节点的值。遍历整个树中的结点即可。这里我们会犯得的一个错误是，仅判断当前结点的左孩子结点小于当前结点，右孩子结点大于当前结点是不够的。原因就在于左子树中可能存在比当前结点大的值。右子树存在比当前结点小的值。</p><p>JAVA代码实现</p><pre><code>class Solution {    public boolean isValidBST(TreeNode root) {        if(root ==null) return true;        if(root.left!=null&amp;&amp;findMax(root.left).val &gt;=root.val) return false;        if(root.right!=null&amp;&amp;findMin(root.right).val&lt;=root.val) return false;        return isValidBST(root.left)&amp;&amp;isValidBST(root.right);    }    public TreeNode findMax(TreeNode root){        if(root == null)  return null;         if(root.right==null) return root;        return findMax(root.right);            }    public TreeNode findMin(TreeNode root){        if(root == null)  return null;        if(root.left==null) return root;        return findMax(root.left);            }    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;前言：在二叉搜索树中，对于每个结点，它的所有左子树结点的元素小于当前节点数据，所有右子树结点大于当前结点。&lt;br&gt;二叉搜索树的三种常见操作：查找、删除、插入。&lt;/p&gt;
&lt;h3 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;he
      
    
    </summary>
    
      <category term="二叉树" scheme="https://9191rs.me/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="BST" scheme="https://9191rs.me/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第235题 和 第236 题：Lowest Common Ancestor</title>
    <link href="https://9191rs.me/posts/4885/"/>
    <id>https://9191rs.me/posts/4885/</id>
    <published>2018-04-01T13:11:09.000Z</published>
    <updated>2018-08-08T14:17:39.806Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>前言：第235题 和 第236 题都是求解一棵树中两个结点最近公共祖先（LCA）问题，但是不同之处在于235给出的树为一棵二叉搜索树（BST），而236是一颗一般的二叉树，这样的话在235中利用BST的性质可以很方便的解决问题，但是在236中就必须全面考虑。<br>一般而言，找一棵树的LCA可以分为三种情况：俩个结点分别在LCA的不同子树，两个结点中的一个就是LCA。</p><h3 id="第235题-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#第235题-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="第235题 Lowest Common Ancestor of a Binary Search Tree"></a>第235题 Lowest Common Ancestor of a Binary Search Tree</h3><p>思路：考虑到BST树的特殊结构：左子树中所有结点的值都比当前结点的值小，右子树中所有结点的值都比当前结点的值小。所以只要找到第一个结点的值的取值在给定的两个结点之间，这个结点就是要找的LCA。具体来说，就是尽量保证这两个结点在LCA的不同子树。</p><p>JAVA代码实现</p><pre><code>class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if(root==null) return null;        if(p.val&lt;root.val&amp;&amp;q.val&lt;root.val)            return lowestCommonAncestor(root.left, p, q);        if(p.val&gt;root.val&amp;&amp;q.val&gt;root.val)            return lowestCommonAncestor(root.right, p, q);        return root;    }}</code></pre><h3 id="第236题"><a href="#第236题" class="headerlink" title="第236题"></a>第236题</h3><p>思路：对于一般的二叉树说，给定的两个结点出现的次数，出现的位置，都是不确定的甚至给定两个结点的值都可能是一样的。考虑到LCA出现的三种情况，当我们在递归的过程中，从根节点开始，只要遇到节点为空，结点为给定结点中的一个，就返回比较，如果在左子树和右子树中返回的结点都不为空，就返回当前结点，负责就返回不为空的那个。</p><p>JAVA代码实现</p><pre><code>class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if(root == null||root == q||root == p)             return root;        TreeNode l = lowestCommonAncestor(root.left, p, q);        TreeNode r = lowestCommonAncestor(root.right, p, q);        if(l!=null&amp;&amp;r!=null)            return root;        return l!=null?l:r;            }}</code></pre><p>注意：这两个题都有一个隐含条件：就是要查找的两个结点已经在树中包含，负责在查找之前，我们还要判断这两个结点是否在树中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;前言：第235题 和 第236 题都是求解一棵树中两个结点最近公共祖先（LCA）问题，但是不同之处在于235给出的树为一棵二叉搜索树（BST），而236是一颗一般的二叉树，这样的话在235中利用BST的性质可以很方便的解决问题，但是在23
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第19题 Remove Nth Node From End of List</title>
    <link href="https://9191rs.me/posts/50137/"/>
    <id>https://9191rs.me/posts/50137/</id>
    <published>2018-03-25T14:02:12.000Z</published>
    <updated>2018-08-01T11:12:25.873Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定一个链表和一个整数n,移除链表的倒数第n个节点<br>假设给定的整数n在链表的范围内。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>如果先将链表遍历一遍，很容易移除数第n个元素。但是如果只能遍历一遍时，有一个很巧妙的办法是设置一个快指针，一个慢指针，当快节点到达链表末尾时，慢指针刚好到达倒数第n+1个节点。要实现这种思路，只要先将快指针移动n+1次，然后两个一起移动即可。</p><h3 id="JAVA代码实现"><a href="#JAVA代码实现" class="headerlink" title="JAVA代码实现"></a>JAVA代码实现</h3><pre><code>/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode removeNthFromEnd(ListNode head, int n) {        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode pro = dummy;        ListNode cur = dummy;        for(int i=0;i&lt;n+1;i++)            cur = cur.next;        while(cur!=null){            cur = cur.next;            pro = pro.next;        }        pro.next = pro.next.next;        return dummy.next;    }}</code></pre><p>一点拓展：若个整数n的长度可以是任意的，就必须先计算除链表的长度，让后比较，进行相应的处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;p&gt;给定一个链表和一个整数n,移除链表的倒数第n个节点&lt;br&gt;假设给定的整数n在链表的范围内
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>基于链表的归并排序</title>
    <link href="https://9191rs.me/posts/47140/"/>
    <id>https://9191rs.me/posts/47140/</id>
    <published>2018-03-25T13:37:25.000Z</published>
    <updated>2018-08-03T09:52:27.742Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>归并排序排序是一种常用的时间复杂度为O(n*lg n)的算法，它的基本想法是先对数据不断二分，然后对分开的每段数据进行合并，利用递归的思想，很容易完成排序。归并排序又分为自顶向下和自底向上两种实现方式，自顶向下实现起来比较简单，就是递归，对数据进行二分和合并。对与自底向上而言，，则需要考虑到每次归并元素的个数。<br>这里要注意的是，对与每次归并来说，必须保证链表的完整性，不能出现链表断裂的情况。</p><h2 id="JAVA代码实现"><a href="#JAVA代码实现" class="headerlink" title="JAVA代码实现"></a>JAVA代码实现</h2><p>1.自顶向下</p><pre><code>/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode sortList(ListNode head) {        if(head==null||head.next==null)            return head;        ListNode pro =null;        ListNode slow = head;        ListNode fast = head;        while(fast!=null&amp;&amp;fast.next!=null){            pro = slow;            slow = slow.next;            fast = fast.next.next;        }        pro.next = null;        ListNode l1 = sortList(head);        ListNode l2 = sortList(slow);        return merge(l1,l2);    }    public ListNode merge(ListNode l1, ListNode l2) {        if(l1==null) return l2;        if(l2==null) return l1;        ListNode dummy = new ListNode(0);        ListNode cur = dummy;        while(l1!=null||l2!=null){            int c1 = Integer.MAX_VALUE;            int c2 = Integer.MAX_VALUE;            if(l1!=null) c1 = l1.val;            if(l2!=null) c2 = l2.val;            if(c1&lt;c2){                cur.next = l1;                cur = l1;                l1 = l1.next;            }else{                cur.next = l2;                cur = l2;                l2 = l2.next;            }        }        return dummy.next;    }}</code></pre><p>2.自底向上</p><pre><code>/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode sortList(ListNode head) {      if(head==null||head.next==null)        return head;      ListNode cur = head;          int count = 0;      while(cur!=null){          cur = cur.next;          count++;      }      ListNode dummy = new ListNode(0);      dummy.next = head;      for(int step=1;step&lt;count;step +=step){          cur = dummy.next;          ListNode left = null;          ListNode right = null;          ListNode end = dummy;          while(cur!=null){              ListNode t = null;              left = cur;              for(int i=0;cur!=null&amp;i&lt;step;i++){                  t = cur;                  cur = cur.next;              }              t.next = null;              right = cur;              //把end作为下一段代码开始的头节点              for(int i=0;cur!=null&amp;i&lt;step;i++){                  t = cur;                  cur = cur.next;              }              t.next = null;              end = merge(left,right,end);          }      }      return dummy.next;  }    public  ListNode merge(ListNode l1, ListNode l2,ListNode dummy) {        if(l1==null){            dummy.next = l2;            return null;        }        if(l2==null) {            dummy.next = l1;            return null;        }        ListNode cur = dummy;        while(l1!=null||l2!=null){            int c1 = Integer.MAX_VALUE;            int c2 = Integer.MAX_VALUE;            if(l1!=null) c1 = l1.val;            if(l2!=null) c2 = l2.val;            if(c1&lt;c2){                cur.next = l1;                cur = l1;                l1 = l1.next;            }else{                cur.next = l2;                cur = l2;                l2 = l2.next;            }        }        return cur;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;归并排序排序是一种常用的时间复杂度为O(n*lg n)的算法，它的基本想法是先对数据不断二分，然后对分开的每段数据进行合并，利用递归的思想，很容易完成排序。归并排序又分为自顶向下和自底向上两种实现方式，自顶向下实现起来比较简单，就是递归，
      
    
    </summary>
    
      <category term="链表" scheme="https://9191rs.me/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
      <category term="数据结构" scheme="https://9191rs.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>基于链表的插入排序</title>
    <link href="https://9191rs.me/posts/34037/"/>
    <id>https://9191rs.me/posts/34037/</id>
    <published>2018-03-25T13:15:43.000Z</published>
    <updated>2018-08-12T03:31:35.899Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="插入排序的基本介绍"><a href="#插入排序的基本介绍" class="headerlink" title="插入排序的基本介绍"></a>插入排序的基本介绍</h3><p>插入排序的时间复杂度为O(n*n),但是在 给定数据近乎有序的情况下，它的时间复杂度可以接近O(n).它的基本思想是对于当前的节点。不断与该节点前面节点进行比较，直到它前面的数据小于它。如下图所示：  </p><p><img src="/posts/34037/1.bmp" alt="">  </p><p>对元素2进行排序时，只要往前一直找，就可以将它插入合适的位置。<br>插入排序基于数组很容易实现，原因在于我们可以很方便的找到每一个位置上的数据。但是链表不能这么做，原因在于很难直接去到每一个元素。结合链表的特点，我们可以设置一个虚拟的头节点，对于每一个节点，都要从该虚拟节点开始，一直到大于这个节点的数为止。</p><h3 id="JAVA代码实现"><a href="#JAVA代码实现" class="headerlink" title="JAVA代码实现"></a>JAVA代码实现</h3><hr><pre><code>/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode insertionSortList(ListNode head) {        if(head==null) return head;        ListNode dummy = new ListNode(0);        ListNode pro = dummy;        ListNode cur = head;        while(cur!=null){            ListNode nex = cur.next;            while(pro.next!=null&amp;&amp;pro.next.val&lt;cur.val)                pro = pro.next;            cur.next = pro.next;            pro.next = cur;            pro = dummy;            cur = nex;        }        return dummy.next;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;插入排序的基本介绍&quot;&gt;&lt;a href=&quot;#插入排序的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;插入排序的基本介绍&quot;&gt;&lt;/a&gt;插入排序的基本介绍&lt;/h3&gt;&lt;p&gt;插入排序的时间复杂度为O(n*n),但是在 给定
      
    
    </summary>
    
      <category term="链表" scheme="https://9191rs.me/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
      <category term="数据结构" scheme="https://9191rs.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 第149题  Max Points on a Line</title>
    <link href="https://9191rs.me/posts/33753/"/>
    <id>https://9191rs.me/posts/33753/</id>
    <published>2018-03-18T12:58:29.000Z</published>
    <updated>2018-08-01T11:12:25.871Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h2><p>给定2D平面上的n个点，找出位于同一条直线上的最大点数。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>这个问题的一种方案是考虑两点之间斜率，把斜率相同的点放置在一个表中，再找到包含最多点的斜率。这个其中有两点需要关注，一个是点坐标的取值范围，一个是涉及斜率计算的问题。<br>我的想法是对于每一个点，分别计算在它之后的所有不同点的斜率，并且用一个Map集合存起来，对于这个点，找出斜率最大的那个。考虑它的正确性，我们可以假设一种极端情况，即给定所有的点都在一条直线上，那么第一个点中肯定已经可以计算所要的结果，其他的点虽然能正常运行，但是同一个斜率得到结果肯定比第一个少。<br>这里还要指出的是，斜率计算的问题，当横坐标相同时，用Integer.MAX_VALUE表示。考虑到Double运算可能会出现精度溢出情况，采用了BigDecimal类来计算精确结果。</p><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><pre><code>/** * Definition for a point. * class Point { *     int x; *     int y; *     Point() { x = 0; y = 0; } *     Point(int a, int b) { x = a; y = b; } * } */class Solution {    public  int maxPoints(Point[] points) {        int res = 1;        if(points.length==0) return 0;        for(int i =0;i&lt;points.length;i++){            HashMap&lt;Double,Integer&gt; hm = new HashMap&lt;&gt;();            hm.put((double) Integer.MIN_VALUE,1);//当points数组不空时，直线上必有一点            int de = 0;            for(int j=i+1;j&lt;points.length;j++){                if((points[i].y==points[j].y)&amp;&amp;(points[i].x==points[j].x)){                     de++;                }else{                    double tt = dis(points[i],points[j]);                    if(hm.containsKey(tt))                        hm.put(tt,hm.get(tt)+1);                    else                        hm.put(tt,2);                               }               }            for(int re:hm.values())                                 res  = Math.max(res, de+re);        }        return res;    }    public static double dis(Point p1, Point p2) {        if((p1.x-p2.x)==0)             return (double)Integer.MAX_VALUE;        if(p1.y==p2.y)             return 0;        java.math.BigDecimal bd1 = new java.math.BigDecimal(Double.toString(p1.y-p2.y));         java.math.BigDecimal bd2 = new java.math.BigDecimal(Double.toString(p1.x-p2.x));         return bd1.divide                 (bd2,16,java.math.BigDecimal.ROUND_HALF_UP).doubleValue();     }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目要求：&quot;&gt;&lt;a href=&quot;#题目要求：&quot; class=&quot;headerlink&quot; title=&quot;题目要求：&quot;&gt;&lt;/a&gt;题目要求：&lt;/h2&gt;&lt;p&gt;给定2D平面上的n个点，找出位于同一条直线上的最大点数。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode Two Sum问题</title>
    <link href="https://9191rs.me/posts/56041/"/>
    <id>https://9191rs.me/posts/56041/</id>
    <published>2018-03-18T12:19:36.000Z</published>
    <updated>2018-08-01T11:12:25.868Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li><strong>Two Sum I</strong></li><li><strong>Two Sum II - Input array is sorted</strong></li></ul><hr><h2 id="第1题-Two-Sum-I"><a href="#第1题-Two-Sum-I" class="headerlink" title="第1题 Two Sum I"></a>第1题 Two Sum I</h2><p><strong>题目要求:</strong></p><blockquote><p>给定一个整数数组，返回这两个数字的索引，使它们合计成一个特定的目标。<br>限定条件：<br>返回值为这两个数字的索引，索引从0开始<br>假定每个输入都只有一个解，且不能使用相同的元素两次</p></blockquote><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>由于数组有序，故采用对撞指针的方法。设置两个指针分别指向数组的头尾，当两个数的和大于给定的值时，右指针左移，小于时，左指针右移。这里需要注意的时，左指针必须小于右指针。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code>public int[] twoSum(int[] nums, int target) {    int [] res = new int[2];    HashMap&lt;Integer,Integer&gt; tm = new HashMap&lt;&gt;();    for(int i =0;i&lt;nums.length;i++){        if(tm.containsKey(target - nums[i])){            res[0]=tm.get(target-nums[i]);            res[1]=i;        }else{            tm.put(nums[i],i);        }    }         return res;}</code></pre><h2 id="第167题Two-Sum-II"><a href="#第167题Two-Sum-II" class="headerlink" title="第167题Two Sum II"></a>第167题Two Sum II</h2><p><strong>题目要求:</strong></p><blockquote><p>给定已按升序排序的整数数组，找到两个数字，使它们合计为特定的目标数字。</p></blockquote><p><strong>限定条件</strong></p><p>返回值为这两个数字的索引，且该索引是从1开始</p><p>假定每个输入都只有一个解，且不能使用相同的元素两次</p><h4 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h4><p>由于数组可能无序，且要返回的是元素的索引。所以我想到的办法是利用Set集合建立一个查找表，遍历整个数组，每次放入一个新元素时，在表中查找是否有target - nums[i]，如果存在则返回相应的索引，反之则继续遍历。</p><h3 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h3><pre><code>public  int[] twoSum(int[] numbers, int target) {    int[] arr = new int[2];   int l = 0,r = numbers.length-1;   while(l&lt;r){    if(numbers[l]+numbers[r]&gt;target) r--;    else if(numbers[l]+numbers[r]&lt;target) l++;    else{        arr[0] = l+1;        arr[1] = r+1;        break;    }   }   return arr;}</code></pre><h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><p>对比上述两个题目可以看出，需要解决的问题几乎一致，但是由于给定条件不一样，数组是否有序，导致解决问题的思路也不一样，一般来说，上述两种方法也是比较常见的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Two Sum I&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Two Sum II - Input array is sorted&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode76题 Minimum Window Substring</title>
    <link href="https://9191rs.me/posts/45681/"/>
    <id>https://9191rs.me/posts/45681/</id>
    <published>2018-03-11T12:16:31.000Z</published>
    <updated>2018-08-01T11:12:25.878Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="最小窗口子字符串"><a href="#最小窗口子字符串" class="headerlink" title="最小窗口子字符串"></a>最小窗口子字符串</h2><blockquote><p>题目要求：给定一个字符串S和T，在S中找到一个包含T中所有字符的最短字串，时间复杂度为O(n).<br>注1：如果这个窗口不存在，返回一个空字符串<br>注2：该题保证在S中总是只有一个唯一的最小窗口</p></blockquote><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a><strong>解决思路</strong></h3><p>采用滑动窗口的方法，首先定义一个HashMap集合，用来记录T中字符出现的次数，同时定义一个计数变量来统计所得到的字符串是否包含T中所有的字符。<br>具体做法为：当定义的滑动窗口的右指针不断向右滑动，找到包含T中所有字符的字串。然后通过控制窗口的滑动，尽可能的减少该字串的长度。</p><h3 id="Java语言解决方案"><a href="#Java语言解决方案" class="headerlink" title="Java语言解决方案"></a><strong>Java语言解决方案</strong></h3><pre><code>class Solution {    public String minWindow(String s, String t) {        if(s.length()&lt;t.length()) return &quot;&quot;;        char[] ss = s.toCharArray();        char[] tt = t.toCharArray();        int count = t.length();        String res = &quot;&quot;;        HashMap&lt;Character,Integer&gt; hm = new HashMap&lt;&gt;();        for(int i=0;i&lt;t.length();i++)            if(hm.containsKey(tt[i]))                hm.put(tt[i], hm.get(tt[i])+1);            else                hm.put(tt[i], 1);                       int l=0,r=0;        while(r&lt;s.length()){            if(hm.containsKey(ss[r])){                if(hm.get(ss[r])&gt;0)                    count--;                hm.put(ss[r], hm.get(ss[r])-1);            }         while(l&lt;=r&amp;&amp;count==0){                if(res.isEmpty()||res.length()&gt;(r-l+1))                    res = s.substring(l,r+1);                if(hm.containsKey(ss[l])){                    hm.put(ss[l], hm.get(ss[l])+1);                    if(hm.get(ss[l])&gt;0)                        count++;                }                l++;                                        }               r++;        }       return res;    }}</code></pre><hr><p>题目链接: <a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/description/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;最小窗口子字符串&quot;&gt;&lt;a href=&quot;#最小窗口子字符串&quot; class=&quot;headerlink&quot; title=&quot;最小窗口子字符串&quot;&gt;&lt;/a&gt;最小窗口子字符串&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目要求：给定一个字符串S和T
      
    
    </summary>
    
      <category term="leetcode" scheme="https://9191rs.me/categories/leetcode/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>算法中时间复杂度分析</title>
    <link href="https://9191rs.me/posts/8713/"/>
    <id>https://9191rs.me/posts/8713/</id>
    <published>2018-03-05T02:47:54.000Z</published>
    <updated>2018-08-01T11:12:25.887Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>算法的时间复杂度表示算法运行所需要的时间</p><ul><li><strong>大O表示法</strong></li><li><strong>递归算法中时间复杂度分析</strong></li></ul><hr><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><p>大O表示法 是一种体现算法时间复杂度的记法，如果用n表示数据规模，那么O(f(n)表示算法说需要执行的指令数(消耗的时间)和 f(n) 成正比。大O表示法指出了算法执行的最低上限。(大O表示法的前边省略了一个常数)。</p><blockquote><p>例子：有一个字符数组，将数组中的每一个字符串按照字母排序，再将整个字符串数组按照字典序排序求这个算法的时间复杂度。<br>分析：假设每个字符串的最大长度是s，字符数组中一共有n个字符串。<br>* 对于一个字符串来说，进行排序的复杂度是O(s*log s),则整个字符数组的复杂度是O(n*s<em>log s)<br>\</em> 对于整个字符串数组排序的复杂度是O(n*log n)，而进行字典排序时每次最多进行s次比较，每次比较都是常数时间，所以复杂度是O(s*n<em>log n)<br>\</em> 综上：整个算法的复杂度是O(s*n*(log n +log s)</p></blockquote><p>常见的大O阶有常数阶O(1)，线性阶O(n)，平方阶O(n²)，对数阶O(logn)，nlogn阶O(nlogn)等等。如果有在有相同规模的n，则只保留最高阶，如O(n+n²) = O(n²)。</p><h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>随数据规模n线性增长。如下面的代码：</p><pre><code>for(int i=0;i&lt;n;i++){//时间复杂度为O(1)的算法...}       </code></pre><h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><p>接着看如下代码：</p><pre><code>int number=1;while(number&lt;n){    number=number*2;    //时间复杂度为O(1)的算法    ...}</code></pre><p>可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。</p><h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><p>下面的代码是循环嵌套：</p><pre><code>for(int i=0;i&lt;n;i++){     for(int j=i;j&lt;n;j++){     //复杂度为O(1)的算法     ...       }  }</code></pre><p>需要注意的是内循环中int j=i，而不是int j=0。当i=0时，内循环执行了n次；i=1时内循环执行了n-1次，当i=n-1时执行了1次，我可以推算出总的执行次数为：</p><blockquote><p>n+(n-1)+(n-2)+(n-3)+……+1 = n²/2+n/2</p></blockquote><p>只保留最高阶，因此保留n²/2，并且去掉这个项的常数，1/2,最终这段代码的时间复杂度为O(n²)。</p><p>注意：<br>1.以下代码的复杂度仍为O(n)，原因是只进行了30*n次基本操作。</p><pre><code>for(int i=0;i&lt;n;i++){     for(int j=0;j&lt;30;j++){     //复杂度为O(1)的算法     ...       }  }</code></pre><p>2.以下代码的复杂度仍为O(n*log n)。</p><pre><code>for(int i=1;i&lt;n;i +=i){     for(int j=0;j&lt;n;j++){     //复杂度为O(1)的算法     ...       }  }</code></pre><h6 id="以上充分说明，应该时刻关注数据规模，而不是一些形式上的类似。"><a href="#以上充分说明，应该时刻关注数据规模，而不是一些形式上的类似。" class="headerlink" title="以上充分说明，应该时刻关注数据规模，而不是一些形式上的类似。"></a>以上充分说明，应该时刻关注数据规模，而不是一些形式上的类似。</h6><hr><h2 id="递归算法中时间复杂度分析"><a href="#递归算法中时间复杂度分析" class="headerlink" title="递归算法中时间复杂度分析"></a>递归算法中时间复杂度分析</h2><h3 id="递归中进行一次递归调用"><a href="#递归中进行一次递归调用" class="headerlink" title="递归中进行一次递归调用"></a>递归中进行一次递归调用</h3><p>如下图所示，该二分查找只进行了一次递归调用。每次调用的复杂度为O(1),递归深度为O(log n),<br>故整个算法的复杂度为O(log n)。<br><img src="/posts/8713/1.png" alt="这里写图片描述"></p><p>一般来说,在递归函数中只递归一次递归调用，总体的复杂度为O(每个递归函数的时间复杂度*递归深度)</p><h3 id="递归中进行多次递归调用"><a href="#递归中进行多次递归调用" class="headerlink" title="递归中进行多次递归调用"></a>递归中进行多次递归调用</h3><p>此时应该关注的是调用次数，如下面代码所示：此时可以通过数递归树上的节点。<br><img src="/posts/8713/2.png" alt="这里写图片描述"><br>比如当n=3时，它的递归树如下图 右半侧，更一般的结论如左半侧所示。<br><img src="/posts/8713/3.png" alt="这里写图片描述"></p><p>又比如，在归并排序中，排序的数据规模都会减少一半，所以递归深度时log n，但是每层进行排序的数据规模都是n,所以时间复杂度是O(n*log n).<br><img src="/posts/8713/4.png" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;算法的时间复杂度表示算法运行所需要的时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大O表示法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归算法中时间复杂度分析&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="算法" scheme="https://9191rs.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://9191rs.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>判断链表成环，且找出环的起点</title>
    <link href="https://9191rs.me/posts/36499/"/>
    <id>https://9191rs.me/posts/36499/</id>
    <published>2017-11-28T13:14:00.000Z</published>
    <updated>2018-08-01T11:12:25.882Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="判断链表成环，且找出环的起点。"><a href="#判断链表成环，且找出环的起点。" class="headerlink" title="判断链表成环，且找出环的起点。"></a>判断链表成环，且找出环的起点。</h1><ul><li><strong>判断链表成环</strong></li><li><strong>找出环的起点</strong></li><li><strong>Java代码实现</strong></li></ul><hr><h2 id="1-判断链表是否成环"><a href="#1-判断链表是否成环" class="headerlink" title="1. 判断链表是否成环"></a>1. 判断链表是否成环</h2><blockquote><p>Floyd环判断法：从同一个起点同时开始以不同速度前进的2个指针最终相遇，那么可以判定存在一个环。</p></blockquote><p>设想：乌龟和兔子在同一个环上赛跑，跑的快的兔子速度为2，跑的慢的乌龟速度为1，则兔子终会赶上乌龟。</p><pre><code>理解：如果以乌龟为参考对象，则兔子前进的速度为1，这就意味着，兔子必将赶上乌龟。</code></pre><p>所以一个判断成环的方法是：先舍子两个指针都指向表头，其中p1每次前进一个节点，p2每次前进两个节点，且p1和p2同时走，当p2指向的地址为null，就证明链表没有环。如果在某个时刻，p1和p2指向的地址相同，那么链表就是有环的。</p><h2 id="2-找出环的起点"><a href="#2-找出环的起点" class="headerlink" title="2.找出环的起点"></a>2.找出环的起点</h2><p><img src="/posts/36499/1.jpg" alt="这里写图片描述"><br>同时可以进一步考虑：K1是等于零的，也就是p1在进入环后，走了不到一圈就在交点处和p2重合。因为p1在进入环的时候，p2和p1之间的距离（沿着行走方向）至多为 d2-1，不可能超过d2-1，因为环的大小也才只有d2 。p2追赶p1，最多只需要走d2-1步，因为每走一步，p1和p2的相对距离减小1，那么p1最多只走了d2-1步，就是最多只经过了d2-1个节点，不可能走完一圈。<br><img src="/posts/36499/2.jpg" alt="这里写图片描述"><br>最后推出的式子的含义可以理解为：d1的长度 = 环长度的整数倍 + 交点与环入口的距离<br>所以我们可以得出：当p1和p2相遇后，让p1回到原点，p2在相遇点，且两者每次都前进一个节点，当两者再次相遇时，就是环的起点。</p><h2 id="3-Java代码实现"><a href="#3-Java代码实现" class="headerlink" title="3. Java代码实现"></a>3. Java代码实现</h2><pre><code>int FindBeginLoop(ListNode head){    ListNode p1 = head, p2 = head;    boolean loopExists = false;    if(head == null)        return false;    //判断环是否存在    while(p2.getNext()!=null&amp;&amp;p2.getNext().getNext()!=null){        p1 = p1.getNext();        p2 = p2.getNext().getNext();        if(p1==p2)            loopExists = true;            break;    }    //如果环存在，寻找环的起点    if(loopExists){        p1 = head;        while(p1!=p2){            p1 = p1.getNext();            p2 = p2.getNext();        }        return p1;    }    return null; //不存在}//附：定义的LitNode类public class ListNode {    private int data;    private ListNode next;    public ListNode(int data) {        this.data = data;    }    public int getData() {        return data;    }    public void setData(int data) {        this.data = data;    }    public SingleListNode getNext() {        return next;    }    public void setNext(SingleListNode next) {        this.next = next;    }}</code></pre><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://www.cnblogs.com/snake-hand/p/3148328.html" target="_blank" rel="noopener">http://www.cnblogs.com/snake-hand/p/3148328.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;判断链表成环，且找出环的起点。&quot;&gt;&lt;a href=&quot;#判断链表成环，且找出环的起点。&quot; class=&quot;headerlink&quot; title=&quot;判断链表成环，且找出环的起点。&quot;&gt;&lt;/a&gt;判断链表成环，且找出环的起点。&lt;/h1&gt;&lt;ul
      
    
    </summary>
    
      <category term="链表" scheme="https://9191rs.me/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Java" scheme="https://9191rs.me/tags/Java/"/>
    
      <category term="leetcode" scheme="https://9191rs.me/tags/leetcode/"/>
    
      <category term="数据结构" scheme="https://9191rs.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://9191rs.me/posts/7251/"/>
    <id>https://9191rs.me/posts/7251/</id>
    <published>2017-10-18T12:19:36.000Z</published>
    <updated>2018-08-05T14:27:44.828Z</updated>
    
    <content type="html"><![CDATA[<p class="description">搭建一个属于自己的博客</p><p><img src="/posts/7251/blog.png" alt="" style="width:100%"><br><a id="more"></a></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>一直想搭建一个属于自己的博客，但都没有付诸行动，直到看见@<a href="http://tengj.top/" target="_blank" rel="noopener">嘟嘟独立博客</a>所写的<br>一列的hexo教程，终于开始动起来，花了一天的时间完成了这个过程。<br>之后计划将自己以前写过的一些东西一点点搬运过来。</p><hr><h2 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h2><hr><p><strong>hexo配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site 网站</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">爱生活,爱柒柒</span><span class="comment">#网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="comment">#网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">且自前行，莫问归处！</span> <span class="comment">#网站描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">LI</span> <span class="string">Ren</span><span class="comment">#您的名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span><span class="comment">#网站使用的语言</span></span><br><span class="line"><span class="attr">timezone:</span><span class="comment">#网站时区。Hexo 默认使用您电脑的时区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 网址</span></span><br><span class="line"><span class="comment">## 如果您的网站存放在子目录中，</span></span><br><span class="line"><span class="comment">##例如 http://yoursite.com/blog，</span></span><br><span class="line"><span class="comment">##则将url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">url:</span> <span class="attr">https://myrens.github.io/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  order_by:</span> <span class="bullet">-date</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改归档页面、某一分类页面、某一标签页面的显示篇数</span></span><br><span class="line"><span class="comment">## 参考：http://theme-next.iissnan.com/faqs.html#setting-page-size</span></span><br><span class="line"><span class="attr">archive_generator:</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  yearly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  monthly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  daily:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">category_generator:</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tag_generator:</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment"># RSS，要先进入站点文件夹根目录安装插件</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-feed --save 即可</span></span><br><span class="line"><span class="comment"># 无需更多配置</span></span><br><span class="line"><span class="comment"># 参数说明查看 README：https://github.com/hexojs/hexo-generator-feed</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="comment"># 文章数，0 为全部</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  hub:</span></span><br><span class="line"><span class="comment"># 是否包含文章内容</span></span><br><span class="line"><span class="attr">  content:</span> <span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">##commnet</span></span><br><span class="line"><span class="attr">disqus_shortname:</span> </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Swiftype Search Key</span></span><br><span class="line"><span class="attr">swiftype_key:</span> <span class="string">tLXWKdsstE5UZFCodRRQ</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># emoji 支持</span></span><br><span class="line"><span class="attr">githubEmojis:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  idName:</span> <span class="string">github-emoji</span></span><br><span class="line"><span class="attr">  unicode:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  styles:</span></span><br><span class="line"><span class="attr">  localEmojis:</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span>  </span><br><span class="line">        <span class="string">git@github.com:LLLRS/LLLRS.github.io.git,master</span></span><br></pre></td></tr></table></figure><hr><h2 id="next主题配置"><a href="#next主题配置" class="headerlink" title="next主题配置"></a><strong>next主题配置</strong></h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"><span class="comment"># ========================= ATTENTION! ==========================</span></span><br><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Theme Core Configuration Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set to true, if you want to fully override the default configuration.</span></span><br><span class="line"><span class="comment"># Useful if you don't want to inherit the theme _config.yml configurations.</span></span><br><span class="line"><span class="attr">override:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Site Information Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To get or check favicons visit: https://realfavicongenerator.net</span></span><br><span class="line"><span class="comment"># Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"><span class="comment"># And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For example, you put your favicons into `hexo-site/source/images` directory.</span></span><br><span class="line"><span class="comment"># Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点图标啦，直接去 https://realfavicongenerator.net</span></span><br><span class="line"><span class="comment"># 选项弄好后，下载压缩包，解压复制粘贴</span></span><br><span class="line"><span class="comment"># 建议放在 hexo-site/source/images/ 里（没有自己建）</span></span><br><span class="line"><span class="comment"># 这样可以避免更新 NexT 主题的时候遇到麻烦</span></span><br><span class="line"><span class="comment"># 最后记得要稍微改下文件名，与下面的保持一致</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line"><span class="attr">  small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line"><span class="attr">  medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line"><span class="attr">  apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line"><span class="attr">  safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line"><span class="attr">  android_manifest:</span> <span class="string">/images/manifest.json</span></span><br><span class="line"><span class="attr">  ms_browserconfig:</span> <span class="string">/images/browserconfig.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set default keywords (Use a comma to separate)</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">"Hexo, NexT, Java, Spring, ssm"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line"><span class="attr">rss:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup.</span></span><br><span class="line">  <span class="comment"># If not defined, current year will be used.</span></span><br><span class="line"><span class="attr">  since:</span> <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line"><span class="attr">  icon:</span> <span class="string">heart</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, will be used `author` from Hexo main config.</span></span><br><span class="line"><span class="attr">  copyright:</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">  <span class="comment"># Hexo 的链接</span></span><br><span class="line"><span class="attr">  powered:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line"><span class="attr">    version:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Any custom text can be defined here.</span></span><br><span class="line">  <span class="comment">#custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># SEO Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.</span></span><br><span class="line"><span class="comment"># See: https://support.google.com/webmasters/answer/139066</span></span><br><span class="line"><span class="comment"># Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )</span></span><br><span class="line"><span class="attr">canonical:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.</span></span><br><span class="line"><span class="attr">seo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If true, will add site-subtitle to index page, added in main hexo config.</span></span><br><span class="line"><span class="comment"># subtitle: Subtitle</span></span><br><span class="line"><span class="attr">index_with_subtitle:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target link.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span></span><br><span class="line"><span class="comment"># 菜单设置 || 菜单图标设置（图标上面说了，不重复）</span></span><br><span class="line"><span class="comment"># 项目换行可以更改显示顺序</span></span><br><span class="line"><span class="comment"># 如果这个项前会显示 .menu</span></span><br><span class="line"><span class="comment"># 解决方法：编辑 ~/blog/themes/next/languages 下的相应文件</span></span><br><span class="line"><span class="comment"># 比如添加一个“留言”菜单，站点配置文件的 language 是 zh-Hans</span></span><br><span class="line"><span class="comment"># 则编辑 zh-Hans.yml，在 menu: 项内添加一行 留言: 留言</span></span><br><span class="line"><span class="comment"># 注意空格，且符号 : 为英文字符！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social Links.</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target permalink.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="attr">https://github.com/LLLRS||</span> <span class="string">github</span></span><br><span class="line"><span class="attr">  E-Mail:</span> <span class="number">15311257617</span><span class="string">@163.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  Github:</span> <span class="string">github</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">友情链接</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">block</span></span><br><span class="line"><span class="comment">#links_layout: inline</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="string">嘟嘟独立博客:</span> <span class="attr">http://tengj.top/</span></span><br><span class="line"><span class="attr">  crossoverjie:</span> <span class="attr">https://crossoverjie.top/</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line"><span class="comment">#avatar: /images/avatar.gif</span></span><br><span class="line"><span class="comment"># 侧栏头像设置</span></span><br><span class="line"><span class="comment"># 圆形以及旋转效果在本文 4.2 节的代码里</span></span><br><span class="line"><span class="comment"># 点击回到博客首页教程见本文 5.13 节</span></span><br><span class="line"><span class="comment"># 建议放在 hexo-site/source/uploads/ 里（没有自己建）</span></span><br><span class="line"><span class="comment"># 这样可以避免更新 NexT 主题的时候遇到麻烦</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/uploads/logo.jpeg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Table Of Contents in the Sidebar</span></span><br><span class="line"><span class="comment"># 侧栏文章目录设置（前提是 Markdown 书写正确）</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line"><span class="attr">  number:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line"><span class="attr">  wrap:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># http://creativecommons.org/</span></span><br><span class="line"><span class="comment"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment">#creative_commons: by-nc-sa</span></span><br><span class="line"><span class="comment">#creative_commons:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position, available value: left | right (only for Pisces | Gemini).</span></span><br><span class="line"><span class="attr">  position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display, available value (only for Muse | Mist):</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  Totally remove sidebar including sidebar toggle.</span></span><br><span class="line"><span class="attr">  display:</span> <span class="string">post</span></span><br><span class="line">  <span class="comment">#display: always</span></span><br><span class="line">  <span class="comment">#display: hide</span></span><br><span class="line">  <span class="comment">#display: remove</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line"><span class="attr">  offset:</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Back to top in sidebar (only for Pisces | Gemini).</span></span><br><span class="line"><span class="attr">  b2t:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line"><span class="attr">  scrollpercent:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line"><span class="attr">  onmobile:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Post Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span></span><br><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically saving scroll position on each post/page in cookies.</span></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  length:</span> <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post meta display settings</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  created_at:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  updated_at:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="comment"># 显示统计字数和估计阅读时长</span></span><br><span class="line"><span class="comment"># 注意：这个要安装插件，先进入站点文件夹根目录</span></span><br><span class="line"><span class="comment"># 然后：npm install hexo-wordcount --save</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  wordcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  min2read:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  totalcount:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wechat Subscriber</span></span><br><span class="line"><span class="comment">#wechat_subscriber:</span></span><br><span class="line">  <span class="comment">#enabled: true</span></span><br><span class="line">  <span class="comment">#qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg</span></span><br><span class="line">  <span class="comment">#description: ex. subscribe to my blog by scanning my public wechat account</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reward</span></span><br><span class="line"><span class="attr">reward_comment:</span> <span class="string">欢迎一起进行交流！</span></span><br><span class="line"><span class="attr">wechatpay:</span> <span class="string">/images/wechat.jpg</span></span><br><span class="line"><span class="comment">#alipay: /images/alipay.jpg</span></span><br><span class="line"><span class="comment">#bitcoin: /images/bitcoin.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare license on posts</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">3.0</span></span><br><span class="line"><span class="attr">  license_url:</span> <span class="attr">https://creativecommons.org/licenses/by-nc-sa/3.0/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Misc Theme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reduce padding / margin indents on devices with narrow width.</span></span><br><span class="line"><span class="attr">mobile_layout_economy:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Android Chrome header panel color ($black-deep).</span></span><br><span class="line"><span class="attr">android_chrome_color:</span> <span class="string">"#222"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Logo.</span></span><br><span class="line"><span class="comment"># !!Only available for Default Scheme currently.</span></span><br><span class="line"><span class="comment"># Options:</span></span><br><span class="line"><span class="comment">#   enabled: [true/false] - Replace with specific image</span></span><br><span class="line"><span class="comment">#   image: url-of-image   - Images's url</span></span><br><span class="line"><span class="attr">custom_logo:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  image:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line"><span class="comment"># - Find fonts on Google Fonts (https://www.google.com/fonts)</span></span><br><span class="line"><span class="comment"># - All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#     light, light italic, normal, normal italic, bold, bold italic</span></span><br><span class="line"><span class="comment"># - Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># - Introduce in 5.0.1</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># CAUTION! Safari Version 10.1.2 <span class="doctag">bug:</span> https://github.com/iissnan/hexo-theme-next/issues/1844</span></span><br><span class="line"><span class="comment"># To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host. E.g. //fonts.googleapis.com (Default).</span></span><br><span class="line"><span class="attr">  host:</span> <span class="attr">https://fonts.cat.net</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: xx`. Use `px` as unit.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used on &lt;body&gt; element.</span></span><br><span class="line"><span class="attr">  global:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Lato</span></span><br><span class="line"><span class="attr">    size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Headlines (h1, h2, h3, h4, h5, h6).</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line"><span class="attr">  headings:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Roboto</span> <span class="string">Slab</span></span><br><span class="line"><span class="attr">    size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts.</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Logo.</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line"><span class="attr">  logo:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span></span><br><span class="line"><span class="attr">    size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line"><span class="attr">  codes:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Roboto</span> <span class="string">Mono</span></span><br><span class="line"><span class="attr">    size:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Third Party Services Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Han Support docs: https://hanzi.pro/</span></span><br><span class="line"><span class="attr">han:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Swiftype Search API Key</span></span><br><span class="line"><span class="comment">#swiftype_key:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Analytics ID</span></span><br><span class="line"><span class="comment">#baidu_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Duoshuo ShortName</span></span><br><span class="line"><span class="comment">#duoshuo_shortname:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus</span></span><br><span class="line"><span class="attr">disqus:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  shortname:</span></span><br><span class="line"><span class="attr">  count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hypercomments</span></span><br><span class="line"><span class="comment">#hypercomments_id:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># changyan</span></span><br><span class="line"><span class="attr">changyan:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  appid:</span></span><br><span class="line"><span class="attr">  appkey:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="comment">#  app_id: oilMyKSMaPtFHPbgcbiCfJL6-gzGzoHsz</span></span><br><span class="line"><span class="comment">#  app_key: oUBvV1jEzR3mJ3RvgWoHex8G</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  appid:</span> <span class="string">oilMyKSMaPtFHPbgcbiCfJL6-gzGzoHsz</span>   </span><br><span class="line"><span class="attr">  appkey:</span> <span class="string">oUBvV1jEzR3mJ3RvgWoHex8G</span>  </span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">true</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">true</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Support for youyan comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from http://www.uyan.cc</span></span><br><span class="line"><span class="comment">#youyan_uid: your uid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Support for LiveRe comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="comment">#livere_uid: your uid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gitment</span></span><br><span class="line"><span class="comment"># Introduction: https://imsun.net/posts/gitment-introduction/</span></span><br><span class="line"><span class="comment"># You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;</span></span><br><span class="line"><span class="attr">gitment:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  mint:</span> <span class="literal">true</span> <span class="comment"># RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span></span><br><span class="line"><span class="attr">  count:</span> <span class="literal">true</span> <span class="comment"># Show comments count in post meta area</span></span><br><span class="line"><span class="attr">  lazy:</span> <span class="literal">false</span> <span class="comment"># Comments lazy loading with a button</span></span><br><span class="line"><span class="attr">  cleanly:</span> <span class="literal">false</span> <span class="comment"># Hide 'Powered by ...' on footer, and more</span></span><br><span class="line"><span class="attr">  language:</span> <span class="comment"># Force language, or auto switch by theme</span></span><br><span class="line"><span class="attr">  github_user:</span> <span class="comment"># MUST HAVE, Your Github ID</span></span><br><span class="line"><span class="attr">  github_repo:</span> <span class="comment"># MUST HAVE, The repo you use to store Gitment comments</span></span><br><span class="line"><span class="attr">  client_id:</span> <span class="comment"># MUST HAVE, Github client id for the Gitment</span></span><br><span class="line"><span class="attr">  client_secret:</span> <span class="comment"># EITHER this or proxy_gateway, Github access secret token for the Gitment</span></span><br><span class="line"><span class="attr">  proxy_gateway:</span> <span class="comment"># Address of api proxy, See: https://github.com/aimingoo/intersect</span></span><br><span class="line"><span class="attr">  redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint enabled</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Share</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    button | slide</span></span><br><span class="line"><span class="comment"># Warning: Baidu Share does not support https.</span></span><br><span class="line"><span class="comment">#baidushare:</span></span><br><span class="line"><span class="comment">##  type: button</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line"><span class="comment"># This plugin is more useful in China, make sure you known how to use it.</span></span><br><span class="line"><span class="comment"># And you can find the use guide at official webiste: http://www.jiathis.com/.</span></span><br><span class="line"><span class="comment"># Warning: JiaThis does not support https.</span></span><br><span class="line"><span class="comment">#jiathis:</span></span><br><span class="line">  <span class="comment">##uid: Get this uid from http://www.jiathis.com/</span></span><br><span class="line"><span class="comment">#add_this_id:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line"><span class="comment">#duoshuo_share: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NeedMoreShare2</span></span><br><span class="line"><span class="comment"># This plugin is a pure javascript sharing lib which is useful in China.</span></span><br><span class="line"><span class="comment"># See: https://github.com/revir/need-more-share2</span></span><br><span class="line"><span class="comment"># Also see: https://github.com/DzmVasileusky/needShareButton</span></span><br><span class="line"><span class="comment"># iconStyle: default | box</span></span><br><span class="line"><span class="comment"># boxForm: horizontal | vertical</span></span><br><span class="line"><span class="comment"># position: top / middle / bottom + Left / Center / Right</span></span><br><span class="line"><span class="comment"># networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,</span></span><br><span class="line"><span class="comment">#           Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,</span></span><br><span class="line"><span class="comment">#           Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,</span></span><br><span class="line"><span class="comment">#           Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailru</span></span><br><span class="line"><span class="attr">needmoreshare2:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  postbottom:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    options:</span></span><br><span class="line"><span class="attr">      iconStyle:</span> <span class="string">box</span></span><br><span class="line"><span class="attr">      boxForm:</span> <span class="string">horizontal</span></span><br><span class="line"><span class="attr">      position:</span> <span class="string">bottomCenter</span></span><br><span class="line"><span class="attr">      networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line"><span class="attr">  float:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    options:</span></span><br><span class="line"><span class="attr">      iconStyle:</span> <span class="string">box</span></span><br><span class="line"><span class="attr">      boxForm:</span> <span class="string">horizontal</span></span><br><span class="line"><span class="attr">      position:</span> <span class="string">middleRight</span></span><br><span class="line"><span class="attr">      networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters/</span></span><br><span class="line"><span class="comment">#google_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="comment">#google_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bing Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.bing.com/webmaster/</span></span><br><span class="line"><span class="comment">#bing_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yandex Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://webmaster.yandex.ru/</span></span><br><span class="line"><span class="comment">#yandex_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CNZZ count</span></span><br><span class="line"><span class="comment">#cnzz_siteid:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Insights</span></span><br><span class="line"><span class="comment"># See https://azure.microsoft.com/en-us/services/application-insights/</span></span><br><span class="line"><span class="comment"># application_insights:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make duoshuo show UA</span></span><br><span class="line"><span class="comment"># user_id must NOT be null when admin_enable is true!</span></span><br><span class="line"><span class="comment"># you can visit http://dev.duoshuo.com get duoshuo user id.</span></span><br><span class="line"><span class="attr">duoshuo_info:</span></span><br><span class="line"><span class="attr">  ua_enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  admin_enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  user_id:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">#admin_nickname: Author</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post widgets &amp; FB/VK comments settings.</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Facebook SDK Support.</span></span><br><span class="line"><span class="comment"># https://github.com/iissnan/hexo-theme-next/pull/410</span></span><br><span class="line"><span class="attr">facebook_sdk:</span></span><br><span class="line"><span class="attr">  enable:</span>       <span class="literal">false</span></span><br><span class="line"><span class="attr">  app_id:</span>       <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line"><span class="attr">  fb_admin:</span>     <span class="comment">#&lt;user_id&gt;</span></span><br><span class="line"><span class="attr">  like_button:</span>  <span class="comment">#true</span></span><br><span class="line"><span class="attr">  webmaster:</span>    <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Facebook comments plugin</span></span><br><span class="line"><span class="comment"># This plugin depends on Facebook SDK.</span></span><br><span class="line"><span class="comment"># If facebook_sdk.enable is false, Facebook comments plugin is unavailable.</span></span><br><span class="line"><span class="attr">facebook_comments_plugin:</span></span><br><span class="line"><span class="attr">  enable:</span>       <span class="literal">false</span></span><br><span class="line"><span class="attr">  num_of_posts:</span> <span class="number">10</span>    <span class="comment"># min posts num is 1</span></span><br><span class="line"><span class="attr">  width:</span>        <span class="number">100</span><span class="string">%</span>  <span class="comment"># default width is 550px</span></span><br><span class="line"><span class="attr">  scheme:</span>       <span class="string">light</span> <span class="comment"># default scheme is light (light or dark)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VKontakte API Support.</span></span><br><span class="line"><span class="comment"># To get your AppID visit https://vk.com/editapp?act=create</span></span><br><span class="line"><span class="attr">vkontakte_api:</span></span><br><span class="line"><span class="attr">  enable:</span>       <span class="literal">false</span></span><br><span class="line"><span class="attr">  app_id:</span>       <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line"><span class="attr">  like:</span>         <span class="literal">true</span></span><br><span class="line"><span class="attr">  comments:</span>     <span class="literal">true</span></span><br><span class="line"><span class="attr">  num_of_posts:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  id:</span>     <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line"><span class="attr">  color:</span>  <span class="string">fc6423</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line"><span class="comment"># 可以显示每篇文章的阅读量</span></span><br><span class="line"><span class="comment"># 然后可以通过阅读量建立 TopX 页面，教程链接：</span></span><br><span class="line"><span class="comment"># https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.html</span></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  app_id:</span> <span class="string">oilMyKSMaPtFHPbgcbiCfJL6-gzGzoHsz</span></span><br><span class="line"><span class="attr">  app_key:</span> <span class="string">oUBvV1jEzR3mJ3RvgWoHex8G</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another tool to show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># visit https://console.firebase.google.com/u/0/ to get apiKey and projectId</span></span><br><span class="line"><span class="comment"># visit https://firebase.google.com/docs/firestore/ to get more information about firestore</span></span><br><span class="line"><span class="attr">firestore:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  collection:</span> <span class="string">articles</span> <span class="comment">#required, a string collection name to access firestore database</span></span><br><span class="line"><span class="attr">  apiKey:</span> <span class="comment">#required</span></span><br><span class="line"><span class="attr">  projectId:</span> <span class="comment">#required</span></span><br><span class="line"><span class="attr">  bluebird:</span> <span class="literal">false</span> <span class="comment">#enable this if you want to include bluebird 3.5.1(core version) Promise polyfill</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="comment"># 不蒜子统计，用于在页脚显示总访客数和总浏览量，将 false 改为 true 就能直接使用</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line"><span class="attr">  site_uv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="attr">  site_uv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line"><span class="attr">  site_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="attr">  site_pv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line"><span class="attr">  page_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="attr">  page_pv_footer:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tencent analytics ID</span></span><br><span class="line"><span class="comment"># tencent_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tencent MTA ID</span></span><br><span class="line"><span class="comment"># tencent_mta:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span></span><br><span class="line"><span class="attr">baidu_push:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Calendar</span></span><br><span class="line"><span class="comment"># Share your recent schedule to others via calendar page</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># API Documentation:</span></span><br><span class="line"><span class="comment"># https://developers.google.com/google-apps/calendar/v3/reference/events/list</span></span><br><span class="line"><span class="attr">calendar:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  calendar_id:</span> <span class="string">&lt;required&gt;</span></span><br><span class="line"><span class="attr">  api_key:</span> <span class="string">&lt;required&gt;</span></span><br><span class="line"><span class="attr">  orderBy:</span> <span class="string">startTime</span></span><br><span class="line"><span class="attr">  offsetMax:</span> <span class="number">24</span></span><br><span class="line"><span class="attr">  offsetMin:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  timeZone:</span></span><br><span class="line"><span class="attr">  showDeleted:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  singleEvents:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  maxResults:</span> <span class="number">250</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hits:</span></span><br><span class="line"><span class="attr">    per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line"><span class="attr">    hits_empty:</span> <span class="string">"We didn't find any results for the search: $&#123;query&#125;"</span></span><br><span class="line"><span class="attr">    hits_stats:</span> <span class="string">"$&#123;hits&#125; results found in $&#123;time&#125; ms"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Tags Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># External URL with BASE64 encrypt &amp; decrypt.</span></span><br><span class="line"><span class="comment"># Usage: &#123;% exturl text url "title" %&#125;</span></span><br><span class="line"><span class="comment"># Alias: &#123;% extlink text url "title" %&#125;</span></span><br><span class="line"><span class="attr">exturl:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note tag (bs-callout).</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line"><span class="attr">  style:</span> <span class="string">flat</span></span><br><span class="line"><span class="attr">  icons:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="attr">  light_bg_offset:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Label tag.</span></span><br><span class="line"><span class="attr">label:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tabs tag.</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  transition:</span></span><br><span class="line"><span class="attr">    tabs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    labels:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  border_radius:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#! DO NOT EDIT THE FOLLOWING SETTINGS</span></span><br><span class="line"><span class="comment">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use velocity to animate everything.</span></span><br><span class="line"><span class="attr">motion:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  async:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  transition:</span></span><br><span class="line">    <span class="comment"># Transition variants:</span></span><br><span class="line">    <span class="comment"># fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span></span><br><span class="line">    <span class="comment"># swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span></span><br><span class="line">    <span class="comment"># bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span></span><br><span class="line">    <span class="comment"># slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span></span><br><span class="line">    <span class="comment"># slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span></span><br><span class="line">    <span class="comment"># perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span></span><br><span class="line"><span class="attr">    post_block:</span> <span class="string">fadeIn</span></span><br><span class="line"><span class="attr">    post_header:</span> <span class="string">fadeIn</span></span><br><span class="line"><span class="attr">    post_body:</span> <span class="string">fadeIn</span></span><br><span class="line"><span class="attr">    coll_header:</span> <span class="string">slideLeftIn</span></span><br><span class="line">    <span class="comment"># Only for Pisces | Gemini.</span></span><br><span class="line"><span class="attr">    sidebar:</span> <span class="string">slideUpIn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fancybox</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="comment"># 页面顶部加载条</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-flash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Only fit scheme Pisces</span></span><br><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="comment"># size: The width of the ribbon.</span></span><br><span class="line"><span class="comment"># alpha: The transparency of the ribbon.</span></span><br><span class="line"><span class="comment"># zIndex: The display level of the ribbon.</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  size:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  alpha:</span> <span class="number">0.6</span></span><br><span class="line"><span class="attr">  zIndex:</span> <span class="bullet">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Script Vendors.</span></span><br><span class="line"><span class="comment"># Set a CDN address for the vendor you want to customize.</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment">#    jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js</span></span><br><span class="line"><span class="comment"># Be aware that you should use the same version as internal ones to avoid potential problems.</span></span><br><span class="line"><span class="comment"># Please use the https protocol of CDN files when you enable https on your site.</span></span><br><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="comment"># Internal path prefix. Please do not edit it.</span></span><br><span class="line"><span class="attr">  _internal:</span> <span class="string">lib</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 2.1.3</span></span><br><span class="line"><span class="attr">  jquery:</span> <span class="attr">https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 2.1.5</span></span><br><span class="line">  <span class="comment"># See: http://fancyapps.com/fancybox/</span></span><br><span class="line">  <span class="comment"># 自定义 fancybox（暂时）</span></span><br><span class="line"><span class="attr">  fancybox:</span> <span class="attr">https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js</span></span><br><span class="line"><span class="attr">  fancybox_css:</span> <span class="attr">https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.6</span></span><br><span class="line">  <span class="comment"># See: https://github.com/ftlabs/fastclick</span></span><br><span class="line"><span class="attr">  fastclick:</span> <span class="attr">https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.9.7</span></span><br><span class="line">  <span class="comment"># See: https://github.com/tuupola/jquery_lazyload</span></span><br><span class="line"><span class="attr">  lazyload:</span> <span class="attr">https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.2.1</span></span><br><span class="line">  <span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">  velocity:</span> <span class="attr">https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.2.1</span></span><br><span class="line">  <span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">  velocity_ui:</span> <span class="attr">https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 0.7.9</span></span><br><span class="line">  <span class="comment"># See: https://faisalman.github.io/ua-parser-js/</span></span><br><span class="line"><span class="attr">  ua_parser:</span> <span class="attr">https://cdnjs.cloudflare.com/ajax/libs/UAParser.js/0.7.9/ua-parser.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 4.6.2</span></span><br><span class="line">  <span class="comment"># See: http://fontawesome.io/</span></span><br><span class="line"><span class="attr">  fontawesome:</span> <span class="attr">https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.2</span></span><br><span class="line">  <span class="comment"># See: https://github.com/HubSpot/pace</span></span><br><span class="line">  <span class="comment"># Or use direct links below:</span></span><br><span class="line"><span class="attr">  pace:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="attr">  pace_css:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">  canvas_nest:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three</span></span><br><span class="line"><span class="attr">  three:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three_waves</span></span><br><span class="line">  <span class="comment"># https://github.com/jjandxa/three_waves</span></span><br><span class="line"><span class="attr">  three_waves:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three_waves</span></span><br><span class="line">  <span class="comment"># https://github.com/jjandxa/canvas_lines</span></span><br><span class="line"><span class="attr">  canvas_lines:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three_waves</span></span><br><span class="line">  <span class="comment"># https://github.com/jjandxa/canvas_sphere</span></span><br><span class="line"><span class="attr">  canvas_sphere:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># https://github.com/zproo/canvas-ribbon</span></span><br><span class="line"><span class="attr">  canvas_ribbon:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 3.3.0</span></span><br><span class="line">  <span class="comment"># https://github.com/ethantw/Han</span></span><br><span class="line"><span class="attr">  han:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># needMoreShare2</span></span><br><span class="line">  <span class="comment"># https://github.com/revir/need-more-share2</span></span><br><span class="line"><span class="attr">  needMoreShare2:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assets</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"><span class="attr">images:</span> <span class="string">images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Theme version</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">5.1</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><hr><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢<a href="http://tengj.top/" target="_blank" rel="noopener">嘟嘟独立博客</a>。<br>感谢<a href="https://reuixiy.github.io/" target="_blank" rel="noopener">reuixiy</a>,这篇<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.htm" target="_blank" rel="noopener">文章</a>记录的十分详细。</p><hr>]]></content>
    
    <summary type="html">
    
      搭建一个属于自己的博客
    
    </summary>
    
      <category term="hexo" scheme="https://9191rs.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://9191rs.me/tags/hexo/"/>
    
      <category term="Next" scheme="https://9191rs.me/tags/Next/"/>
    
      <category term="配置" scheme="https://9191rs.me/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
