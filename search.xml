<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot&Netty实现仿微信网页版]]></title>
    <url>%2Fposts%2F15239%2F</url>
    <content type="text"><![CDATA[前言Netty是一个基于基于Java NIO的网络应用框架和client-server框架，提供了对TCP、UDP和文件传输的支持。Netty不仅能实现消息的转发，而且可以主动推送消息给客户端。在学习过程中，突然想到可以用Netty作为核心，用WebSocket为应用层通信协议做一个互联网聊天系统。 整体说明本次开发采用了前后端分离的想法，前端通过向后端发送AjAx请求获取相应的信息。在部署到服务器的时候，前端页面放到了Tomcat之下实现访问，后端的工程通过Maven打成了jar包，利用SpringBoot提供的内置Tomcat运行。 SpringBoot和MyBatis构成了后端的主要架构。主要用来处理用户的相关请求，比如登录、获取好友列表、获取聊天记录等等。而SprngBoot整合的Netty WebSockt服务主要处理用户消息通信的WebSocket类型请求，用户通过浏览器登录后，根据用户id建立一条WebSocket连接并保存在后端以便进行实时通信。当一个用户向另一用户发起通信，服务器会根据消息内容中的对话方用户id，找到保存的WebSocket连接，通过该连接发送消息，对方就能够收到即时收到消息。当用户注销或退出时，释放WebSocket连接。 同时利用用户和服务器之间的 WebSockt连接实现了心跳检测功能，当用户登录后，前端会定时向后端发送心跳请求，如果在约定的时间没有收到，就释放该WebSockt连接。 整个系统采用了Idworker为数据库中的每一条记录生成唯一的记录。 项目结构系统采用B/S结构，主要事务逻辑在服务器端实现。 项目后端结构： 项目前端结构： 数据库结构： 后端功能模块登录注册模块用户在登录的时，先到Users表中查询用户是否存在，如果不存在或者密码错误，返回相应的提示信息，如果正确，则返回用户的完整信息。用户在注册的时候，也先到Users表中查询用户是否存在，如果已经存在就不能继续创建了，返回一个提示信息，如果不存在就在Users表中插入一条记录，并且返回到该用户的初始信息。 查找并添加好友根据用户的用户名进行查找，满足用户存在，不是自己，不是自己的好友三个条件，则返回要查找的用户，否则只能返回相迎的提示信息。在得到要添加的好友信息，进行添加时，需要在friends_request表中添加相应的记录，一个添加请求只会在保存一次。在收到添加好友请求后，用户可以选择接受或者拒绝，如果拒绝，删除friends_request表中相应的记录。如果接受，先删除friends_request表中添加相应的记录，并且在my_friends表中添加相应的记录。要获取用户的所有好友，则需要先在my_friends表中根据用户的ID查找好友的ID，然后去Users表中查找并返回所有的好友信息。 修改呢称和修改用户头像修改呢称和修改用户头像的思路基本一致，都是将根据用户的ID在Users表中将相应的信息进行更改即可。用户上传的头像保存在用FastDFS搭建的图片服务器上，它在用户上传完图像之后都会返回一个地址，只要将该地址保存在数据库中即可。 Netty WebSockt服务模块详细的Netty创建WebSockt服务的过程可以参考这篇文章。对于接收到的信息分为5种： 登录用户登录的后，前端初始化WebSockt服务，并向后端送消息，后端接收到以后，将用户ID和channnel信息保存到一个HashMap中，且在保存之前要进行判断HashMap是否已经保存了一个对应的信息，如果有的话，则应该通过向该channel发送一个ISLOGIN类型的信息，强制让旧的用户下线。 聊天类型的消息先将消息保存到chat_msg表中，同时标记消息未签收。如果接收者在线，同时将消息发给接收者。 消息签收对消息进行签收的目的是确定消息已经到达了对方的电脑。没有签收的消息，会在用户下次登录的过程中，全部被改用户所接受。 心跳包Netty提供了空闲状态事件，如果在一定时间内收不到心跳包，就可以认为用户已经下线，应该移除相应的WebSockt连接。 前端功能模块前端主要分为两个模块：登录和注册模块和聊天模块。 登录和注册模块登录和注册模块主要是进行用户信息管理，登录或者注册成功后，会将用户的信息保存到本地。 聊天模块聊天模块又可以分为三个小的模块：聊天快照、联系人列表和聊天窗口。 聊天窗口根据缓存好的好友信息，唯一的生成每个好友的聊天窗口，并且动态的嵌入到网页中，根据用户的选择进行显示。在每次进行窗口显示的过程中，又会读取缓存的聊天录，并且动态的显示在聊天窗口之中。缓存的好友信息会随着心跳包定时进行更新，或者在通过用户好友请求后进行更新。缓存的好友消息会在接收到消息之后就进行更新。 联系人列表联系人列表分为好友请求和好友，都是通过缓存好的信息进行动态加载和显示。缓存的信息是随着心跳包在不断定时更新。 聊天快照聊天快照会在用户收到消息或者发送消息的时候进行动态更新。 实现效果及演示实现效果现在通过把Netty和SpringBoot整合，实现的功能有以下几点： 用户的登录和注册 修改登录用户的呢称，头像 添加好友 一对一聊天 心跳检测，定时刷新用户信息 同一个用户只能在一处登录 待完善的功能： 前端页面的美化现在的界面主要是参考素材火这个界面实现的，为了实现功能写的比较烂（主要是拼凑，无奈）。 实现表情包，文件的发送 完善搜索功能 实现群聊 登录界面： 聊天界面： 演示git源码地址: LLLRS GitHub 在线演示地址账户1: mian 密码： main账户2: test1 密码： test1账户3: test2 密码： test2 注意：由于前端会把用户的信息都会缓存到本地浏览器，如果在同一台电脑上测试的话，需要用不同的浏览器登录不同的用户。 参考链接 WebSocket 是什么原理？为什么可以实现持久连接？ Netty应用 SpringBoot整合Netty]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第72题 Edit Distance]]></title>
    <url>%2Fposts%2F43664%2F</url>
    <content type="text"><![CDATA[题目要求求两个字符串的编辑距离，将一个字符串变成另外一个字符串所用的最少操作数，每次只能增加、删除或者替换一个字符。 两个字符串的编辑距离越小，说明两个字符串越相似！ DP解法dp[i][j]：它是指word1[0…i]和word2[0…j]的编辑距离 如果word1[i]和word2[j]相等，则dp[i][j] = dp[i-1][j-1] 如果word1[i]和word2[j]不相等相等，则要分情况讨论 添加： 也就是在word1[i]后加一个字符x使得word1[0…i] + x和word2[0…j]相等，则dp[i][j] = dp[i][j-1] + 1 删除：也就是在word1[i]后删除第i处字符x使得word1[0…i-1] 和word2[0…j]相等，则dp[i][j] = dp[i-1][j] + 1 修改：也就是在word1[i]后修改第i处的字符使得word1[0…i] 和word2[0…j]相等，则dp[i][j] = dp[i-1][j-1] + 1 参考代码123456789101112131415161718192021222324public int minDistance(String w1, String w2) &#123; int r = w1.length(); int c = w2.length(); int[][] dp = new int[r+1][c+1]; for(int i=0;i&lt;=c;i++) dp[0][i] = i; //dp[i][0]就是，w1长度为i，w2为空时，w1需要删除i个字符才能转换成空 for(int i=1;i&lt;=r;i++)&#123; dp[i][0] = i; //dp[0][j]就是w1为空，w2长度为j的情况，w1需要添加j个字符转换成w2 for(int j=1;j&lt;=c;j++)&#123; if(w1.charAt(i-1)==w2.charAt(j-1)) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j], dp[i][j-1])) + 1; &#125; &#125; return dp[r][c]; &#125; 基于上述代码的一种改进1234567891011121314151617181920212223242526public int minDistance(String w1, String w2) &#123; int r = w1.length(); int c = w2.length(); int[] dp = new int[c+1]; for(int i=0;i&lt;=c;i++) dp[i] = i; for(int i=1;i&lt;=r;i++)&#123; int[] temp = new int[c+1]; temp[0] = i; for(int j=1;j&lt;=c;j++)&#123; if(w1.charAt(i-1)==w2.charAt(j-1)) temp[j] = dp[j-1]; else temp[j] = Math.min(temp[j-1],Math.min(dp[j-1], dp[j])) + 1; // temp[j-1] 添加 dp[j-1] 修改 dp[j] 删除 &#125; dp = temp; &#125; return dp[c]; &#125; 参考链接 EditDistance,求两个字符串最小编辑距离，动态规划]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第10题 Regular Expression Matching]]></title>
    <url>%2Fposts%2F36828%2F</url>
    <content type="text"><![CDATA[题目要求 回溯法思路回溯法是一种暴力解法，把“*”的所有可能性都测试一遍看是否有满足的。从后往前匹配,用两个指针 si, pi来表明当前s和p的字符。 如果pi对应的字符是”*”，根据s[i] 和 p[j-1]是否相同，分两种情况： 如果相同，则先尝试匹配掉s的这个字符，继续尝试匹配 不管相同不相同，不匹配s的这个字符，继续尝试匹配 如果pi对应的字符不是是”*”，直接看s[i]和p[j]是否相等 边界条件 如果si和pi都小于0，说明匹配。 如果pi小于0，si大于零，说明不能匹配 参考代码123456789101112131415161718192021222324252627public boolean isMatch(String s, String p) &#123; if(s==null || p == null) return false; return isMatch(s.toCharArray(),s.length() - 1,p.toCharArray(),p.length() - 1);&#125;private boolean isMatch(char[] s,int si,char[] p,int pi)&#123; if(si &lt; 0 &amp;&amp; pi &lt; 0) return true; if(pi &lt; 0) return false; if(p[pi] == '*')&#123; if(si &gt;= 0 &amp;&amp;( p[pi - 1] == s[si] || p[pi - 1] == '.' ) &amp;&amp; isMatch(s,si-1,p,pi)) return true; return isMatch(s,si,p,pi-2); &#125; if(si &gt;= 0 &amp;&amp; (p[pi] == s[si] || p[pi] == '.' )) return isMatch(s,si-1,p,pi-1); return false;&#125; DP解法思路dp[i][j]的含义是s[0-i] 与 s[0-j]是否匹配 若s[i] == p[j] 或者p[j] == ‘ . ‘,则dp[i][j] = dp[i-1][j-1] 若p[j] == ‘ * ‘,则需要分情况讨论 s[i] != p[j-1]， 则 dp[i][j] = dp[i][j-2] –&gt;忽略掉 p[j-1] 和* s[i] == p[j-1] 或者p[j] == ‘ . ‘ dp[i][j] = dp[i-1][j] –&gt; p[j-1] 和* 匹配多次 dp[i][j] = dp[i][j-1] –&gt; p[j-1] 和*匹配一次 dp[i][j] = dp[i][j-2] –&gt; 忽略掉 p[j-1] 和* 参考代码123456789101112131415161718192021222324252627public boolean isMatch(String st, String pt) &#123; if(st==null || pt == null) return false; int m = st.length(); int n = pt.length(); char[] s = st.toCharArray(); char[] p = pt.toCharArray(); boolean[][] dp = new boolean[m+1][n+1]; //dp[i][j]的含义是s[0-i] 与 s[0-j]是否匹配 dp[0][0] = true; ////初始化第0行,除了[0][0]全为false //初始化第0列，只有X*能匹配空串，如果有*，它的真值一定和p[0][j-2]的相同（略过它之前的符号） for (int j = 1; j &lt;= n; j++) dp[0][j] = j &gt; 1 &amp;&amp; '*' == p[j - 1] &amp;&amp; dp[0][j - 2]; for(int i = 1;i &lt;= m;i++)&#123; for(int j = 1;j &lt;= n;j++)&#123; if(p[j-1] == '*') dp[i][j] = dp[i][j - 2] || (s[i - 1] == p[j - 2] || p[j - 2] == '.') &amp;&amp; dp[i - 1][j]; else dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == '.') &amp;&amp; dp[i - 1][j - 1]; &#125; &#125; return dp[m][n];&#125; 参考链接 《LeetBook》leetcode题解(10): Regular Expression Matching——DP解决正则匹配]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第5题 Longest Palindromic Substring]]></title>
    <url>%2Fposts%2F39014%2F</url>
    <content type="text"><![CDATA[题目要求给定一个字符串，求它的一个最长回文子串。 暴力解法思路 找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。 暴力解法的时间复杂度是O(n^3)。 可以从最长的字串开始枚举，如果回文，就停止 Java代码1234567891011121314151617181920212223242526class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()&lt;=1) return s; for(int i = s.length();i&gt;0;i--)&#123; for(int j=0;j&lt;=s.length()-i;j++)&#123; String st = s.substring(j,i+j); if(isPalindrome(st)) return st; &#125; &#125; return ""; &#125; private boolean isPalindrome(String sub)&#123; for (int k = 0; k &lt; sub.length() / 2; k++) &#123; if (sub.charAt(k) != sub.charAt(sub.length() - k - 1)) return false; &#125; return true; &#125;&#125; 中心扩展法思路 遍历字符串中的每一个字符，以它为中心开始向左右两边拓展，直到左右两边的字符不同，或者达到边界。 此算法的时间复杂度是O(n^2) Java代码12345678910111213141516171819202122232425262728293031class Solution &#123; int st = 0,maxLen = 0; public String longestPalindrome(String s) &#123; int len = s.length(); if(len&lt;=1) return s; for(int i=0;i&lt;len-1;i++)&#123; if(s.charAt(i)==s.charAt(i+1)) palindromeAux(s,i,i+1); palindromeAux(s,i,i); &#125; return s.substring(st,st+maxLen); &#125; public void palindromeAux(String s,int l,int r) &#123; int len = s.length(); while(l&gt;=0&amp;&amp;r&lt;len&amp;&amp;s.charAt(l)==s.charAt(r))&#123; l--; r++; &#125; if (maxLen &lt; r - l- 1) &#123; st = l + 1; maxLen = r - l - 1; &#125; &#125; &#125; Manacher 算法具体介绍见这篇文章 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public String longestPalindrome(String s) &#123; //字符串预处理 List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; list.add('#'); list.add(s.charAt(i)); &#125; list.add('#'); int MaxRight = 0; //现在访问到的最右边的字符 int pos = 0; //maxRight位置对应的轴位置 int MaxLen = 0; int n = list.size(); int[] RL = new int[n]; for(int i=0;i&lt;n;i++)&#123; if(i&lt;MaxRight) RL[i] = Math.min(RL[2*pos-i], MaxRight-i); else RL[i] = 1; //尝试扩展，注意处理边界 while (i-RL[i]&gt;=0 &amp;&amp;i+RL[i]&lt;n &amp;&amp; list.get(i-RL[i]) == list.get(i+RL[i])) RL[i] +=1; //更新MaxRight,pos if (RL[i]+i-1&gt;MaxRight)&#123; MaxRight = RL[i]+i-1; pos = i; &#125; //更新最长回文串的长度 MaxLen=Math.max(MaxLen, RL[i]); &#125; for(int i=0;i&lt;n;i++)&#123; if(RL[i] != MaxLen) continue; pos = i; break; &#125; String res = ""; if(list.get(pos)!='#') res += list.get(pos); for(int i=pos+1;i&lt;pos + MaxLen ;i++)&#123; char ch = list.get(i); if(ch=='#') continue; res = ch + res + ch; &#125; return res; &#125;&#125; DP解法思路 pal[i,j]（表示以i开始以j结束的子串）是否为回文字符串。 算法复杂度是O(N^2) 状态方程和转移方程：pal[i, j] = pal[i+1, j-1]， if ( s[i]==s[j] ) pal[i, j] = false，if ( s[i] != s[j] ) Java代码12345678910111213141516171819202122232425262728293031class Solution &#123; public String longestPalindrome(String s) &#123; if(s==null||s.length()==0) return ""; int n = s.length(); boolean[][] pal = new boolean[n][n]; //pal[i][j] 表示s[i...j]是否为回文串 pal[i][j] = false 表示不是回文串 int maxLen = 0; int l = 0,r = 0; for(int i=0;i&lt;n;i++)&#123; int j = i; while(j&gt;=0)&#123; if(s.charAt(i)==s.charAt(j)&amp;&amp;(i-j&lt;2||pal[j+1][i-1]))&#123; pal[j][i] = true; if (maxLen &lt; i-j+1)&#123; maxLen = i-j+1; r = i; l = j; &#125; &#125; j--; &#125; &#125; return s.substring(l,r+1); &#125;&#125; 参考链接 最长回文子串——Manacher 算法 动态规划：最长回文字符串 最长回文子串（Longest Palindromic Substring）——三种时间复杂度的解法]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第3题 Longest Substring Without Repeating Characters]]></title>
    <url>%2Fposts%2F53116%2F</url>
    <content type="text"><![CDATA[题目要求求一个字符串中有不重复字母的字符串个数。 解题思路采用双指针的思想，并且用一个HashMap保存每一个字符出现的位置。移动右指针扫描字符串并且更新映射关系。如果在HashMap中已经存在这个字符，就将左字符移动到最后找到的同一字符的右边。 Java代码123456789101112131415161718public int lengthOfLongestSubstring(String s) &#123; int l =0,r = 0; int res = 0; HashMap&lt;Character,Integer&gt; hm = new HashMap&lt;&gt;(); while(r&lt;s.length())&#123; char ch = s.charAt(r); if(hm.containsKey(ch)) l = Math.max(l,hm.get(ch) + 1); hm.put(ch,r); res = Math.max(res,r-l+1); r++; &#125; return res;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不用四则运算符号做加减乘除]]></title>
    <url>%2Fposts%2F30160%2F</url>
    <content type="text"><![CDATA[前言加减乘除是在写程序过程中，经常会遇到的。如果不能使用四则运算符号（+ - / * ）做运算，那么我们只能考虑用位运算。且由于减法和乘法一般可用加法推出，所以现在只介绍用位运算实现加法和除法。 加法思路首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 Java代码实现123456789101112public int Add(int num1,int num2) &#123; int sum,carry; do&#123; sum = num1 ^ num2; carry = (num1&amp;num2)&lt;&lt;1; num1 = sum; num2 = carry; &#125;while(num2!=0); return num1;&#125; 除法思路用将15除以3举例，先将3向左移动1位（相当于乘以2），得到新除数6。15大于6，再次使得除数左移一位变为12。15大于12，再次使得除数左移一位变为24。15小于24，则用（15-12）重新开始这一个过程。在求解过程中用一个数记录循环的次数就可以得到解。 Java代码实现1234567891011121314151617181920212223public int divide(int dividend, int divisor) &#123; if(divisor==0 || (dividend == Integer.MIN_VALUE&amp;&amp; divisor==-1)) return Integer.MAX_VALUE; int sign = (dividend &lt; 0) ^ (divisor &lt; 0) ? -1 : 1; long dvd = Math.abs((long) dividend); long dvs = Math.abs((long) divisor); int res = 0; while(dvd &gt;= dvs)&#123; long temp = dvs, mul = 1; while(dvd &gt;= (temp&lt;&lt; 1))&#123; temp &lt;&lt;= 1; mul &lt;&lt;= 1; //翻倍 &#125; dvd -= temp; res += mul; &#125; return sign == 1 ? res : -res; &#125; Multiply Strings思路先按照元素规则计算出每一位的和，最后在考虑进位问题。 Java代码1234567891011121314151617181920212223242526272829303132333435363738public String multiply(String num1, String num2) &#123; if(num1==null||num2==null) return ""; if(num1.equals("")||num2.equals("")) return ""; if(num1.equals("0")||num2.equals("0")) return "0"; int len1 = num1.length(); int len2 = num2.length(); if(len1==0||len2==0) return "0"; if(len1&gt;len2) //确num1是较短那个短 return multiply(num2,num1); int[] res = new int[len1 + len2 - 1]; for(int i=0;i&lt;len1;i++)&#123; int t1 = num1.charAt(i) - '0'; for(int j=0;j&lt;len2;j++)&#123; int t2 = num2.charAt(j) - '0'; res[i+j] = res[i+j] + t1 * t2; &#125; &#125; StringBuilder sb = new StringBuilder(); int du = 0; for(int i=res.length-1;i&gt;=0;i--)&#123; res[i] = res[i] + du; du = res[i] / 10; res[i] = res[i] % 10; &#125; if(du!=0) sb.append(du); for(int i=0;i&lt;res.length;i++) sb.append(res[i]); return sb.toString();&#125; 参考链接 leetcode – Divide Two Integers 牛客网 – 不用加减乘除做加法 leetcode – Multiply Strings]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第60题 Permutation Sequence]]></title>
    <url>%2Fposts%2F56083%2F</url>
    <content type="text"><![CDATA[题目要求将1-n按照从小到大的顺序进行全排列，求解第k个排列结果。如n=3,它的全排列顺序如下： 解题思路首先想到的肯定是求出整个全排列，然后返回第K个即可，这种做法当然可行，但是对于本题来书并不是最优解。leetcode上有一种十分巧妙的解法)，它的思路如下(以n=4,k=16举例)： 当n = 4时，全排列序列可以看作以下几种情况的组合：&#8195;&#8195; 1 + (permutations of 2, 3, 4)&#8195;&#8195;2 + (permutations of 1, 3, 4)&#8195;&#8195;3 + (permutations of 1, 2, 4)&#8195;&#8195;4 + (permutations of 1, 2, 3) 对于每一个子排列来说，有6种可能。也就是说，在这个特殊的情况下总共会有24个排列。因此，当k＝14时，所要求的排列将在 3 + (permutations of 1, 2, 4) 这个子排列中。这里求第几个会有一个公式： index = k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2 然后相当于实在求 permutations of {1, 2, 4} 中的一个子序列,新的k可以通过下述公式计算： k = k - (index from previous) (n-1)! = k - 2(n-1)! = 13 - 2*(3)! = 1 第二步中的全排列序列：&#8195;&#8195;1 + (permutations of 2, 4)&#8195;&#8195;2 + (permutations of 1, 4)&#8195;&#8195;4 + (permutations of 1, 2)根据公式求出新的index = k / (n - 2)! = 1 / (4-2)! = 1 / 2! = 0， 这样的话下一步应该在1 + (permutations of 2, 4)中，&#8195;&#8195;2 + (permutations of 4)&#8195;&#8195;4 + (permutations of 2) 再次根据公式计算k的值为1，index的值为1。 最后一步的子序列为(permutations of 2)，也可以计算的k的值为0，index的值为0(走个流程，最后结果都是这个)。 综上: index的自每一步中取值分别为：2 0 1 0，结合每一次的去安排列序列，可以得出最终的结果为： 3142 ！！ Java参考代码123456789101112131415161718192021222324252627public String getPermutation(int n, int k) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;(); int[] fn = new int[n+1]; for(int i=1;i&lt;=n;i++) nums.add(i); fn[0] = 1; int sum = 1; for(int i=1;i&lt;=n;i++)&#123; sum *= i; fn[i] = sum; &#125; k--; //减去1，因为总是计数是从0开始 StringBuilder sb = new StringBuilder(); for(int i=1;i&lt;=n;i++)&#123; int idx = k/fn[n-i]; sb.append(String.valueOf(nums.get(idx))); nums.remove(idx); k = k - idx*fn[n-i]; &#125; return sb.toString(); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理]]></title>
    <url>%2Fposts%2F41468%2F</url>
    <content type="text"><![CDATA[事务概述事务的概念来自于两个独立的需求：并发数据库访问，系统错误恢复。一个事务是可以被看作一个单元的一系列SQL语句的集合。事务通常指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 事务的特性（ACID） 原子性（Atomicity）：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 一致性（Consistency）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系： 只有满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对数据库崩溃的情况。 事务的隔离级别如果不对数据库进行并发控制，可能会产生异常情况： 脏读(Dirty Read)：当一个事务读取另一个事务尚未提交的修改时，产生脏读。同一事务内不是脏读。一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。如T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 不可重复读(Nonrepeatable Read) ：一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。如T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 幻读(Phantom Reads) ：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。如T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同 丢失修改(Lost Update)：第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。如T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）。 未提交读(Read Uncommitted)直译就是”读未提交”，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。Read Uncommitted允许脏读。 已提交读(Read Committed)直译就是”读提交”，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。Read Commited 不允许脏读，但会出现非重复读。 可重复读(Repeatable Read)：直译就是”可以重复读”，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。 串行读(Serializable)直译就是”序列化”，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。Serializable 不允许不一致现象的出现。 事务隔离的实现——锁MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 读写锁 排它锁（Exclusive）: 简写为 X 锁，又称写锁。一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。 共享锁（Shared）: 简写为 S 锁，又称读锁。用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。 有以下两个规定： 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁， Read Uncommited : 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 Read Committed : 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。 Repeatable Read: 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。 Serializable: 读加共享锁，写加排他锁，读写互斥。 意向锁使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。在MySQL存储引擎InnoDB中，意向锁是表级锁。 意向共享锁（IS）：在对一个数据行加共享锁前必须取得该表的IS锁。 意向排他锁（IX）：在对一个数据行加排他锁前必须取得该表的IX锁。 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。 MySQL 的 InnoDB 存储引擎提供的锁单行记录锁（Record Locks）锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。 间隙锁（Gap Locks）锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。 SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE; Next-Key Locks它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定范围内的索引. 数据库范式范式理论是为了解决数据库操作中的异常： 冗余数据：例如一行数据出现了两次。 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。 删除异常：删除一个信息，那么也会丢失其它信息。 插入异常 高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。 第一范式（1NF）在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。 第二范式（2NF）第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。 第三范式（3NF）满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 参考链接 CyC2018/Interview-Notebook 事务的概念 java面试之数据库面试知识点]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http与https]]></title>
    <url>%2Fposts%2F51855%2F</url>
    <content type="text"><![CDATA[URLURI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。 URI（Uniform Resource Identifier，统一资源标识符） URL（Uniform Resource Locator，统一资源定位符） URN（Uniform Resource Name，统一资源名称） HTTPHTTP(Hyper Text Transfer Protocol,超文本传输协议)是基于TCP/IP进行数据传输数据的，默认端口号是80。HTTP的特点：无连接、无状态、媒体独立。 无连接：指的是每次链接只处理一个请求。如果说服务端处理完客户端的一次请求后页收到了来自客户端的应答了，就会断开请求。 无状态：对于后续需要前面的相关信息就会需要重新传送。 媒体独立：只要服务端和客户端知道处理数据的方式，那么任何类型的数据都会通过HTTP发送。 HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。 工作流程一次HTTP操作称为一个事务，其工作过程可分为四步： 首先客户机与服务器需要建立连接。如单击某个链接，HTTP的工作开始。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 HTTP报文请求报文HTTP 请求分为三个部分：请求行（包括请求方法、URI、HTTP版本信息）、请求头、消息主体。类似于下面这样： HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。 常用的HTTP方法： GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 OPTIONS：查询相应URI支持的HTTP方法。 响应报文HTTP 响应分为三个部分：状态行（包括HTTP版本、状态码、状态码的原因短语）、响应头、消息主体。类似于下面这样： HTTP 状态码 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 常见的HTTP相应状态码 100 Continue 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 200 OK 客户端请求成功 301 Moved Permanently 请求永久重定向 302 Moved Temporarily 请求临时重定向 304 Not Modified 文件未修改，可以直接使用缓存的文件。 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常 CookieHTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 用途 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 分类 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 Secure 和 HttpOnly标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 Document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。 Session除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码； 如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 连接管理 短连接与长连接当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。流水线默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。 流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。 HTTP/1.0 与 HTTP/1.1 的区别 HTTP/1.1 默认是长连接 HTTP/1.1 支持管线化处理 HTTP/1.1 支持同时打开多个 TCP 连接 HTTP/1.1 支持虚拟主机 HTTP/1.1 新增状态码 100 HTTP/1.1 支持分块传输编码 HTTP/1.1 新增缓存处理指令 max-age HTTP/2.0二进制分帧层HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的.在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。 一个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向信息。 消息（Message）是与逻辑请求或响应消息对应的完整的一系列帧。 帧（Fram）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。 服务端推送HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。 首部压缩HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩. GET 和 POST 比较作用GET 用于获取资源，而 POST 用于传输实体主体。 参数GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。但是不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参考支持标准字符集。 Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据），而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。注意： 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 安全安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。不安全的方法除了 POST 之外还有 PUT、DELETE。 GET请求可以被浏览器缓存，POST不能 幂等性幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是 HTTPS超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTPS的工作过程 客户端发起HTTPS请求这个没什么好说的，就是用户在浏览器里输入一个HTTPS网址，然后连接到服务端的443端口。 服务端的配置采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个随机值。然后用证书（也就是公钥）对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务端解密信息服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。 客户端解密信息客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。 HTTPs 采用的加密方式 HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。 HTTPS和HTTP的区别 https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 参考链接： CyC2018/Interview-Notebook 详细解析 HTTP 与 HTTPS 的区别 HTTPS加密过程和TLS证书验证]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2Fposts%2F28758%2F</url>
    <content type="text"><![CDATA[网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。 计算机网络体系结构 五层协议 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。 运输层 ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 OSI其中表示层和会话层用途如下： 会话层 ：数据压缩、加密以及数据描述，这使得应用程序不必担心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 TCP/IP只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。 数据链路层 封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 透明传输：透明表示一个实际存在的事物看起来好像不存在一样。&#8195;&#8195;帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 差错检测：目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 网络层网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。网络层使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP 地址编址方式 分类由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}。 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}。要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。注意，外部网络看不到子网的存在。 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}。CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 地址解析协议 ARP网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。ARP 实现由 IP 地址得到 MAC 地址。每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 网际控制报文协议 ICMPICMP是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由器是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP报文有两种：差错报告报文和询问报文 ICMP的应用 Ping：测试两台主机之间的连通性。 Traceroute：跟踪一个分组从源点到终点的路径。 网络地址转换 NATNAT（Network Address Translation，网络地址转换）是一种网络地址翻译技术，将内部私有IP地址改变成可以在公网上使用的 IP。 NAT三种实现方式 静态地址转换：一个公网IP对应一个内部IP,一对一转换 动态地址转换：N个公网IP对应M个内部Ip,不固定的一对一IP转换关系．同一时间，有M-N个主机无法联网． 端口多路复用：对外只有一个公网IP,通过端口来区别不同内部IP主机的数据．转换 NAPT。 DHCP协议：动态主机设置协议（Dynamic Host ConfigurationProtocol, DHCP）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 运输层网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道。 UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。慢开始与拥塞避免 发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 常见的几道面试题TCP对应的协议和UDP对应的协议TCP对应的协议：（1） FTP：定义了文件传输协议，使用21端口。（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。 UDP对应的协议：（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 DNS域名系统，简单描述其工作原理。当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。 了解交换机、路由器、网关的概念，并知道各自的用途交换机交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。只有当目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。 路由器路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 网关网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。 交换机与路由器有什么区别？ 工作所处的OSI层次不一样，交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层。 寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址。 转发速不同：交换机的转发速度快，路由器转发速度相对较慢。 TCP协议如何来保证传输的可靠性 TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。 对于可靠性，TCP通过以下方式进行保证： 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据。 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层。 丢弃重复数据：对于重复数据，能够丢弃重复数据。 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。 IP地址与物理地址 物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。 参考链接： CyC2018/Interview-Notebook 常见面试题整理–计算机网络篇 面试中常见的计算机网络的问题]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql中的索引]]></title>
    <url>%2Fposts%2F64683%2F</url>
    <content type="text"><![CDATA[概述数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引是一种数据结构，一个索引是存储的表中一个特定列或者某几个特定列的值数据结构，索引是在列上创建的。 索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 MySql的存储引擎MySql的存储引擎主要有两种：MyISAM和InnoDB。 MyISAMMySql5.5之前的默认引擎，特点如下： 不支持行锁，读取是需要对读到的所有表加锁，写入时则对表加排他锁。 不支持事务和外键。 不支持崩溃后的安全恢复。 在表有读取查询的同时，支持往表中插入新纪录。 支持BLOB和TEXT的前600个字符索引，支持全文索引。 支持延迟更新索引，极大的提升了写入性能。 对于不会进行修改的表，支持压缩表，减少了磁盘空间占用。 InnoDBMySql5.5之后的默认引擎，特点如下： 支持行锁，采用MVCC来支持高并发，可能死锁。 支持事务和外键。 支持崩溃后的安全恢复。 不支持全文索引。 总而言之，MyISAM适合读密集的表，而InnoDB适合写密集的表。 MyISAM和InnoDB都可以采用B+ Tree作为索引，但是其实现方式是不同的。 MylSAM： B+Tree叶节点的data域存放的是数据记录的地址。检索时，首先 ，按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称非聚簇索引。 InnoDB:其数据文件本身就是就是索引文件，树的叶子节点的data域保存了完整的数据记录。如果这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为聚簇索引。而其余的索引都被称为辅助索引，辅助索引的data域记录相应的主键的值。根据主索引搜索时，直接到key所在的节点索引，即可取出数据。再根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 B+ Tree 原理B+ Tree 是Btree(Balance Tree)的变体，也是一种多路平衡的搜索树。B+树所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 B+ Tree的查找和删除进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。 插入删除操作记录会破坏平衡树的平衡性，因此在插入删除时，需要对树进行一个分裂、合并、旋转等操作。 为什么是B+ Tree红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因： B+的磁盘读写代价更低 &#8195;&#8195;B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 B+-tree的查询效率更加稳定 &#8195;&#8195;由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 索引分类B+Tree 索引B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。B+Tree 索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 普通索引：最基本的索引类型，而且它没有唯一性之类的限制。 UNIQUE索引：表示唯一的，不允许重复的索引，可以为NULL值，一个表可以有多个唯一索引。 主键索引：主键是一种唯一性索引，不能为NULL值，只能有一个。 哈希索引InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制： 无法用于排序与分组； 只支持精确查找，无法用于部分查找和范围查找；全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。 空间数据索引（R-Tree）MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据。 总结索引的优点 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序和创建临时表（B+Tree 索引是有序的，可以用来做 ORDER BY 和 GROUP BY 操作）； 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，也就将相邻的数据都存储在一起）。 索引能够极大地提高数据检索效率，也能够改善排序分组操作的性能，但有不能忽略的一个问题就是索引是完全独立于基础数据之外的一部分数据。假设在Table ta 中的Column ca 创建了索引 idx_ta_ca，那么任何更新 Column ca 的操作，MySQL在更新表中 Column ca的同时，都须要更新Column ca 的索引数据，调整因为更新带来键值变化的索引信息。而如果没有对 Column ca 进行索引，MySQL要做的仅仅是更新表中 Column ca 的信息。这样，最明显的资源消耗就是增加了更新所带来的 IO 量和调整索引所致的计算量。此外，Column ca 的索引idx_ta_ca须要占用存储空间，而且随着 Table ta 数据量的增加，idx_ta_ca 所占用的空间也会不断增加，所以索引还会带来存储空间资源消耗的增加。 索引选择原则 较频繁的作为查询条件的字段应该创建索引 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件 更新非常频繁的字段不适合创建索引 不会出现在 WHERE 子句中的字段不该创建索引 选择在哪个列上创建索引是最非常重要的。可以考虑使用索引的主要有 两种类型的列：在where子句中出现的列，在join子句中出现的列，而不是在SELECT关键字后选择列表的列。 索引列的基数越大(不重复的索引值)，索引的效果越好。 使用短索引(前缀索引)，如果对字符串列进行索引，应该指定一个前缀长度，可节省大量索引空间，提升查询速度。 多列索引。在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。 索引选择注意事项既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。 表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。 索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：Index Selectivity = Cardinality / #T。显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，对于选择性太小的列没必要创建索引。 MySQL只对一下操作符才使用索引：&lt;,&lt;=,=,&gt;,&gt;=,between,in, 以及某些时候的like(不以通配符%或_开头的情形)。 不要过度索引，只保持所需的索引。每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。 在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 参考链接： CyC2018/Interview-Notebook MYSQL-索引 由 B-/B+树看 MySQL索引结构 请说出数据库索引实现原理]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机类加载机制]]></title>
    <url>%2Fposts%2F40484%2F</url>
    <content type="text"><![CDATA[概述&#8195;&#8195;虚拟机的类加载机制就是虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。在Java语言里面，类型的加载、连 接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些 性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言 特性就是依赖运行期动态加载和动态连接这个特点实现的。 类加载的时机&#8195;&#8195;类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加 载（Loading)、验证（Verification)、准备（Preparation)、解析（Resolution)、初始化 (Initialization)、使用（Using)和卸载（Unloading) 7个阶段。其中验证、准备、解析3个部分统称为连接（Linking),这7个阶段的发生顺序如下图所示。 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化 阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。但是这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、 激活另外一个阶段。 对于加载过程， Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化过程，有且只有5种情况必须立即对类进行“初始化”： 使用new 关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果 放人常量池的静态宇段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化， 则需要先触发其初始化。 初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父 类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含mainO方法的那个类），虚 拟机会先初始化这个主类。 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式（被动引用）都不会触发初始化。 1234567891011121314151617181920212223242526272829//父类public class Father &#123; static&#123; System.out.println("Father init"); &#125; public static int value = 123;&#125;//子类public class Son extends Father &#123; static &#123; System.out.println("Son init"); &#125; public static final String HELLO = "hello";&#125;//测试类public class Test &#123; public static void test1() &#123; Son.value; &#125; public static void test2() &#123; Father[] nums = new Father[0]; &#125; public static void test3() &#123; System.out.println(Son.HELLO); &#125;&#125; 当调用test1()方法后，输出“Father init”，而不会输出“Son init”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静 态字段，只会触发父类的初始化而不会触发子类的初始化。 当调用test2()方法后，没有输出 “Father init”，这说明没有触发Father类的初始化。这是因为数组类本身不通过类加载器创建，它是由Java虚拟 机直接创建的，创建数组的动作是由字节码指令newairay触发。 当调用test3()方法后，没有输出 “Son init”，这说明没有触发Father类的初始化。这是因为在编译阶段通过常量传播优化，已经将此常量的值“hello”存储到了 Test类的•常量池中，以后Test类对常量 Son.HELLO的引拥实际都被转化为Test类对自身常量池的引用。 类加载的过程加载在加栽阶段，虚拟机需要完成以下3件亊情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问人口。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中， 对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面）， 这个对象将作为程序访问方法区中的这些类型数据的外部接口。 加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加栽阶段尚未完成，连接阶段可能已经开始，但这拽夹在加栽阶段之中进行的动作，仍然属 予连接阶段的内容，这两个阶段的开始时间仍然保持着同定的先后顺序。 验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含时信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成4个阶段的检验动作:文件格式验证、元数据验证、字节码验证和符号引用验证。 文件格式验证阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处 理。元数据验证阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规 范的元数据信息。字节码验证阶段的主要目的是通过数据流和控制流分析， 确定程序语义是合法的、符合逻辑的。符号引用验证阶段可以可以看做是对类自身以外（常量池中 的各种符号引用）的信息进行匹配性校验。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值.假设一个类变量的定义为：public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器&amp;ltclinit&amp;gt（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 下图列出了Java中所有基本数据类型以及reference类型的默认零值： 这里还需要注意如下几点： 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 类或接口的解析假设当前代码所处的类为D,如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤： 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加栽 器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他 相关类的加载动作，例如加载这个类的父类或实现的接口 •一旦这个加载过程出现了任何异 常，解析过程就宣告失败。2.如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似 “[Ljava/lang/hiteger”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述 符如前面所假设的形式，需要加载的元素类型就是“Java.lang.Integer”，接着由虚拟机生成一 个代表此数组维度和元素的数组对象。3.如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的 类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。 如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。 字段解析对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序：1234567891011121314151617181920212223242526class Super&#123; public static int m = 11; static&#123; System.out.println("执行了super类静态语句块"); &#125;&#125; class Father extends Super&#123; public static int m = 33; static&#123; System.out.println("执行了父类静态语句块"); &#125;&#125; class Child extends Father&#123; static&#123; System.out.println("执行了子类静态语句块"); &#125;&#125; public class StaticTest&#123; public static void main(String[] args)&#123; System.out.println(Child.m); &#125;&#125; 执行结果如下： 执行了super类静态语句块 执行了父类静态语句块 33 如果注释掉Father类中对m定义的那一行，则输出结果如下： 执行了super类静态语句块 11 分析如下：static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。 类方法解析对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。 接口方法解与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。 初始化 初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器&amp;ltclinit&amp;gt()方法的过程。 &amp;ltclinit&amp;gt()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。 &amp;ltclinit&amp;gt()方法与实例构造器&amp;ltinit&amp;g()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&amp;ltclinit&amp;gt()方法执行之前，父类的&amp;ltclinit&amp;g()方法已经执行完毕。因此，在虚拟机中第一个被执行的&amp;ltclinit&amp;gt()方法的类肯定是java.lang.Object。 &amp;ltclinit&amp;gt()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&amp;ltclinit&amp;gt()方法。 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成&amp;ltclinit&amp;gt()方法。但是接口鱼类不同的是：执行接口的&amp;ltclinit&amp;gt()方法不需要先执行父接口的&amp;ltclinit&amp;gt()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&amp;ltclinit&amp;gt()方法。 虚拟机会保证一个类的&amp;ltclinit&amp;gt()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&amp;ltclinit&amp;gt()方法，其他线程都需要阻塞等待，直到活动线程执行&amp;ltclinit&amp;gt()方法完毕。如果在一个类的&amp;ltclinit&amp;gt()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 1234567891011121314151617class Father&#123; public static int a = 1; static&#123; a = 2; &#125;&#125; class Child extends Father&#123; public static int b = a;&#125; public class ClinitTest&#123; public static void main(String[] args)&#123; System.out.println(Child.b); &#125;&#125; 执行上面的代码，会打印出2，也就是说b的值被赋为了2。 首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用&amp;ltclinit&amp;gt()方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的&amp;ltclinit&amp;gt()方法，根据规则2，在此之前，要先执行完其父类Father的&amp;ltclinit&amp;gt()方法，又根据规则1，在执行&amp;ltclinit&amp;gt()方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的&amp;ltclinit&amp;gt()方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的&amp;ltclinit&amp;gt()方法，这样便会将b的赋值为2。 如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。原因同上。 另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。 类加载器类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类 加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚 拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通 俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有 意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们 的类加载器不同，那这两个类就必定不相等。这里所指的“相等’ 包括代表类的Class对象的equals()方法、isAssignableFrom()方法、 islnstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。 站在Java虚拟机的角度来讲，只存在两种不同的类加载器： 启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。 所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 自定义的类加载器。 这几种类加载器的层次关系如下图所示： 这种层次关系称为类加载器的双亲委派模型。把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。 此外，类加载器全盘负责机制：当一个类加载器加载一个Class的时候，这个Class所依赖的和引用的所有Class也由这个类加载器负责载入，除非是显式的使用另外一个类加载器载入。 详情请参见 深入理解Java虚拟机第二版 【深入Java虚拟机】之四：类加载机制]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2Fposts%2F15805%2F</url>
    <content type="text"><![CDATA[概述 &#8195;&#8195; Java 内存运行时区域的可分为程序计数器、虚拟机栈、本地方法栈、Java堆和方法区等5个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而 生，随线程而灭；栈中的栈帧随着方法的进人和退出而有条不紊地执行着出栈和入栈操作。 每一个找帧中分配多少内存基本上是在类结构确定下来时就已知的， 因此这几个区域的内存分配和回收都具备确定性，在方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一 样，一个接口中的多个实现类需要的内存可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，而垃圾收集器所关注的正是这部分内存。 哪些对象需要回收 &#8195;&#8195;在堆里面存放着Java程序中几乎所有的对象，垃圾收集器在对堆进行回收前，第一 件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”。常见的方法有两个：引用计数算法和可达性分析算法。 引用计数算法 &#8195;&#8195;引用计数算法（Reference Counting）的判定方式很简单：给对象中增加一个引用计数器，每当有 一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器允 0的对象就是不可能再被使用的。一般地说，引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是至少主流的 Java虚拟机里面没有选则引用计数算法来管理内存，其中最主要的原因是它很难解决对象之 间相互循环引用的问题。 public class ReferenceCountingGC{ public Object instance = null; private static final int _1MB = 1024 * 1024; public static void testGC() { ReferenceCountingGC objA = new ReferenceCountingGCO ; ReferenceCountingGC objB = new ReferenceCountingGCO; objA.instance = objB; objB.instance = objA; objA = null; objB = null; //假设在这行发生GC, objA和ObjB是否能被回收？ System.gc(); } } &#8195;&#8195; 如以上代码所示testGC()方法, 对象objA和objB都有宇段instance, 赋值令objA.instance = objB=及 objB.instance = objA。除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着方，导致它们引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。 可达性分析算法&#8195;&#8195; 可达性分析（ReacffabilityAnaljLsisy）算法的基本思 路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所通过的路径称为引用链(Reference Chain),等一个对象到GC Roots没有任何引用链相连时，则明此对象是不可用的。如 下图所示，对象object5、object6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是对回收的对象。&#8195;&#8195; 在可达性分析箅法中不可达的对象，也并非是一定要被回收的。要真正回收一个对象，至少要经历两次标记过程。如果对象在进行可 达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做 F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它,这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。 稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中重新与引用链上 的任何一个对象建立关联，譬如把自己（this关键字）陚值给某个类变量或者对象的成 员变量，那在第二次标记时它将被移除出“即将回收”的集合。如果对象这时候仍然被标记， 那基本上它就真的被回收了。务必注意，finalize()方法都最多只会被系统自动调用一次。 回收方法区&#8195;&#8195;方法区（或者HotSpot虚拟机中的永久代）主要回收两部分内容：废弃常量和无用的类。 回收废弃常量与回收 Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进 人了常量池中，但是当前系统没有任何一个String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这 时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 类需要同时满足下面3个条件才能算是“无用的类”： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访 问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是 和对象一样，不使用了就必然会回收。 垃圾收集算法标记-清除算法&#8195;&#8195;最基础的收集算法是“标记-清除”（Marie-Sweep)算法，如同它的名字一样，算法分 为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一 个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后 在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次 垃圾收集动作。标记—清除算法的执行过程如下图所示。 复制算法&#8195;&#8195;为了解决效率问题，一种称为“复制”（Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都 是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶 指针，按顺序分配内存即可，实现简单，运行髙效。只是这种算法的代价是将内存缩小为了 原来的一半，未免太高了一点。复制算法的执行过程如下图所示。 这种收集算法主要被用来回收新生代，新 生代中的对象98%是“朝生夕死”的，所以并不需要按照1 ：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一 块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块 Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden 和Survivor的大小比例是8 : 1,也就是每次新生代中可用内存空间为整个新生代容量的90%,只有10%的内存会被“浪费”。如果另外一块Survivor空间没有足够空间在放上一次新生代收集下来的存活对象 时，这些对象将直接通过分配担保机制进人老年代。 标记-整理算法&#8195;&#8195;根据老年代的特点，提出7另外一种“标记_-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的 示意图如下所示。 分代收集算法&#8195;&#8195;“分代收集”（Generational Collection)算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代 中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付 出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间 对它进行分配担保，就必须使用“标记一清理”或者“标记一整理”算法来进行回收。 垃圾收集器&#8195;&#8195;垃圾收集器就是内存回收的具体实现。Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚 拟机所提供的垃圾收集器都可能会有很大差别，这里讨论的收集器基于JDK 1.7 Update 14之 后的HotSpot虚拟机，这个虚拟机包含的所有收集器下如图所示（如果两个收集器之间存在连线，就说明它 们可以搭配使用。）。 Serial 收集器&#8195;&#8195;Serial收集器是一个单线程的收集器，它的 “单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作， 更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。下面是 Serial / Serial Old收集器运行示意图。 Serial收集器的优点是简单而高效（与其他收集器的单线程比），对于限定 单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集可以 获得最高的单线程收集效率。缺点则是因内存回收而导致GC停顿。 ParNew收集器&#8195;&#8195;ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集 之外.其余行为包括Serial收集器可用的所有控制参数、收集算法、StopTheWorld、 对象分配规则、回收策略等都与Serial收集器完全一样。ParNew / Serial Old收集器运行示意图如下。 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于 存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分 之百地保证可以超越Serial收集器.但是，随着可以使用的CPU的数量的增加，它对于 GC时系统资源的有效利用还是很有好处的。 Parallel Scavenge 收集器&#8195;&#8195;Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标則是达到一个可控制的吞叶量（Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间）。停顿时间越短就越适合需耍与用户交互的程序，良好的响应速度能提升用户体验，而 吞吐量则可以髙效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记一整理”算法。这个收集器是在JDK 1.6中才开始提供的，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。 CMS收集器&#8195;&#8195;CMS(Concurrent Mark Sweep)收集器是一秤以获取最短回收停顿时间为目标的收集器。，CMS收集器是基于”标记—清除”算法实现的，它的运作过程相分为四个步骤： 初始标记 并发标记 重新标记 并发消除 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快,：并.发;向己阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产牛变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一 些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起 工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS主要优点在于：并发收集和低停顿。但是CMS以下3个明显的缺点： 对CPU资源非常敏感 无法处理浮动垃圾（Floating Garbage)，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生 收集结束 时，可能会有大量空间碎片产生 G1收集器&#8195;&#8195;G1 (Garbage-First)收集器是当今收集器技术发展的最前沿成果之一，是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如 下特点。 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU (CPU 或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿 Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需 要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建 的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。 空间整合: 与CMS的“标记一清理”算法不同，G1从整体来看是基于“标记一整理” 算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的， 但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提 供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找 到连续内存空间而提前触发下一次GC。 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共 同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N毫秒。 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这 样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region),虽然还保留有新生代和老年代的概念，但新生代和 老年代不再是物理隔离的了，它们都是一部分Region (不需要连续）的集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进#全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价値大小（回收.所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许 的收集时间，优先回收价值最大的Region。 G1收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS (Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记阶段是从GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发 执行。 而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面， 最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停 顿线程，但是可并行执行。 最后在筛选回收阶段首先对各个Region的回收价值和成本进行排 序，根据用户所期望的GC停顿时间来制定回收计划， 内存分配与回收策略&#8195;&#8195;对象的内存分配，往大方向讲，就是在堆上分配：对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。下面是几条最普遍的内存分配规则。 对象优先在Eden分配&#8195;&#8195;大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 Minor GC和FullGC的区别： 新生代GC(Minor GC): 指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝 生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。 老年代GC (Major GC/FullGC〉：指发生在老年代的GC, 出现了 Major GC,经常会伴 随至少一次的MinorGC (但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接 进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。 大对象直接进入老年代&#8195;&#8195;所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长 的字符串以及数组，经常出现大对象容易 导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。 长期存活的对象将进入老年代&#8195;&#8195;既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义 了一个对象年龄（Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对 象在Survivor区中每“熬过”一次MinorGC,年龄就增加1岁，当它的年龄增加到一定程 度（默认为15岁），就将会被晋升到老年代中。 动态对象年龄判定&#8195;&#8195;为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进人老年代，无须等到MaxTenuringThreshold中要求的年龄。 空间分配担保&#8195;&#8195;在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生 代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成 立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么 会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果 大于，将尝试着进行一次Minor GC,尽管这次Minor GC是有风险的：如果小于或者 HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 下面解释一下“冒险”是冒了什么风险，前面提到过，新生代使用复制收集算法，但 为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在 Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就 需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。 老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容童的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是 否进Full GC来让老年代腾出更多空间。 取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存 活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure)。 如果出现了 HandlePromotionFailure失败，那就只好在失败后重新发起一次FullGC。虽然 担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotkmFailure开关打 开，避免Full GC过于频繁。 关于JVM参数设置与分析详见这篇文章。 详情请参见深入理解Java虚拟机第二版 &#8195;&#8195;]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域]]></title>
    <url>%2Fposts%2F35314%2F</url>
    <content type="text"><![CDATA[概述Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间：有的区域随着虚拟机进程的启动而 存在.有些区域则依赖用户线程的启动和结朿而建立和销毁。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示。 程序计数器 &#8195;&#8195;程序计数器（Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 &#8195;&#8195;程序计数器属于“线程私有”的内存。这是因为Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的， 在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线 程中的指令。因此，为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立 的程序计数器，各条线程之间的计数器互不影响，独立存储。 Java虚拟机栈&#8195;&#8195;Java虚拟机栈（Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frames，方法运行时的基础数据结构) 用于存储局部变量表、操作数栈、动态链接、方法出 口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中人桟到 出栈的过程。 &#8195;&#8195;局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、 float、long、double)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对 象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 retumAddress类型（指向了一条字节码指令的地址)。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot),其余的数 据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进人一个方法时， 这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部 变童表的大小。 &#8195;&#8195;在Java虚拟机规范中，对这个区域规定了两种异常状况： StackOverflowError异常 : 线程请求的栈深度大于虚 拟机所允许的深度。 OutOfMemoryError异常 : 虚拟机栈可以动态扩展且在扩展时无法申请到足够的内存。 本地方法栈&#8195;&#8195;本地方法栈（Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为 虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法找中方法使用的语言、使用方 式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（例如HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法 栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。 Java堆&#8195;&#8195;Java堆(Java Heap)是Java虚拟机所管理的内存中最犬块,且 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就 是存放实例，几乎所有的对象实例都在这里分配。这里要注意不过堆中的数据无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例。 &#8195;&#8195;Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。 方法区&#8195;&#8195;方法区（Methof Area)也是各个线程共享的内存区域，它甩管存储已被虚拟机加载的类信息、常量、静态变量即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出 OutOfMemory Error 异常。 运行时常量池&#8195;&#8195;运行时常量池（Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table)，用于 存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进人方法区的运行时常量池中存放。运行时常量池具备动态性，Java语言并 不要求常量一定只有编译期才能产生，也就是并非预置人Class文件中常量池的内容才能进 人方法区运行时常量池，运行期间也可能将新的常量放人池中。 &#8195;&#8195;当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存&#8195;&#8195;直接内存（DirectMemoiy)并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。早在JDK 1.4中新加人了 NIO (New Input/Output)类，引人了一种基于通道（Channel) 与缓冲区（Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一 个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场 景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 &#8195;&#8195;本直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是 会受到本机总内存大小以及处理器寻址空间的限 制。因此在动态扩展时也会出现OutOfMemoryError异常。 HotSpot虚拟机在Java堆中堆对象的操作对象的创建&#8195;&#8195;在Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建过程却没有那么容易。 虚拟机遇到一条new指令时，首先将去检査这个指令的参数是否能在常量池中定位到一 个类的符号引用，并且检査这个符号引用代表的类是否已被加载、解析和初始化过。如果没 有，那必须先执行相应的类加载过程。 在类加栽检査通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在 类加载完成后便可完全确定，为对象分配空间的任务等同于 把一块确定大小的内存从Java堆中划分出来。划分的方式又有两种：假设Java堆中内存是绝对规整的，所有用过 的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方 式称为“指针碰撞”（Bump the Pointer)。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，则虚拟机就必须维护一个列 表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象 实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List〉。与此同时，由于Java堆被所有线程共享，还应该考虑在并发情况下为对象分配内存的线程安全 性：一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存 分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配二小块内 存，称为本地线程分配缓冲。 内存分配完成后.虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。 虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找 到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对 象头（Object Header）之中。 经过以上步骤，new操作就已经完成，但是只有对象进行了初始化，一个真正可用的对象才算完全产生出来。 对象的内存布局&#8195;&#8195;在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header)、 实例数据（Instance Data)和对齐填充（Padding)。 &#8195;&#8195;HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指 针来确定这个对象是哪个类的实例。 &#8195;&#8195;接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种 类型的字段内容。无论是从父类继承下来的，还是在于类中定义的，都需要记录起来。 &#8195;&#8195;第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用（HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍）。 对象的访问定位&#8195;&#8195;Java程序需要通过栈上的reference数据来操作堆上 的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式 也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如下图所示。 详情请参见深入理解Java虚拟机第二版]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下编译OpenJDK7]]></title>
    <url>%2Fposts%2F14724%2F</url>
    <content type="text"><![CDATA[准备开发包 OpenJDK7u75官方源码包，下载地址 Bootstrap JDK为Oraclejdk7u80， 下载地址 NetBeans7.0.1的C++版，下载地址 编译OpenJDK7源码安装依赖 sudo apt-get install build-essential gawk m4 libasound2-devlibcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-devbinutils libmotif3 libmotif-dev ant 编写编译脚本创建一个build.sh，并把下面的内容放进去，再把build.sh放到OpenJDK源码的目录下。12345678910111213141516171819202122232425262728293031323334353637#!/bin/bash export LANG=C # Oracle JDK7的目录export ALT_BOOTDIR=/usr/lib/jvm/jdk1.7.0_80 #允许自动下载依赖包 export ALLOW_DOWNLOADS=true #使用预编译头文件，以提升便以速度 export USE_PRECOMPILED_HEADER=true #要编译的内容 export BUILD_LANGTOOLS=true export BUILD_JAXP=true export BUILD_JAXWS=true export BUILD_CORBA=true export BUILD_HOSTPOT=true export BUILD_JDK=true #要编译的版本 export SKIP_DEBUG_BUILD=false export SKIP_FASTDEBUG_BUILD=true export DEBUG_NAME=debug #避免javaws和浏览器Java插件等的build BUILD_DEPLOY=false #不build安装包BUILD_INSTALL=false #设置存放编译结果的目录,一定要放在一个可以读写的路径 export ALT_OUTPUTDIR=/home/re/openjdk7/build unset CLASSPATH unset JAVA_HOME make sanity make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log 开始编译在命令行里切换到OpenJDK源码的目录下，运行脚本。 sh build.sh 经过一段时间的运行之后，出现下图时，就是编译完成了。 编译过程中遇到的问题 内核版本不支持 echo “ This OS is not supported:” uname -a; exit 1; This OS is not supported: Linux bcc66964b45e 4.9.27-moby 解决办法：编辑 hotspot/make/linux/Makefile，在改SUPPORTED_OS_VERSION一行后面添加4%。 SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7% 3% 4% 时间问题 Error: time is more than 10 years from present: 1136059200000java.lang.RuntimeException: time is more than 10 years from present: 1136059200000 解决办法：修改/jdk/src/share/classes/java/util/CurrencyData.properties中的几行参数，将其改为0年内的一个时间。 AZ=AZM;2010-12-31-20-00-00;AZN MZ=MZM;2011-06-30-22-00-00;MZN RO=ROL;2011-06-30-21-00-00;RON TR=TRL;2011-12-31-22-00-00;TRY VE=VEB;2012-01-01-04-00-00;VEF 在NetBeans IDE工具中进行HotSpot调试实例 在NetBeans中新建基于源码c/c++项目 选择OpenJDK下关于hotspot的源码文件夹地址，以及选择定制 选择hotspot的make目录下makefile的路径 下一步要填写一些生成命令： ${MAKE} -f Makefile clean jvmg ALT_BOOTDIR=/usr/lib/jvm/jdk1.7.0_80 ARCH_DATA_MODEL=64 LANG=C 其中ALT_BOOTDIR就是编译脚本Oracle JDK7的目录的路径。 一直点下一步，在ide中会出现hotspot项目,右键点击项目，选择属性，再点运行，又出来三个需要配置的地方。 设置运行命令为： /home/re/openjdk7/build/hotspot/outputdir/linux_amd64_compiler2/jvmg/gamma Queens -XX:+TraceBytecodes -XX:StopInterpreterAt= 设置运行目录为： /home/re/openjdk7/build/hotspot/outputdir/linux_amd64_compiler2/jvmg/gamma 设置环境变量为： JAVA_HOME ：/usr/lib/jvm/jdk1.7.0_80 CLASSPATH：.: \$ {JAVA_HOME}/lib/dt.jar:\${JAVA_HOME}/lib/tools.jar LD_LIBRARY_PATH： /home/re/openjdk7/build/hotspot/outputdir/linux_amd64_compiler2/jvmg 完成以上配置之后，一个可修改、编译、调试的HotSpot 工程就完全建立起来了，启动器的执行入口是java.c的main()方法，读者可以设置断点单步跟踪，如下图所示。 参考链接： Ubuntu14.04 下编译 OpenJDK Java虚拟机HotSpot调试实例 深入理解Java虚拟机]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>OpenJDK7</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口的最大值]]></title>
    <url>%2Fposts%2F8268%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。均不匹配. 思路分析对于这个题目而言，暴力解法是比较遍历整个数组，求出每一个滑动窗口的最大值，但是这样做的话带来了大量的重复计算。因此，如果考虑滑动窗口之间的相关性，可以用一个队列来模拟整个过程。 对新来的元素k，将其与队列中的元素相比较1、前面比k小的，直接移出队列（因为不再可能成为后面滑动窗口的最大值了!）,2、前面比k大的X，比较两者下标，判断X是否已不在窗口之内，不在了，直接移出队列注意：队列中存放的是每个元素对应的索引 重复下来，队列的第一个元素是滑动窗口中的最大值 Java实现12345678910111213141516171819202122232425262728public ArrayList&lt;Integer&gt; maxInWindows(int [] nums, int size)&#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int len = nums.length; if(len==0||size==0||size&gt;len) return res; LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for(int i=0;i&lt;size-1;i++)&#123; while(!q.isEmpty()&amp;&amp;nums[i]&gt;nums[q.getLast()]) q.removeLast(); q.addLast(i); &#125; for(int i=size-1;i&lt;len;i++)&#123; while(!q.isEmpty()&amp;&amp;nums[i]&gt;nums[q.getLast()]) q.removeLast(); q.addLast(i); if(i-q.getFirst() + 1&gt;size) q.removeFirst(); res.add(nums[q.getFirst()]); &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式匹配]]></title>
    <url>%2Fposts%2F16074%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数用来匹配包括’.’和’ ‘的正则表达式。模式中的字符’ . ‘表示任意一个字符，而’ ‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 思路分析要判断是否匹配，首先对’ . ‘ 和 ‘ * ‘的作用进行分析： ‘ . ‘比较简单，就是可以指代任意字符，切不可忽略。 ‘ ‘一般出现在一个字符的后面，表示它前面的字符可以出现0次或者多次。如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：1、模式后移2字符，相当于x被忽略2、字符串后移1字符，模式后移2字符，即只匹配一次3、字符串后移1字符，模式不变，即继续匹配字符下一位 Java实现1234567891011121314151617181920212223242526272829public boolean match(char[] s, char[] p)&#123; if(s==null||p==null) return false; return match(s,0, p,0);&#125;private boolean match(char[] s,int si,char[] p,int pi)&#123; if(si==s.length&amp;&amp;pi==p.length) return true; if(si!=s.length&amp;&amp;pi==p.length) return false; if(pi&lt;p.length-1&amp;&amp;p[pi+1]=='*')&#123; if((si != s.length &amp;&amp; p[pi] == s[si]) || (p[pi] == '.' &amp;&amp; si != s.length)) return match(s,si+1, p,pi+2) || match(s,si+1, p,pi) || match(s,si, p,pi+2); else return match(s,si, p,pi+2); &#125; if((si != s.length &amp;&amp; p[pi] == s[si]) || (p[pi] == '.' &amp;&amp; si != s.length)) return match(s,si+1, p,pi+1); return false;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字在排序数组中出现的次数]]></title>
    <url>%2Fposts%2F32844%2F</url>
    <content type="text"><![CDATA[题目描述统计一个数字在排序数组中出现的次数。 注意：输入的数组是有序的。 思路分析对于这个题目，最简单的思路就是顺序扫描整个数组，当找到这个数字时，让相应的计数变量自增。这样的话，算法的时间复杂度为O(n)。但是千万忘了该数组是有序的，因此可以考虑是否可以用上二分搜索。最简单的一种想法就是利用二分搜索找到它第一次出现的位置，再找到它最后一次出现的位置，两个相减既是该数字出现的次数。该算法时间复杂度为O(log n)。 Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int GetNumberOfK(int [] nums , int k) &#123; int len = nums.length; if(len==0) return 0; int start = getStartK(nums,k,0,nums.length-1); int end = getEndK(nums,k,0,nums.length-1); if(start!=-1&amp;&amp;end!=-1) return end - start + 1; return 0;&#125;private int getStartK(int[] nums,int k,int l,int r)&#123; if(l&gt;r) return -1; int mid = l + (r-l)/2; if(nums[mid]==k)&#123; if(mid&gt;0&amp;&amp;nums[mid-1]!=k||mid==0) return mid; else r = mid-1; &#125;else if(nums[mid]&gt;k)&#123; r = mid - 1; &#125;else&#123; l = mid + 1; &#125; return getStartK(nums,k,l,r);&#125; private int getEndK(int[] nums,int k,int l,int r)&#123; if(l&gt;r) return -1; int mid = l + (r-l)/2; if(nums[mid]==k)&#123; if(mid&lt;nums.length-1&amp;&amp;nums[mid+1]!=k||mid==nums.length-1) return mid; else l = mid + 1; &#125;else if(nums[mid]&gt;k)&#123; r = mid - 1; &#125;else&#123; l = mid + 1; &#125; return getEndK(nums,k,l,r);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2Fposts%2F33062%2F</url>
    <content type="text"><![CDATA[题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007注意：输入的数组中没有的相同的数字 思路分析对于这个题目，最简单的思路就是顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小，如果后面的数字比它小，则这两个数字就组成了一个逆序对，对于一个长度为n的数组来说，这个算法的时间复杂度为O(n^2)。 在这里以数组{7,5,6,4}为例来分析统计逆序对的过程。 (a) 把长度为4的数组分解成两个长度为2的子数组；(b) 把长度为2的数组分解成两个成都为1的子数组；(c) 把长度为1的子数组 合并、排序并统计逆序对 ；(d) 把长度为2的子数组合并、排序，并统计逆序对； 在上图（a）和（b）中，先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。其实可以看到，这种做法就是归并排序的一部分操作。 在每一次归并的时候，如果后半部分指数组针指向的数字比前半部分数组指针指向的数字大，则和归并排序一样，反之，前半部分指向的数字大，则进行统计，此时，前半部分剩下的所有数字都和后半部分当前的数字构成了一个逆序对。算法的时间复杂度是O(n*log n),空间复杂度是O(n)。 Java实现123456789101112131415161718192021222324252627282930313233343536private long cnt = 0;private int[] aux;public int InversePairs(int [] nums) &#123; int len = nums.length; if(len&lt;2) return 0; aux = new int[len]; for(int step = 1;step&lt;len;step += step) for(int k=0;k&lt;len-step;k += 2*step) merge(nums,k,k+step-1,Math.min(len-1,k+2*step-1)); return (int)(cnt%1000000007);&#125;private void merge(int[] nums,int l,int m,int r)&#123; for(int k=l;k&lt;=r;k++) aux[k] = nums[k]; int i = l,j = m+1; for(int k=l;k&lt;=r;k++)&#123; if(i&gt;m) nums[k] = aux[j++]; else if(j&gt;r) nums[k] = aux[i++]; else if(aux[j]&gt;aux[i]) nums[k] = aux[i++]; else&#123; nums[k] = aux[j++]; cnt += m-i+1; &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树转换为双向链表]]></title>
    <url>%2Fposts%2F18325%2F</url>
    <content type="text"><![CDATA[题目描述&#8195;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路&#8195;核心思想是利用树的中序遍历（递归版）解题思路：1.将左子树构造成双链表，并返回链表头节点。2.定位至左子树双链表最后一个节点。3.如果左子树链表不为空的话，将当前root追加到左子树链表。4.将右子树构造成双链表，并返回链表头节点。5.如果右子树链表不为空的话，将该链表追加到root节点之后。6.根据左子树链表是否为空确定返回的节点。 Java参考代码1234567891011121314151617181920212223242526272829303132333435363738/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public TreeNode Convert(TreeNode root) &#123; if(root==null) return null; if(root.left==null&amp;&amp;root.right==null) return root; TreeNode left = Convert(root.left); TreeNode p = left; while(p!=null&amp;&amp;p.right!=null) p = p.right; if(left!=null)&#123; p.right = root; root.left = p; &#125; TreeNode right = Convert(root.right); if(right!=null)&#123; right.left = root; root.right = right; &#125; return left == null ? root : left;&#125; 参考链接：https://www.nowcoder.com/questionTerminal/947f6eb80d944a84850b0538bf0ec3a5]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组的最小数字]]></title>
    <url>%2Fposts%2F48940%2F</url>
    <content type="text"><![CDATA[题目要求把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路采用二分法解答这个问题，mid = l + (r - l)/2需要考虑三种情况：(1)nums[mid] &gt; nums[r]:&#8195;出现这种情况的nums类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 (2)nums[mid] == nums[r]:&#8195;出现这种情况的nums类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 。(3)nums[mid] &lt; nums[r]:&#8195;出现这种情况的nums类似[2,2,3,4,5,6,6],此时最小数字一定就是nums[mid]或者在mid的左边。因为右边必然都是递增的。 Java实现12345678910111213141516171819public int minNumberInRotatenums(int [] nums) &#123; int len = nums.length; if(len==0) return 0; int l = 0; int r = len-1; while(l&lt;r)&#123; int mid = l + (r-l)/2; if(nums[mid]&gt;nums[r]) l = mid + 1; else if(nums[mid]==nums[r]) r--; else r = mid; &#125; return nums[l];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序的三种实现]]></title>
    <url>%2Fposts%2F20940%2F</url>
    <content type="text"><![CDATA[冒泡排序介绍冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。 实现过程：设数组的长度为N：（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。（2）这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。（3）N=N-1，如果N不为0就重复前面二步，否则排序完成。 基本实现根据上述介绍，很快就能写出基本实现 123456789//最基本的冒泡public static void Sort1(int[] nums,int n)&#123; for(int i=0;i&lt;n;i++) for(int j=1;j&lt;n-i;j++) if(nums[j-1]&gt;nums[j]) swap(nums,j-1,j); &#125; 改进1考虑整个排序过程可以发现，如果一趟数据交换过程中没有出现一次数据交换，则可以认为数组已经有序了。 123456789101112131415161718//一点点改进 只要在一次冒泡中没有发生交换，则认为数组已经有序public static void Sort2(int[] nums,int n)&#123; boolean flag = true; int k = n; while(flag)&#123; flag = false; for(int j=1;j&lt;k;j++) if(nums[j-1]&gt;nums[j])&#123; swap(nums,j-1,j); flag = true; &#125; k--; &#125;&#125; 改进2同样考虑，如果在交换过程中，前面的数据发生了交换，而后面一部分数据没有发生交换（已经有序），那么在下一趟交换过程中，只要对前面的数据进行交换即可。 123456789101112131415161718//接着改进 当后面的元素已经有序了，也不需要再次排序了public static void Sort3(int[] nums,int n)&#123; int k = n; while(k&gt;0)&#123; int t = k; k = 0; for(int j=1;j&lt;t;j++) if(nums[j-1]&gt;nums[j])&#123; swap(nums,j-1,j); k = j; &#125; &#125;&#125; 参考链接：https://blog.csdn.net/u010853261/article/details/54891710]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的排列]]></title>
    <url>%2Fposts%2F3080%2F</url>
    <content type="text"><![CDATA[题目要求：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串(字典序)abc,acb,bac,bca,cab和cba。输入一个字符串,长度不超9(可能有字符重复),字符只包括大小写字母。 解决思路1-递归算法采用递归的方法，根据不同位置上字母的组合，先把结果保存在TreeSet中，这样既可以去掉重复的字符串，又可以保证字符串之间的字典顺序。 java代码1123456789101112131415161718192021222324252627282930313233343536TreeSet&lt;String&gt; t = new TreeSet&lt;&gt;(); boolean[] used = null; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); int len = str.length(); if(len == 0) return res; used = new boolean[len]; PermutationAux(str,len,0,new StringBuilder()); for(String tt : t) res.add(tt); return res; &#125; private void PermutationAux(String s,int n,int cnt,StringBuilder sb)&#123; if(sb.length() == n)&#123; t.add(sb.toString()); return; &#125; for(int i=0;i&lt;n;i++)&#123; if(!used[i])&#123; used[i] = true; sb.append(s.charAt(i)); PermutationAux(s,n,cnt+1,sb); sb.setLength(sb.length()-1); used[i] = false; &#125; &#125; &#125; 解决思路2-字典序排列算法一个全排列可看做一个字符串，字符串可有前缀、后缀。生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。 【例】 如何得到346987521的下一个1，从尾部往前找第一个P(i-1) &lt; P(i)的位置3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1最终找到6是第一个变小的数字，记录下6的位置i-1 2，从i位置往后找到最后一个大于6的数 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1最终找到7的位置，记录位置为m 3，交换位置i-1和m的值 3 4 7 9 8 6 5 2 14，倒序i位置后的所有数据 3 4 7 1 2 5 6 8 9则347125689为346987521的下一个排列 详情可以参考牛客网上@天天502关于这个揭发这个回答。 java代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); int len = str.length(); if(len == 0) return res; char[] ch = str.toCharArray(); Arrays.sort(ch); res.add(String.valueOf(ch)); while(true)&#123; int l = len-1; while(l&gt;0&amp;&amp;ch[l-1]&gt;=ch[l]) l--; if(l==0) break; int r = l; while(r&lt;len&amp;&amp;ch[r]&gt;ch[l-1]) r++; swap(ch,l-1,r-1); reverse(ch,l); res.add(String.valueOf(ch)); &#125; return res; &#125; private void reverse(char[] chars,int k)&#123; if(chars==null || chars.length&lt;=k) return; int len = chars.length; for(int i=0;i&lt;(len-k)/2;i++)&#123; int m = k+i; int n = len-1-i; if(m&lt;=n)&#123; swap(chars,m,n); &#125; &#125; &#125; private void swap(char[] cs,int i,int j)&#123; char temp = cs[i]; cs[i] = cs[j]; cs[j] = temp; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seckill]]></title>
    <url>%2Fposts%2F12142%2F</url>
    <content type="text"><![CDATA[仿照慕课网完成的一个基于SSM的秒杀项目写在前面刚开始学习SSM框架的使用，也看了一些相关的书籍，但也不是很明白。慕课网 上的这套视频讲的很基础，非常适合入门学习，再看完这套视频之后，想把这个过程记录一下，加深自己的理解。在这里也感谢慕课网@yijun zhang的分享的这门课程。 本次课程的开发环境是IDEA+Maven+SSM框架，一共分为四个模块： Java高并发秒杀APi之业务分析与DAO层 Java高并发秒杀APi之Service Java高并发秒杀APi之Web层 Java高并发秒杀APi之高并发优化 下面分别对这四个方面进行讨论。 Java高并发秒杀APi之业务分析与DAO层1.项目初始化采用Idea提供maven项目工程模板创建工程结构： 在porm.xml里修改项目需要的坐标配置信息,参考。 2.Dao层设计开发Dao是数据访问的缩写，它只进行数据的访问操作,不涉及逻辑业务首先创建数据库，相关表的sql语句查看参考。然后创建表对应的实体类，在org.seckill.entity包下创建Seckill.java和SuccessKilled.java。然后针对实体创建出对应dao层的接口，在org.seckill.dao包下创建SeckillDao.java和SuccessKilledDao.java,参考。这里需要说明的是我们所创建的Dao接口并不需要要我们手动去实现，而是采用MyBatis去实现。Mybatis提供了Mapper动态代理开发的方式为自动实现Dao的接口。MyBatis提供了两种方式去实现Dao接口XML文件配置和注解，本次项目我们采用XML文件配置。首先在resources包下创建MyBatis全局配置文件mybatis-config.xml文件，打开MyBatis提供的文档，点击左边的”入门”栏框，可以看到mybatis全局配置文件。在配置过程中，可以参考这个文档的一些内容去配置项目的mybatis-config.xml文件。接下来采用Mybatis提供的Mapper功能，实现Dao接口的开发，这里需要再次创建两个文件SeckillDao.xml和SuccessKilledDao.xml，参考。在这两个xml编写相应的SQL语句，这也是MyBatis的成功之处。 接下来要实现的是MyBatis和Spring的整合，整合目标:更少的编码:只写接口，不写实现类。更少的配置:别名、配置扫描映射xml文件、dao实现。足够的灵活性:自由定制SQL语句、自由传结果集自动赋值。在resources包下创建一个spring包，里面放置spring对Dao、Service、transaction的配置文件。在浏览器中输入进入到Spring的官网可以看到其官方文档,然后根据约定，编写Spring-dao.xml。 以上就基本完成了Dao层的开发，接下来就需要对写的代码进行单元测试，测试代码放在test包下，参考。 Java高并发秒杀APi之Service首先是Service接口的设计，这个接口里的应该是按照使用者的角度去编写，应该考虑到每个方法所返回的业务相关的对象，这个对象用于封装Ser和Web层之间的数据传递Dto层,dto和entity的区别在于:entity用于业务数据的封装，而dto用于完成web和service层的数据传递。另外还要整个秒杀过程中可能出现的异常，定义对应的异常处理类,这些异常一般都应该是RuntimeException。设计好接口之后，就应该对其进行实现。 接下来就需要利用Spring对Service进行处理，在spring包下创建一个spring-service.xml文件，采用注解(@Component @Service @Dao @Controller)的方式ji将刚才实现的Service实现类进行注入到Spring Ioc容器中。每个Service实现类采用( @Transactional)进行事务管理。 最好跟Dao层一样，利用Juit对Service层进行测试。 Java高并发秒杀APi之Web层Web层包含前端交互设计、Restful:url满足Restful设计规范、Spring MVC、bootstrap+jquery这四个方面的开发。 它的前端交互流程设计如下图: Restful是一种优雅的URI表述方式，用来设计访问URL。通过这个URL的设计，就可以很自然的感知到这个URL代表的是哪种业务场景或者什么样的数据或资源。基于Restful设计的URL，对于接口的使用者、前端、web系统或者搜索引擎甚至是我们的用户，都是非常友好的。下面看看这个秒杀系统的URL设计: 整合配置Spring MVC框架首先在WEB-INF的web.xml中进行我们前端控制器DispatcherServlet的配置,然后在spring容器中进行web层相关bean(即Controller)的配置，在spring包下创建一个spring-web.xml，这样就完成了Spring MVC的相关配置(即将Spring MVC框架整合到了我们的项目中)，接下来就要基于Restful接口进行项目的Controller开发工作了。Controller中的每一个方法都对应我们系统中的一个资源URL，其设计应该遵循Restful接口的设计风格。Controller开发中的方法完全是对照Service接口方法进行开发的，第一个方法用于访问我们商品的列表页，第二个方法访问商品的详情页，第三个方法用于返回一个json数据，数据中封装了我们商品的秒杀地址，第四个方法用于封装用户是否秒杀成功的信息，第五个方法用于返回系统当前时间。 接下来的工作主要就是页面开发，现在基本的趋势是前后端分离，所以了解一点即可。 做完了这三个层，已经可以进行展示了：运行Tomcat服务器,在浏览器中输入http://localhost:8080/seckill/list列表页： 详情页：再次秒杀会显示重复秒杀：]]></content>
      <categories>
        <category>ssm</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第51题 N-Queens]]></title>
    <url>%2Fposts%2F26372%2F</url>
    <content type="text"><![CDATA[N皇后问题是一个非常经典的问题，即如何能够在N*N的棋盘上放置N个皇后，使得任何一个皇后都无法直接吃掉其他的皇后。为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。注意仅当 N= 1 或N≥ 4 时问题有解。 这个问题依然可以用递归来解决。由于每一行只能放置一个皇后，所以可以尝试在从每一行的N个位置上尝试放置皇后，直到放满N个皇后。在尝试的过程中，维护三个数组表示该位置是否可以放置皇后，其中列用自身表示，主对角线上用横竖坐标的差表示，副对角线上用横竖坐标的和表示。 JAVA代码实现class Solution { boolean[] col = null; boolean[] dia1 = null; boolean[] dia2 = null; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) { col = new boolean[n]; dia1 = new boolean[2*n-1]; dia2 = new boolean[2*n-1]; dfs(n, 0, new ArrayList&lt;&gt;()); return res; } public void dfs(int n,int row,List&lt;Integer&gt; st) { if(row==n){ res.add(aux(n, st)); return; } for(int i=0;i&lt;n;i++){ if(!col[i]&amp;&amp;!dia1[row-i+n-1]&amp;&amp;!dia2[row+i]){ col[i] = true; dia1[row-i+n-1] = true; dia2[row+i] = true; st.add(i); dfs(n, row+1, st); st.remove(st.size()-1); col[i] = false; dia1[row-i+n-1] = false; dia2[row+i] = false; } } } public List&lt;String&gt; aux(int n,List&lt;Integer&gt; st) { char[] t = new char[n]; List&lt;String&gt; temp = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++) t[i] = &apos;.&apos;; for(int i=0;i&lt;n;i++){ int k = st.get(i); t[k] = &apos;Q&apos;; temp.add(String.valueOf(t)); t[k] = &apos;.&apos;; } return temp; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第77题 Combinations]]></title>
    <url>%2Fposts%2F11001%2F</url>
    <content type="text"><![CDATA[题目要求给定两个整数n和k，返回1 … n中所有可能的k个数的组合。 例如下图： 解题思路对于1到n个整数进行k个组合，可以这样构造一个递归树，对与 整数i来说，只要能从i到n中找到k-1个元素即可，在这个递归过程中记录递归结果，等记录到k个结果时，就返回。 JAVA代码class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { if(n&lt;=0||k&lt;=0||k&gt;n) return res; combineAux(n,k,1,new ArrayList&lt;Integer&gt;()); return res; } private void combineAux(int n,int k,int sta,List&lt;Integer&gt; t){ if(t.size()==k){ res.add(new ArrayList(t)); return; } for(int i = sta;i&lt;=n-(k-t.size())+1;i++){ t.add(i); combineAux(n,k,i+1,t); t.remove(t.size()-1); } } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第46题和第47题 全排列问题]]></title>
    <url>%2Fposts%2F49137%2F</url>
    <content type="text"><![CDATA[leetcode 第46题和第47题 都是求一个给定数组中的全排列问题，不同之处在于47题中数组的元素可以重复。 leetcode 第46题 解题思路这也是一个递归问题。对于数组中的每个元素，它的全排列就等于它本身加上除它以外所有的全排。所以只要这样依次计算全排列就行。 JAVA代码实现class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[] used = null; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { res.clear(); if(nums.length==0) return res; used = new boolean[nums.length]; permuteAux(nums,0, new ArrayList&lt;&gt;()); return res; } private void permuteAux(int[] nums,int index,List&lt;Integer&gt; st) { if(index == nums.length){ List&lt;Integer&gt; t = new ArrayList&lt;&gt;(st); res.add(t); return; } for(int i=0;i&lt;nums.length;i++){ if(used[i]) continue; st.add(nums[i]); used[i] = true; permuteAux(nums,index+1,st); used[i] = false; st.remove(st.size()-1); } return; } } leetcode 第47题 解题思路这也是一个递归问题。解题思路与46图题基本一致，但是却必须做出一些，改变，首先必须使得数组有序，在对数组中的每个元素进行全排列的时候，如果该元素与前一个元素相同，且前面一个元素已经完成了全排列，则跳过这个元素。 JAVA代码实现class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[] used = null; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { res.clear(); if(nums.length==0) return res; used = new boolean[nums.length]; Arrays.sort(nums); permuteAux(nums,0, new ArrayList&lt;&gt;()); return res; } private void permuteAux(int[] nums,int index,List&lt;Integer&gt; st) { if(index == nums.length){ List&lt;Integer&gt; t = new ArrayList&lt;&gt;(st); res.add(t); return; } for(int i=0;i&lt;nums.length;i++){ if(used[i]) continue; if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue; st.add(nums[i]); used[i] = true; permuteAux(nums,index+1,st); used[i] = false; st.remove(st.size()-1); } return; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第17题 Letter Combinations of a Phone Number]]></title>
    <url>%2Fposts%2F24625%2F</url>
    <content type="text"><![CDATA[题目要求给定一个数字字符串，返回数字可能表示的所有可能的字母组合。 数字到字母的映射（就像在电话按钮上一样）在下面给出。 例如： 输入字符串 “23”，输出结果为： “ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”。 解题思路这是一个典型的可以用递归解决的树形问题。对于每个数字，都分别代表了几个字母。组合在一起就变成了一个树。 JAVA代码实现class Solution { String[] aux = {&quot; &quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;}; List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) { res.clear(); if(digits.length()==0) return res; letterCombinationsAux(digits,0,&quot;&quot;); return res; } private void letterCombinationsAux(String d,int index,String s){ if(index==d.length()){ res.add(s); return ; } String t = aux[d.charAt(index)-&apos;0&apos;]; for(int i = 0;i&lt;t.length();i++) letterCombinationsAux(d,index+1,s+t.charAt(i)); return ; } } 原题地址：https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树（BST）的相关问题]]></title>
    <url>%2Fposts%2F8235%2F</url>
    <content type="text"><![CDATA[前言：在二叉搜索树中，对于每个结点，它的所有左子树结点的元素小于当前节点数据，所有右子树结点大于当前结点。二叉搜索树的三种常见操作：查找、删除、插入。 查找在查找操作中，就可以看到二叉搜索树的优势，它的时间复杂度为O(lg n). //查找 public TreeNode find(TreeNode root，int data){ if(root == null) return null; if(root.val&gt;data) return find(root.left,data); if(root.val&lt;data) return find(root.right,data); return root; } //查找最小值 public TreeNode findMin(TreeNode root){ if(root == null) return null; if(root.left==null) return root; return findMax(root.left); } //查找最大值 public TreeNode findMax(TreeNode root) { if(root==null) return null; if(root.right==null) return root; return findMax(root.right); } 插入：思路：首先找到要插入数据的位置，与查找类似。当找到这个位置后，如果数据已经存在，则直接返回即可，否则，将数据插入到走过的最后一个位置上。 public TreeNode insert(TreeNode root，int data){ if(root == null) { root = new TreeMode(data); root.left = null; root.right = null; } if(root.val&gt;data) root.left = insert(root.left,data); if(root.val&lt;data) root.right = insert(root.right,data); return root; } 删除： leetcode第450题 Delete Node in a BST思路：首先找到这个结点，然后删除这个结点即可。删除的过程中听注意：如果该节点的为叶子结点，直接删除结点；如果只有一个孩子结点，就用这个结点替代即可；如果该节点有两个结点，可以有两种做法：1，用左子树中最大的结点替换该节点，并在左子树中删除该最大节点。2、用右子树中最小的结点替换该节点，并在右子树中删除该最小节点。 java代码实现 class Solution { //考虑四种情况 public TreeNode deleteNode(TreeNode root, int key) { if(root ==null) return null; if(root.val&gt;key){ root.left = deleteNode(root.left, key); }else if(root.val&lt;key){ root.right = deleteNode(root.right,key); }else{ if(root.left!=null&amp;&amp;root.right!=null){ TreeNode t = findMax(root.left); root.val = t.val; root.left = deleteNode(root.left,t.val); }else{ if(root.left==null) root = root.right; else root = root.left; } } return root; } public TreeNode findMax(TreeNode root) { if(root==null) return null; if(root.right==null) return root; return findMax(root.right); } } 判断：leetcode第98题 Validate Binary Search Tree思路：只要保证当前节点的左子树中的最大值小于当前节点，右子树中的最小值大于当前节点的值。遍历整个树中的结点即可。这里我们会犯得的一个错误是，仅判断当前结点的左孩子结点小于当前结点，右孩子结点大于当前结点是不够的。原因就在于左子树中可能存在比当前结点大的值。右子树存在比当前结点小的值。 JAVA代码实现 class Solution { public boolean isValidBST(TreeNode root) { if(root ==null) return true; if(root.left!=null&amp;&amp;findMax(root.left).val &gt;=root.val) return false; if(root.right!=null&amp;&amp;findMin(root.right).val&lt;=root.val) return false; return isValidBST(root.left)&amp;&amp;isValidBST(root.right); } public TreeNode findMax(TreeNode root){ if(root == null) return null; if(root.right==null) return root; return findMax(root.right); } public TreeNode findMin(TreeNode root){ if(root == null) return null; if(root.left==null) return root; return findMax(root.left); } }]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第235题 和 第236 题：Lowest Common Ancestor]]></title>
    <url>%2Fposts%2F4885%2F</url>
    <content type="text"><![CDATA[前言：第235题 和 第236 题都是求解一棵树中两个结点最近公共祖先（LCA）问题，但是不同之处在于235给出的树为一棵二叉搜索树（BST），而236是一颗一般的二叉树，这样的话在235中利用BST的性质可以很方便的解决问题，但是在236中就必须全面考虑。一般而言，找一棵树的LCA可以分为三种情况：俩个结点分别在LCA的不同子树，两个结点中的一个就是LCA。 第235题 Lowest Common Ancestor of a Binary Search Tree思路：考虑到BST树的特殊结构：左子树中所有结点的值都比当前结点的值小，右子树中所有结点的值都比当前结点的值小。所以只要找到第一个结点的值的取值在给定的两个结点之间，这个结点就是要找的LCA。具体来说，就是尽量保证这两个结点在LCA的不同子树。 JAVA代码实现 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root==null) return null; if(p.val&lt;root.val&amp;&amp;q.val&lt;root.val) return lowestCommonAncestor(root.left, p, q); if(p.val&gt;root.val&amp;&amp;q.val&gt;root.val) return lowestCommonAncestor(root.right, p, q); return root; } } 第236题思路：对于一般的二叉树说，给定的两个结点出现的次数，出现的位置，都是不确定的甚至给定两个结点的值都可能是一样的。考虑到LCA出现的三种情况，当我们在递归的过程中，从根节点开始，只要遇到节点为空，结点为给定结点中的一个，就返回比较，如果在左子树和右子树中返回的结点都不为空，就返回当前结点，负责就返回不为空的那个。 JAVA代码实现 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null||root == q||root == p) return root; TreeNode l = lowestCommonAncestor(root.left, p, q); TreeNode r = lowestCommonAncestor(root.right, p, q); if(l!=null&amp;&amp;r!=null) return root; return l!=null?l:r; } } 注意：这两个题都有一个隐含条件：就是要查找的两个结点已经在树中包含，负责在查找之前，我们还要判断这两个结点是否在树中。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第19题 Remove Nth Node From End of List]]></title>
    <url>%2Fposts%2F50137%2F</url>
    <content type="text"><![CDATA[题目要求给定一个链表和一个整数n,移除链表的倒数第n个节点假设给定的整数n在链表的范围内。 解题思路如果先将链表遍历一遍，很容易移除数第n个元素。但是如果只能遍历一遍时，有一个很巧妙的办法是设置一个快指针，一个慢指针，当快节点到达链表末尾时，慢指针刚好到达倒数第n+1个节点。要实现这种思路，只要先将快指针移动n+1次，然后两个一起移动即可。 JAVA代码实现/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode pro = dummy; ListNode cur = dummy; for(int i=0;i&lt;n+1;i++) cur = cur.next; while(cur!=null){ cur = cur.next; pro = pro.next; } pro.next = pro.next.next; return dummy.next; } } 一点拓展：若个整数n的长度可以是任意的，就必须先计算除链表的长度，让后比较，进行相应的处理。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于链表的归并排序]]></title>
    <url>%2Fposts%2F47140%2F</url>
    <content type="text"><![CDATA[归并排序排序是一种常用的时间复杂度为O(n*lg n)的算法，它的基本想法是先对数据不断二分，然后对分开的每段数据进行合并，利用递归的思想，很容易完成排序。归并排序又分为自顶向下和自底向上两种实现方式，自顶向下实现起来比较简单，就是递归，对数据进行二分和合并。对与自底向上而言，，则需要考虑到每次归并元素的个数。这里要注意的是，对与每次归并来说，必须保证链表的完整性，不能出现链表断裂的情况。 JAVA代码实现1.自顶向下 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode sortList(ListNode head) { if(head==null||head.next==null) return head; ListNode pro =null; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null){ pro = slow; slow = slow.next; fast = fast.next.next; } pro.next = null; ListNode l1 = sortList(head); ListNode l2 = sortList(slow); return merge(l1,l2); } public ListNode merge(ListNode l1, ListNode l2) { if(l1==null) return l2; if(l2==null) return l1; ListNode dummy = new ListNode(0); ListNode cur = dummy; while(l1!=null||l2!=null){ int c1 = Integer.MAX_VALUE; int c2 = Integer.MAX_VALUE; if(l1!=null) c1 = l1.val; if(l2!=null) c2 = l2.val; if(c1&lt;c2){ cur.next = l1; cur = l1; l1 = l1.next; }else{ cur.next = l2; cur = l2; l2 = l2.next; } } return dummy.next; } } 2.自底向上 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode sortList(ListNode head) { if(head==null||head.next==null) return head; ListNode cur = head; int count = 0; while(cur!=null){ cur = cur.next; count++; } ListNode dummy = new ListNode(0); dummy.next = head; for(int step=1;step&lt;count;step +=step){ cur = dummy.next; ListNode left = null; ListNode right = null; ListNode end = dummy; while(cur!=null){ ListNode t = null; left = cur; for(int i=0;cur!=null&amp;i&lt;step;i++){ t = cur; cur = cur.next; } t.next = null; right = cur; //把end作为下一段代码开始的头节点 for(int i=0;cur!=null&amp;i&lt;step;i++){ t = cur; cur = cur.next; } t.next = null; end = merge(left,right,end); } } return dummy.next; } public ListNode merge(ListNode l1, ListNode l2,ListNode dummy) { if(l1==null){ dummy.next = l2; return null; } if(l2==null) { dummy.next = l1; return null; } ListNode cur = dummy; while(l1!=null||l2!=null){ int c1 = Integer.MAX_VALUE; int c2 = Integer.MAX_VALUE; if(l1!=null) c1 = l1.val; if(l2!=null) c2 = l2.val; if(c1&lt;c2){ cur.next = l1; cur = l1; l1 = l1.next; }else{ cur.next = l2; cur = l2; l2 = l2.next; } } return cur; } }]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于链表的插入排序]]></title>
    <url>%2Fposts%2F34037%2F</url>
    <content type="text"><![CDATA[插入排序的基本介绍插入排序的时间复杂度为O(n*n),但是在 给定数据近乎有序的情况下，它的时间复杂度可以接近O(n).它的基本思想是对于当前的节点。不断与该节点前面节点进行比较，直到它前面的数据小于它。如下图所示： 对元素2进行排序时，只要往前一直找，就可以将它插入合适的位置。插入排序基于数组很容易实现，原因在于我们可以很方便的找到每一个位置上的数据。但是链表不能这么做，原因在于很难直接去到每一个元素。结合链表的特点，我们可以设置一个虚拟的头节点，对于每一个节点，都要从该虚拟节点开始，一直到大于这个节点的数为止。 JAVA代码实现 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode insertionSortList(ListNode head) { if(head==null) return head; ListNode dummy = new ListNode(0); ListNode pro = dummy; ListNode cur = head; while(cur!=null){ ListNode nex = cur.next; while(pro.next!=null&amp;&amp;pro.next.val&lt;cur.val) pro = pro.next; cur.next = pro.next; pro.next = cur; pro = dummy; cur = nex; } return dummy.next; } }]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第149题 Max Points on a Line]]></title>
    <url>%2Fposts%2F33753%2F</url>
    <content type="text"><![CDATA[题目要求：给定2D平面上的n个点，找出位于同一条直线上的最大点数。 解决思路这个问题的一种方案是考虑两点之间斜率，把斜率相同的点放置在一个表中，再找到包含最多点的斜率。这个其中有两点需要关注，一个是点坐标的取值范围，一个是涉及斜率计算的问题。我的想法是对于每一个点，分别计算在它之后的所有不同点的斜率，并且用一个Map集合存起来，对于这个点，找出斜率最大的那个。考虑它的正确性，我们可以假设一种极端情况，即给定所有的点都在一条直线上，那么第一个点中肯定已经可以计算所要的结果，其他的点虽然能正常运行，但是同一个斜率得到结果肯定比第一个少。这里还要指出的是，斜率计算的问题，当横坐标相同时，用Integer.MAX_VALUE表示。考虑到Double运算可能会出现精度溢出情况，采用了BigDecimal类来计算精确结果。 java代码/** * Definition for a point. * class Point { * int x; * int y; * Point() { x = 0; y = 0; } * Point(int a, int b) { x = a; y = b; } * } */ class Solution { public int maxPoints(Point[] points) { int res = 1; if(points.length==0) return 0; for(int i =0;i&lt;points.length;i++){ HashMap&lt;Double,Integer&gt; hm = new HashMap&lt;&gt;(); hm.put((double) Integer.MIN_VALUE,1);//当points数组不空时，直线上必有一点 int de = 0; for(int j=i+1;j&lt;points.length;j++){ if((points[i].y==points[j].y)&amp;&amp;(points[i].x==points[j].x)){ de++; }else{ double tt = dis(points[i],points[j]); if(hm.containsKey(tt)) hm.put(tt,hm.get(tt)+1); else hm.put(tt,2); } } for(int re:hm.values()) res = Math.max(res, de+re); } return res; } public static double dis(Point p1, Point p2) { if((p1.x-p2.x)==0) return (double)Integer.MAX_VALUE; if(p1.y==p2.y) return 0; java.math.BigDecimal bd1 = new java.math.BigDecimal(Double.toString(p1.y-p2.y)); java.math.BigDecimal bd2 = new java.math.BigDecimal(Double.toString(p1.x-p2.x)); return bd1.divide (bd2,16,java.math.BigDecimal.ROUND_HALF_UP).doubleValue(); } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode Two Sum问题]]></title>
    <url>%2Fposts%2F56041%2F</url>
    <content type="text"><![CDATA[Two Sum I Two Sum II - Input array is sorted 第1题 Two Sum I题目要求: 给定一个整数数组，返回这两个数字的索引，使它们合计成一个特定的目标。限定条件：返回值为这两个数字的索引，索引从0开始假定每个输入都只有一个解，且不能使用相同的元素两次 解决思路由于数组有序，故采用对撞指针的方法。设置两个指针分别指向数组的头尾，当两个数的和大于给定的值时，右指针左移，小于时，左指针右移。这里需要注意的时，左指针必须小于右指针。 Java代码public int[] twoSum(int[] nums, int target) { int [] res = new int[2]; HashMap&lt;Integer,Integer&gt; tm = new HashMap&lt;&gt;(); for(int i =0;i&lt;nums.length;i++){ if(tm.containsKey(target - nums[i])){ res[0]=tm.get(target-nums[i]); res[1]=i; }else{ tm.put(nums[i],i); } } return res; } 第167题Two Sum II题目要求: 给定已按升序排序的整数数组，找到两个数字，使它们合计为特定的目标数字。 限定条件 返回值为这两个数字的索引，且该索引是从1开始 假定每个输入都只有一个解，且不能使用相同的元素两次 解决思路由于数组可能无序，且要返回的是元素的索引。所以我想到的办法是利用Set集合建立一个查找表，遍历整个数组，每次放入一个新元素时，在表中查找是否有target - nums[i]，如果存在则返回相应的索引，反之则继续遍历。 Java代码public int[] twoSum(int[] numbers, int target) { int[] arr = new int[2]; int l = 0,r = numbers.length-1; while(l&lt;r){ if(numbers[l]+numbers[r]&gt;target) r--; else if(numbers[l]+numbers[r]&lt;target) l++; else{ arr[0] = l+1; arr[1] = r+1; break; } } return arr; } 一些思考对比上述两个题目可以看出，需要解决的问题几乎一致，但是由于给定条件不一样，数组是否有序，导致解决问题的思路也不一样，一般来说，上述两种方法也是比较常见的。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode76题 Minimum Window Substring]]></title>
    <url>%2Fposts%2F45681%2F</url>
    <content type="text"><![CDATA[最小窗口子字符串 题目要求：给定一个字符串S和T，在S中找到一个包含T中所有字符的最短字串，时间复杂度为O(n).注1：如果这个窗口不存在，返回一个空字符串注2：该题保证在S中总是只有一个唯一的最小窗口 解决思路采用滑动窗口的方法，首先定义一个HashMap集合，用来记录T中字符出现的次数，同时定义一个计数变量来统计所得到的字符串是否包含T中所有的字符。具体做法为：当定义的滑动窗口的右指针不断向右滑动，找到包含T中所有字符的字串。然后通过控制窗口的滑动，尽可能的减少该字串的长度。 Java语言解决方案class Solution { public String minWindow(String s, String t) { if(s.length()&lt;t.length()) return &quot;&quot;; char[] ss = s.toCharArray(); char[] tt = t.toCharArray(); int count = t.length(); String res = &quot;&quot;; HashMap&lt;Character,Integer&gt; hm = new HashMap&lt;&gt;(); for(int i=0;i&lt;t.length();i++) if(hm.containsKey(tt[i])) hm.put(tt[i], hm.get(tt[i])+1); else hm.put(tt[i], 1); int l=0,r=0; while(r&lt;s.length()){ if(hm.containsKey(ss[r])){ if(hm.get(ss[r])&gt;0) count--; hm.put(ss[r], hm.get(ss[r])-1); } while(l&lt;=r&amp;&amp;count==0){ if(res.isEmpty()||res.length()&gt;(r-l+1)) res = s.substring(l,r+1); if(hm.containsKey(ss[l])){ hm.put(ss[l], hm.get(ss[l])+1); if(hm.get(ss[l])&gt;0) count++; } l++; } r++; } return res; } } 题目链接: https://leetcode.com/problems/minimum-window-substring/description/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法中时间复杂度分析]]></title>
    <url>%2Fposts%2F8713%2F</url>
    <content type="text"><![CDATA[算法的时间复杂度表示算法运行所需要的时间 大O表示法 递归算法中时间复杂度分析 大O表示法大O表示法 是一种体现算法时间复杂度的记法，如果用n表示数据规模，那么O(f(n)表示算法说需要执行的指令数(消耗的时间)和 f(n) 成正比。大O表示法指出了算法执行的最低上限。(大O表示法的前边省略了一个常数)。 例子：有一个字符数组，将数组中的每一个字符串按照字母排序，再将整个字符串数组按照字典序排序求这个算法的时间复杂度。分析：假设每个字符串的最大长度是s，字符数组中一共有n个字符串。* 对于一个字符串来说，进行排序的复杂度是O(s*log s),则整个字符数组的复杂度是O(n*slog s)\ 对于整个字符串数组排序的复杂度是O(n*log n)，而进行字典排序时每次最多进行s次比较，每次比较都是常数时间，所以复杂度是O(s*nlog n)\ 综上：整个算法的复杂度是O(s*n*(log n +log s) 常见的大O阶有常数阶O(1)，线性阶O(n)，平方阶O(n²)，对数阶O(logn)，nlogn阶O(nlogn)等等。如果有在有相同规模的n，则只保留最高阶，如O(n+n²) = O(n²)。 线性阶随数据规模n线性增长。如下面的代码： for(int i=0;i&lt;n;i++){ //时间复杂度为O(1)的算法 ... } 对数阶接着看如下代码： int number=1; while(number&lt;n){ number=number*2; //时间复杂度为O(1)的算法 ... } 可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。 平方阶下面的代码是循环嵌套： for(int i=0;i&lt;n;i++){ for(int j=i;j&lt;n;j++){ //复杂度为O(1)的算法 ... } } 需要注意的是内循环中int j=i，而不是int j=0。当i=0时，内循环执行了n次；i=1时内循环执行了n-1次，当i=n-1时执行了1次，我可以推算出总的执行次数为： n+(n-1)+(n-2)+(n-3)+……+1 = n²/2+n/2 只保留最高阶，因此保留n²/2，并且去掉这个项的常数，1/2,最终这段代码的时间复杂度为O(n²)。 注意：1.以下代码的复杂度仍为O(n)，原因是只进行了30*n次基本操作。 for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;30;j++){ //复杂度为O(1)的算法 ... } } 2.以下代码的复杂度仍为O(n*log n)。 for(int i=1;i&lt;n;i +=i){ for(int j=0;j&lt;n;j++){ //复杂度为O(1)的算法 ... } } 以上充分说明，应该时刻关注数据规模，而不是一些形式上的类似。 递归算法中时间复杂度分析递归中进行一次递归调用如下图所示，该二分查找只进行了一次递归调用。每次调用的复杂度为O(1),递归深度为O(log n),故整个算法的复杂度为O(log n)。 一般来说,在递归函数中只递归一次递归调用，总体的复杂度为O(每个递归函数的时间复杂度*递归深度) 递归中进行多次递归调用此时应该关注的是调用次数，如下面代码所示：此时可以通过数递归树上的节点。比如当n=3时，它的递归树如下图 右半侧，更一般的结论如左半侧所示。 又比如，在归并排序中，排序的数据规模都会减少一半，所以递归深度时log n，但是每层进行排序的数据规模都是n,所以时间复杂度是O(n*log n).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断链表成环，且找出环的起点]]></title>
    <url>%2Fposts%2F36499%2F</url>
    <content type="text"><![CDATA[判断链表成环，且找出环的起点。 判断链表成环 找出环的起点 Java代码实现 1. 判断链表是否成环 Floyd环判断法：从同一个起点同时开始以不同速度前进的2个指针最终相遇，那么可以判定存在一个环。 设想：乌龟和兔子在同一个环上赛跑，跑的快的兔子速度为2，跑的慢的乌龟速度为1，则兔子终会赶上乌龟。 理解：如果以乌龟为参考对象，则兔子前进的速度为1，这就意味着，兔子必将赶上乌龟。 所以一个判断成环的方法是：先舍子两个指针都指向表头，其中p1每次前进一个节点，p2每次前进两个节点，且p1和p2同时走，当p2指向的地址为null，就证明链表没有环。如果在某个时刻，p1和p2指向的地址相同，那么链表就是有环的。 2.找出环的起点同时可以进一步考虑：K1是等于零的，也就是p1在进入环后，走了不到一圈就在交点处和p2重合。因为p1在进入环的时候，p2和p1之间的距离（沿着行走方向）至多为 d2-1，不可能超过d2-1，因为环的大小也才只有d2 。p2追赶p1，最多只需要走d2-1步，因为每走一步，p1和p2的相对距离减小1，那么p1最多只走了d2-1步，就是最多只经过了d2-1个节点，不可能走完一圈。最后推出的式子的含义可以理解为：d1的长度 = 环长度的整数倍 + 交点与环入口的距离所以我们可以得出：当p1和p2相遇后，让p1回到原点，p2在相遇点，且两者每次都前进一个节点，当两者再次相遇时，就是环的起点。 3. Java代码实现int FindBeginLoop(ListNode head){ ListNode p1 = head, p2 = head; boolean loopExists = false; if(head == null) return false; //判断环是否存在 while(p2.getNext()!=null&amp;&amp;p2.getNext().getNext()!=null){ p1 = p1.getNext(); p2 = p2.getNext().getNext(); if(p1==p2) loopExists = true; break; } //如果环存在，寻找环的起点 if(loopExists){ p1 = head; while(p1!=p2){ p1 = p1.getNext(); p2 = p2.getNext(); } return p1; } return null; //不存在 } //附：定义的LitNode类 public class ListNode { private int data; private ListNode next; public ListNode(int data) { this.data = data; } public int getData() { return data; } public void setData(int data) { this.data = data; } public SingleListNode getNext() { return next; } public void setNext(SingleListNode next) { this.next = next; } } 参考http://www.cnblogs.com/snake-hand/p/3148328.html]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2Fposts%2F7251%2F</url>
    <content type="text"><![CDATA[搭建一个属于自己的博客 写在前面一直想搭建一个属于自己的博客，但都没有付诸行动，直到看见@嘟嘟独立博客所写的一列的hexo教程，终于开始动起来，花了一天的时间完成了这个过程。之后计划将自己以前写过的一些东西一点点搬运过来。 我的配置 hexo配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: 爱生活,爱柒柒 #网站标题subtitle: #网站副标题description: 且自前行，莫问归处！ #网站描述author: LI Ren #您的名字language: zh-Hans #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址## 如果您的网站存放在子目录中，##例如 http://yoursite.com/blog，##则将url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。url: https://myrens.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page## 修改归档页面、某一分类页面、某一标签页面的显示篇数## 参考：http://theme-next.iissnan.com/faqs.html#setting-page-sizearchive_generator: per_page: 10 yearly: false monthly: false daily: falsecategory_generator: per_page: 10tag_generator: per_page: 10 # Extensions## Plugins: https://hexo.io/plugins/# RSS，要先进入站点文件夹根目录安装插件# npm install hexo-generator-feed --save 即可# 无需更多配置# 参数说明查看 README：https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml# 文章数，0 为全部 limit: 0 hub:# 是否包含文章内容 content: true ##commnetdisqus_shortname: # MathJax Supportmathjax: enable: true cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML # Swiftype Search Keyswiftype_key: tLXWKdsstE5UZFCodRRQ # emoji 支持githubEmojis: enable: true idName: github-emoji unicode: false styles: localEmojis: # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:LLLRS/LLLRS.github.io.git,master next主题配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839# ===============================================================# ========================= ATTENTION! ==========================# ===============================================================# # Theme Core Configuration Settings# ---------------------------------------------------------------# Set to true, if you want to fully override the default configuration.# Useful if you don't want to inherit the theme _config.yml configurations.override: false# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# To get or check favicons visit: https://realfavicongenerator.net# Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.# Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.# And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.# 站点图标啦，直接去 https://realfavicongenerator.net# 选项弄好后，下载压缩包，解压复制粘贴# 建议放在 hexo-site/source/images/ 里（没有自己建）# 这样可以避免更新 NexT 主题的时候遇到麻烦# 最后记得要稍微改下文件名，与下面的保持一致favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg android_manifest: /images/manifest.json ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: "Hexo, NexT, Java, Spring, ssm"# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss:footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2015 # Icon between year and copyright info. icon: heart # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). # Hexo 的链接 powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.# 菜单设置 || 菜单图标设置（图标上面说了，不重复）# 项目换行可以更改显示顺序# 如果这个项前会显示 .menu# 解决方法：编辑 ~/blog/themes/next/languages 下的相应文件# 比如添加一个“留言”菜单，站点配置文件的 language 是 zh-Hans# 则编辑 zh-Hans.yml，在 menu: 项内添加一行 留言: 留言# 注意空格，且符号 : 为英文字符！menu: home: / || home archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/LLLRS|| github E-Mail: 15311257617@163.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true Github: github # Blog rollslinks_icon: linklinks_title: 友情链接links_layout: block#links_layout: inlinelinks: 嘟嘟独立博客: http://tengj.top/ crossoverjie: https://crossoverjie.top/ # Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gif#avatar: /images/avatar.gif# 侧栏头像设置# 圆形以及旋转效果在本文 4.2 节的代码里# 点击回到博客首页教程见本文 5.13 节# 建议放在 hexo-site/source/uploads/ 里（没有自己建）# 这样可以避免更新 NexT 主题的时候遇到麻烦avatar: /uploads/logo.jpeg# Table Of Contents in the Sidebar# 侧栏文章目录设置（前提是 Markdown 书写正确）toc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: true# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: true # Enable sidebar on narrow view (only for Muse | Mist). onmobile: true# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically saving scroll position on each post/page in cookies.save_scroll: false# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcount# 显示统计字数和估计阅读时长# 注意：这个要安装插件，先进入站点文件夹根目录# 然后：npm install hexo-wordcount --savepost_wordcount: item_text: true wordcount: true min2read: false totalcount: false separated_meta: false# Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg #description: ex. subscribe to my blog by scanning my public wechat account# Rewardreward_comment: 欢迎一起进行交流！wechatpay: /images/wechat.jpg#alipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($black-deep).android_chrome_color: "#222"# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: https://fonts.cat.net # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Lato size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: Roboto Slab size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: Roboto Mono size:# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML# Han Support docs: https://hanzi.pro/han: false# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortName#duoshuo_shortname:# Disqusdisqus: enable: false shortname: count: true# Hypercomments#hypercomments_id:# changyanchangyan: enable: false appid: appkey:# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.org# app_id: oilMyKSMaPtFHPbgcbiCfJL6-gzGzoHsz# app_key: oUBvV1jEzR3mJ3RvgWoHex8G valine: enable: true appid: oilMyKSMaPtFHPbgcbiCfJL6-gzGzoHsz appkey: oUBvV1jEzR3mJ3RvgWoHex8G notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# Share#duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: true postbottom: enable: true options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Bing Webmaster tools verification setting# See: https://www.bing.com/webmaster/#bing_site_verification:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: false admin_enable: false user_id: 0 #admin_nickname: Author# Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# ---------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.# 可以显示每篇文章的阅读量# 然后可以通过阅读量建立 TopX 页面，教程链接：# https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.htmlleancloud_visitors: enable: true app_id: oilMyKSMaPtFHPbgcbiCfJL6-gzGzoHsz app_key: oUBvV1jEzR3mJ3RvgWoHex8G# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/# 不蒜子统计，用于在页脚显示总访客数和总浏览量，将 false 改为 true 就能直接使用busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: false # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: false# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: true transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: fadeIn post_body: fadeIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancyboxfancybox: true# Progress bar in the top during page loading.# 页面顶部加载条pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-flash# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ # 自定义 fancybox（暂时） fancybox: https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js fancybox_css: https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: https://cdnjs.cloudflare.com/ajax/libs/UAParser.js/0.7.9/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.4 致谢感谢嘟嘟独立博客。感谢reuixiy,这篇文章记录的十分详细。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
