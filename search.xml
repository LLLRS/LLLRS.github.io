<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[旋转数组的最小数字]]></title>
    <url>%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[旋转数组的最小数字题目要求把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路采用二分法解答这个问题，mid = l + (r - l)/2需要考虑三种情况：(1)nums[mid] &gt; nums[r]:&#8195;出现这种情况的nums类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 (2)nums[mid] == nums[r]:&#8195;出现这种情况的nums类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 。(3)nums[mid] &lt; nums[r]:&#8195;出现这种情况的nums类似[2,2,3,4,5,6,6],此时最小数字一定就是nums[mid]或者在mid的左边。因为右边必然都是递增的。 Java实现12345678910111213141516171819public int minNumberInRotatenums(int [] nums) &#123; int len = nums.length; if(len==0) return 0; int l = 0; int r = len-1; while(l&lt;r)&#123; int mid = l + (r-l)/2; if(nums[mid]&gt;nums[r]) l = mid + 1; else if(nums[mid]==nums[r]) r--; else r = mid; &#125; return nums[l];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序的三种实现]]></title>
    <url>%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[冒泡排序的三种实现冒泡排序介绍冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。 实现过程：设数组的长度为N：（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。（2）这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。（3）N=N-1，如果N不为0就重复前面二步，否则排序完成。 基本实现根据上述介绍，很快就能写出基本实现 123456789//最基本的冒泡public static void Sort1(int[] nums,int n)&#123; for(int i=0;i&lt;n;i++) for(int j=1;j&lt;n-i;j++) if(nums[j-1]&gt;nums[j]) swap(nums,j-1,j); &#125; 改进1考虑整个排序过程可以发现，如果一趟数据交换过程中没有出现一次数据交换，则可以认为数组已经有序了。 123456789101112131415161718//一点点改进 只要在一次冒泡中没有发生交换，则认为数组已经有序public static void Sort2(int[] nums,int n)&#123; boolean flag = true; int k = n; while(flag)&#123; flag = false; for(int j=1;j&lt;k;j++) if(nums[j-1]&gt;nums[j])&#123; swap(nums,j-1,j); flag = true; &#125; k--; &#125;&#125; 改进2同样考虑，如果在交换过程中，前面的数据发生了交换，而后面一部分数据没有发生交换（已经有序），那么在下一趟交换过程中，只要对前面的数据进行交换即可。 123456789101112131415161718//接着改进 当后面的元素已经有序了，也不需要再次排序了public static void Sort3(int[] nums,int n)&#123; int k = n; while(k&gt;0)&#123; int t = k; k = 0; for(int j=1;j&lt;t;j++) if(nums[j-1]&gt;nums[j])&#123; swap(nums,j-1,j); k = j; &#125; &#125;&#125; 参考链接：https://blog.csdn.net/u010853261/article/details/54891710]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的排列]]></title>
    <url>%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.html</url>
    <content type="text"><![CDATA[题目要求：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串(字典序)abc,acb,bac,bca,cab和cba。输入一个字符串,长度不超9(可能有字符重复),字符只包括大小写字母。 解决思路1-递归算法采用递归的方法，根据不同位置上字母的组合，先把结果保存在TreeSet中，这样既可以去掉重复的字符串，又可以保证字符串之间的字典顺序。 java代码1123456789101112131415161718192021222324252627282930313233343536TreeSet&lt;String&gt; t = new TreeSet&lt;&gt;(); boolean[] used = null; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); int len = str.length(); if(len == 0) return res; used = new boolean[len]; PermutationAux(str,len,0,new StringBuilder()); for(String tt : t) res.add(tt); return res; &#125; private void PermutationAux(String s,int n,int cnt,StringBuilder sb)&#123; if(sb.length() == n)&#123; t.add(sb.toString()); return; &#125; for(int i=0;i&lt;n;i++)&#123; if(!used[i])&#123; used[i] = true; sb.append(s.charAt(i)); PermutationAux(s,n,cnt+1,sb); sb.setLength(sb.length()-1); used[i] = false; &#125; &#125; &#125; 解决思路2-字典序排列算法一个全排列可看做一个字符串，字符串可有前缀、后缀。生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。 【例】 如何得到346987521的下一个1，从尾部往前找第一个P(i-1) &lt; P(i)的位置3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1最终找到6是第一个变小的数字，记录下6的位置i-1 2，从i位置往后找到最后一个大于6的数 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1最终找到7的位置，记录位置为m 3，交换位置i-1和m的值 3 4 7 9 8 6 5 2 14，倒序i位置后的所有数据 3 4 7 1 2 5 6 8 9则347125689为346987521的下一个排列 详情可以参考牛客网上@天天502关于这个揭发这个回答。 java代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); int len = str.length(); if(len == 0) return res; char[] ch = str.toCharArray(); Arrays.sort(ch); res.add(String.valueOf(ch)); while(true)&#123; int l = len-1; while(l&gt;0&amp;&amp;ch[l-1]&gt;=ch[l]) l--; if(l==0) break; int r = l; while(r&lt;len&amp;&amp;ch[r]&gt;ch[l-1]) r++; swap(ch,l-1,r-1); reverse(ch,l); res.add(String.valueOf(ch)); &#125; return res; &#125; private void reverse(char[] chars,int k)&#123; if(chars==null || chars.length&lt;=k) return; int len = chars.length; for(int i=0;i&lt;(len-k)/2;i++)&#123; int m = k+i; int n = len-1-i; if(m&lt;=n)&#123; swap(chars,m,n); &#125; &#125; &#125; private void swap(char[] cs,int i,int j)&#123; char temp = cs[i]; cs[i] = cs[j]; cs[j] = temp; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seckill]]></title>
    <url>%2Fseckill.html</url>
    <content type="text"><![CDATA[仿照慕课网完成的一个基于SSM的秒杀项目写在前面刚开始学习SSM框架的使用，也看了一些相关的书籍，但也不是很明白。慕课网 上的这套视频讲的很基础，非常适合入门学习，再看完这套视频之后，想把这个过程记录一下，加深自己的理解。在这里也感谢慕课网@yijun zhang的分享的这门课程。 本次课程的开发环境是IDEA+Maven+SSM框架，一共分为四个模块： Java高并发秒杀APi之业务分析与DAO层 Java高并发秒杀APi之Service Java高并发秒杀APi之Web层 Java高并发秒杀APi之高并发优化 下面分别对这四个方面进行讨论。 Java高并发秒杀APi之业务分析与DAO层1.项目初始化采用Idea提供maven项目工程模板创建工程结构： 在porm.xml里修改项目需要的坐标配置信息,参考。 2.Dao层设计开发Dao是数据访问的缩写，它只进行数据的访问操作,不涉及逻辑业务首先创建数据库，相关表的sql语句查看参考。然后创建表对应的实体类，在org.seckill.entity包下创建Seckill.java和SuccessKilled.java。然后针对实体创建出对应dao层的接口，在org.seckill.dao包下创建SeckillDao.java和SuccessKilledDao.java,参考。这里需要说明的是我们所创建的Dao接口并不需要要我们手动去实现，而是采用MyBatis去实现。Mybatis提供了Mapper动态代理开发的方式为自动实现Dao的接口。MyBatis提供了两种方式去实现Dao接口XML文件配置和注解，本次项目我们采用XML文件配置。首先在resources包下创建MyBatis全局配置文件mybatis-config.xml文件，打开MyBatis提供的文档，点击左边的”入门”栏框，可以看到mybatis全局配置文件。在配置过程中，可以参考这个文档的一些内容去配置项目的mybatis-config.xml文件。接下来采用Mybatis提供的Mapper功能，实现Dao接口的开发，这里需要再次创建两个文件SeckillDao.xml和SuccessKilledDao.xml，参考。在这两个xml编写相应的SQL语句，这也是MyBatis的成功之处。 接下来要实现的是MyBatis和Spring的整合，整合目标:更少的编码:只写接口，不写实现类。更少的配置:别名、配置扫描映射xml文件、dao实现。足够的灵活性:自由定制SQL语句、自由传结果集自动赋值。在resources包下创建一个spring包，里面放置spring对Dao、Service、transaction的配置文件。在浏览器中输入进入到Spring的官网可以看到其官方文档,然后根据约定，编写Spring-dao.xml。 以上就基本完成了Dao层的开发，接下来就需要对写的代码进行单元测试，测试代码放在test包下，参考。 Java高并发秒杀APi之Service首先是Service接口的设计，这个接口里的应该是按照使用者的角度去编写，应该考虑到每个方法所返回的业务相关的对象，这个对象用于封装Ser和Web层之间的数据传递Dto层,dto和entity的区别在于:entity用于业务数据的封装，而dto用于完成web和service层的数据传递。另外还要整个秒杀过程中可能出现的异常，定义对应的异常处理类,这些异常一般都应该是RuntimeException。设计好接口之后，就应该对其进行实现。 接下来就需要利用Spring对Service进行处理，在spring包下创建一个spring-service.xml文件，采用注解(@Component @Service @Dao @Controller)的方式ji将刚才实现的Service实现类进行注入到Spring Ioc容器中。每个Service实现类采用( @Transactional)进行事务管理。 最好跟Dao层一样，利用Juit对Service层进行测试。 Java高并发秒杀APi之Web层Web层包含前端交互设计、Restful:url满足Restful设计规范、Spring MVC、bootstrap+jquery这四个方面的开发。 它的前端交互流程设计如下图: Restful是一种优雅的URI表述方式，用来设计访问URL。通过这个URL的设计，就可以很自然的感知到这个URL代表的是哪种业务场景或者什么样的数据或资源。基于Restful设计的URL，对于接口的使用者、前端、web系统或者搜索引擎甚至是我们的用户，都是非常友好的。下面看看这个秒杀系统的URL设计: 整合配置Spring MVC框架首先在WEB-INF的web.xml中进行我们前端控制器DispatcherServlet的配置,然后在spring容器中进行web层相关bean(即Controller)的配置，在spring包下创建一个spring-web.xml，这样就完成了Spring MVC的相关配置(即将Spring MVC框架整合到了我们的项目中)，接下来就要基于Restful接口进行项目的Controller开发工作了。Controller中的每一个方法都对应我们系统中的一个资源URL，其设计应该遵循Restful接口的设计风格。Controller开发中的方法完全是对照Service接口方法进行开发的，第一个方法用于访问我们商品的列表页，第二个方法访问商品的详情页，第三个方法用于返回一个json数据，数据中封装了我们商品的秒杀地址，第四个方法用于封装用户是否秒杀成功的信息，第五个方法用于返回系统当前时间。 接下来的工作主要就是页面开发，现在基本的趋势是前后端分离，所以了解一点即可。 做完了这三个层，已经可以进行展示了：运行Tomcat服务器,在浏览器中输入http://localhost:8080/seckill/list列表页： 详情页：再次秒杀会显示重复秒杀：]]></content>
      <categories>
        <category>ssm</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第51题 N-Queens]]></title>
    <url>%2Fleetcode%20%E7%AC%AC51%E9%A2%98%20%20N-Queens.html</url>
    <content type="text"><![CDATA[N皇后问题是一个非常经典的问题，即如何能够在N*N的棋盘上放置N个皇后，使得任何一个皇后都无法直接吃掉其他的皇后。为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。注意仅当 N= 1 或N≥ 4 时问题有解。 这个问题依然可以用递归来解决。由于每一行只能放置一个皇后，所以可以尝试在从每一行的N个位置上尝试放置皇后，直到放满N个皇后。在尝试的过程中，维护三个数组表示该位置是否可以放置皇后，其中列用自身表示，主对角线上用横竖坐标的差表示，副对角线上用横竖坐标的和表示。 JAVA代码实现class Solution { boolean[] col = null; boolean[] dia1 = null; boolean[] dia2 = null; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) { col = new boolean[n]; dia1 = new boolean[2*n-1]; dia2 = new boolean[2*n-1]; dfs(n, 0, new ArrayList&lt;&gt;()); return res; } public void dfs(int n,int row,List&lt;Integer&gt; st) { if(row==n){ res.add(aux(n, st)); return; } for(int i=0;i&lt;n;i++){ if(!col[i]&amp;&amp;!dia1[row-i+n-1]&amp;&amp;!dia2[row+i]){ col[i] = true; dia1[row-i+n-1] = true; dia2[row+i] = true; st.add(i); dfs(n, row+1, st); st.remove(st.size()-1); col[i] = false; dia1[row-i+n-1] = false; dia2[row+i] = false; } } } public List&lt;String&gt; aux(int n,List&lt;Integer&gt; st) { char[] t = new char[n]; List&lt;String&gt; temp = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++) t[i] = &apos;.&apos;; for(int i=0;i&lt;n;i++){ int k = st.get(i); t[k] = &apos;Q&apos;; temp.add(String.valueOf(t)); t[k] = &apos;.&apos;; } return temp; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第77题 Combinations]]></title>
    <url>%2Fleetcode%20%E7%AC%AC77%E9%A2%98%20Combinations.html</url>
    <content type="text"><![CDATA[题目要求给定两个整数n和k，返回1 … n中所有可能的k个数的组合。 例如下图： 解题思路对于1到n个整数进行k个组合，可以这样构造一个递归树，对与 整数i来说，只要能从i到n中找到k-1个元素即可，在这个递归过程中记录递归结果，等记录到k个结果时，就返回。 JAVA代码class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { if(n&lt;=0||k&lt;=0||k&gt;n) return res; combineAux(n,k,1,new ArrayList&lt;Integer&gt;()); return res; } private void combineAux(int n,int k,int sta,List&lt;Integer&gt; t){ if(t.size()==k){ res.add(new ArrayList(t)); return; } for(int i = sta;i&lt;=n-(k-t.size())+1;i++){ t.add(i); combineAux(n,k,i+1,t); t.remove(t.size()-1); } } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第46题和第47题 全排列问题]]></title>
    <url>%2Fleetcode%20%E7%AC%AC46%E9%A2%98%E5%92%8C%E7%AC%AC47%E9%A2%98%20%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[leetcode 第46题和第47题 都是求一个给定数组中的全排列问题，不同之处在于47题中数组的元素可以重复。 leetcode 第46题 解题思路这也是一个递归问题。对于数组中的每个元素，它的全排列就等于它本身加上除它以外所有的全排。所以只要这样依次计算全排列就行。 JAVA代码实现class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[] used = null; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { res.clear(); if(nums.length==0) return res; used = new boolean[nums.length]; permuteAux(nums,0, new ArrayList&lt;&gt;()); return res; } private void permuteAux(int[] nums,int index,List&lt;Integer&gt; st) { if(index == nums.length){ List&lt;Integer&gt; t = new ArrayList&lt;&gt;(st); res.add(t); return; } for(int i=0;i&lt;nums.length;i++){ if(used[i]) continue; st.add(nums[i]); used[i] = true; permuteAux(nums,index+1,st); used[i] = false; st.remove(st.size()-1); } return; } } leetcode 第47题 解题思路这也是一个递归问题。解题思路与46图题基本一致，但是却必须做出一些，改变，首先必须使得数组有序，在对数组中的每个元素进行全排列的时候，如果该元素与前一个元素相同，且前面一个元素已经完成了全排列，则跳过这个元素。 JAVA代码实现class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[] used = null; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { res.clear(); if(nums.length==0) return res; used = new boolean[nums.length]; Arrays.sort(nums); permuteAux(nums,0, new ArrayList&lt;&gt;()); return res; } private void permuteAux(int[] nums,int index,List&lt;Integer&gt; st) { if(index == nums.length){ List&lt;Integer&gt; t = new ArrayList&lt;&gt;(st); res.add(t); return; } for(int i=0;i&lt;nums.length;i++){ if(used[i]) continue; if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue; st.add(nums[i]); used[i] = true; permuteAux(nums,index+1,st); used[i] = false; st.remove(st.size()-1); } return; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第17题 Letter Combinations of a Phone Number]]></title>
    <url>%2Fleetcode%20%E7%AC%AC17%E9%A2%98%20Letter%20Combinations%20of%20a%20Phone%20Number.html</url>
    <content type="text"><![CDATA[题目要求给定一个数字字符串，返回数字可能表示的所有可能的字母组合。 数字到字母的映射（就像在电话按钮上一样）在下面给出。 例如： 输入字符串 “23”，输出结果为： “ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”。 解题思路这是一个典型的可以用递归解决的树形问题。对于每个数字，都分别代表了几个字母。组合在一起就变成了一个树。 JAVA代码实现class Solution { String[] aux = {&quot; &quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;}; List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) { res.clear(); if(digits.length()==0) return res; letterCombinationsAux(digits,0,&quot;&quot;); return res; } private void letterCombinationsAux(String d,int index,String s){ if(index==d.length()){ res.add(s); return ; } String t = aux[d.charAt(index)-&apos;0&apos;]; for(int i = 0;i&lt;t.length();i++) letterCombinationsAux(d,index+1,s+t.charAt(i)); return ; } } 原题地址：https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树（BST）的相关问题]]></title>
    <url>%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%89%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[前言：在二叉搜索树中，对于每个结点，它的所有左子树结点的元素小于当前节点数据，所有右子树结点大于当前结点。二叉搜索树的三种常见操作：查找、删除、插入。 查找在查找操作中，就可以看到二叉搜索树的优势，它的时间复杂度为O(lg n). //查找 public TreeNode find(TreeNode root，int data){ if(root == null) return null; if(root.val&gt;data) return find(root.left,data); if(root.val&lt;data) return find(root.right,data); return root; } //查找最小值 public TreeNode findMin(TreeNode root){ if(root == null) return null; if(root.left==null) return root; return findMax(root.left); } //查找最大值 public TreeNode findMax(TreeNode root) { if(root==null) return null; if(root.right==null) return root; return findMax(root.right); } 插入：思路：首先找到要插入数据的位置，与查找类似。当找到这个位置后，如果数据已经存在，则直接返回即可，否则，将数据插入到走过的最后一个位置上。 public TreeNode insert(TreeNode root，int data){ if(root == null) { root = new TreeMode(data); root.left = null; root.right = null; } if(root.val&gt;data) root.left = insert(root.left,data); if(root.val&lt;data) root.right = insert(root.right,data); return root; } 删除： leetcode第450题 Delete Node in a BST思路：首先找到这个结点，然后删除这个结点即可。删除的过程中听注意：如果该节点的为叶子结点，直接删除结点；如果只有一个孩子结点，就用这个结点替代即可；如果该节点有两个结点，可以有两种做法：1，用左子树中最大的结点替换该节点，并在左子树中删除该最大节点。2、用右子树中最小的结点替换该节点，并在右子树中删除该最小节点。 java代码实现 class Solution { //考虑四种情况 public TreeNode deleteNode(TreeNode root, int key) { if(root ==null) return null; if(root.val&gt;key){ root.left = deleteNode(root.left, key); }else if(root.val&lt;key){ root.right = deleteNode(root.right,key); }else{ if(root.left!=null&amp;&amp;root.right!=null){ TreeNode t = findMax(root.left); root.val = t.val; root.left = deleteNode(root.left,t.val); }else{ if(root.left==null) root = root.right; else root = root.left; } } return root; } public TreeNode findMax(TreeNode root) { if(root==null) return null; if(root.right==null) return root; return findMax(root.right); } } 判断：leetcode第98题 Validate Binary Search Tree思路：只要保证当前节点的左子树中的最大值小于当前节点，右子树中的最小值大于当前节点的值。遍历整个树中的结点即可。这里我们会犯得的一个错误是，仅判断当前结点的左孩子结点小于当前结点，右孩子结点大于当前结点是不够的。原因就在于左子树中可能存在比当前结点大的值。右子树存在比当前结点小的值。 JAVA代码实现 class Solution { public boolean isValidBST(TreeNode root) { if(root ==null) return true; if(root.left!=null&amp;&amp;findMax(root.left).val &gt;=root.val) return false; if(root.right!=null&amp;&amp;findMin(root.right).val&lt;=root.val) return false; return isValidBST(root.left)&amp;&amp;isValidBST(root.right); } public TreeNode findMax(TreeNode root){ if(root == null) return null; if(root.right==null) return root; return findMax(root.right); } public TreeNode findMin(TreeNode root){ if(root == null) return null; if(root.left==null) return root; return findMax(root.left); } }]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第235题 和 第236 题：Lowest Common Ancestor]]></title>
    <url>%2Fleetcode%20%E7%AC%AC235%E9%A2%98%20%E5%92%8C%20%E7%AC%AC236%20%E9%A2%98%EF%BC%9ALowest%20Common%20Ancestor.html</url>
    <content type="text"><![CDATA[前言：第235题 和 第236 题都是求解一棵树中两个结点最近公共祖先（LCA）问题，但是不同之处在于235给出的树为一棵二叉搜索树（BST），而236是一颗一般的二叉树，这样的话在235中利用BST的性质可以很方便的解决问题，但是在236中就必须全面考虑。一般而言，找一棵树的LCA可以分为三种情况：俩个结点分别在LCA的不同子树，两个结点中的一个就是LCA。 第235题 Lowest Common Ancestor of a Binary Search Tree思路：考虑到BST树的特殊结构：左子树中所有结点的值都比当前结点的值小，右子树中所有结点的值都比当前结点的值小。所以只要找到第一个结点的值的取值在给定的两个结点之间，这个结点就是要找的LCA。具体来说，就是尽量保证这两个结点在LCA的不同子树。 JAVA代码实现 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root==null) return null; if(p.val&lt;root.val&amp;&amp;q.val&lt;root.val) return lowestCommonAncestor(root.left, p, q); if(p.val&gt;root.val&amp;&amp;q.val&gt;root.val) return lowestCommonAncestor(root.right, p, q); return root; } } 第236题思路：对于一般的二叉树说，给定的两个结点出现的次数，出现的位置，都是不确定的甚至给定两个结点的值都可能是一样的。考虑到LCA出现的三种情况，当我们在递归的过程中，从根节点开始，只要遇到节点为空，结点为给定结点中的一个，就返回比较，如果在左子树和右子树中返回的结点都不为空，就返回当前结点，负责就返回不为空的那个。 JAVA代码实现 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null||root == q||root == p) return root; TreeNode l = lowestCommonAncestor(root.left, p, q); TreeNode r = lowestCommonAncestor(root.right, p, q); if(l!=null&amp;&amp;r!=null) return root; return l!=null?l:r; } } 注意：这两个题都有一个隐含条件：就是要查找的两个结点已经在树中包含，负责在查找之前，我们还要判断这两个结点是否在树中。]]></content>
      <categories>
        <category>leetcode 数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第19题 Remove Nth Node From End of List]]></title>
    <url>%2Fleetcode%20%E7%AC%AC19%E9%A2%98%20Remove%20Nth%20Node%20From%20End%20of%20List.html</url>
    <content type="text"><![CDATA[题目要求给定一个链表和一个整数n,移除链表的倒数第n个节点假设给定的整数n在链表的范围内。 解题思路如果先将链表遍历一遍，很容易移除数第n个元素。但是如果只能遍历一遍时，有一个很巧妙的办法是设置一个快指针，一个慢指针，当快节点到达链表末尾时，慢指针刚好到达倒数第n+1个节点。要实现这种思路，只要先将快指针移动n+1次，然后两个一起移动即可。 JAVA代码实现/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode pro = dummy; ListNode cur = dummy; for(int i=0;i&lt;n+1;i++) cur = cur.next; while(cur!=null){ cur = cur.next; pro = pro.next; } pro.next = pro.next.next; return dummy.next; } } 一点拓展：若个整数n的长度可以是任意的，就必须先计算除链表的长度，让后比较，进行相应的处理。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于链表的归并排序]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[归并排序基本介绍归并排序排序是一种常用的时间复杂度为O(n*lg n)的算法，它的基本想法是先对数据不断二分，然后对分开的每段数据进行合并，利用递归的思想，很容易完成排序。归并排序又分为自顶向下和自底向上两种实现方式，自顶向下实现起来比较简单，就是递归，对数据进行二分和合并。对与自底向上而言，，则需要考虑到每次归并元素的个数。这里要注意的是，对与每次归并来说，必须保证链表的完整性，不能出现链表断裂的情况。 JAVA代码实现1.自顶向下 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode sortList(ListNode head) { if(head==null||head.next==null) return head; ListNode pro =null; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null){ pro = slow; slow = slow.next; fast = fast.next.next; } pro.next = null; ListNode l1 = sortList(head); ListNode l2 = sortList(slow); return merge(l1,l2); } public ListNode merge(ListNode l1, ListNode l2) { if(l1==null) return l2; if(l2==null) return l1; ListNode dummy = new ListNode(0); ListNode cur = dummy; while(l1!=null||l2!=null){ int c1 = Integer.MAX_VALUE; int c2 = Integer.MAX_VALUE; if(l1!=null) c1 = l1.val; if(l2!=null) c2 = l2.val; if(c1&lt;c2){ cur.next = l1; cur = l1; l1 = l1.next; }else{ cur.next = l2; cur = l2; l2 = l2.next; } } return dummy.next; } } 2.自底向上 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode sortList(ListNode head) { if(head==null||head.next==null) return head; ListNode cur = head; int count = 0; while(cur!=null){ cur = cur.next; count++; } ListNode dummy = new ListNode(0); dummy.next = head; for(int step=1;step&lt;count;step +=step){ cur = dummy.next; ListNode left = null; ListNode right = null; ListNode end = dummy; while(cur!=null){ ListNode t = null; left = cur; for(int i=0;cur!=null&amp;i&lt;step;i++){ t = cur; cur = cur.next; } t.next = null; right = cur; //把end作为下一段代码开始的头节点 for(int i=0;cur!=null&amp;i&lt;step;i++){ t = cur; cur = cur.next; } t.next = null; end = merge(left,right,end); } } return dummy.next; } public ListNode merge(ListNode l1, ListNode l2,ListNode dummy) { if(l1==null){ dummy.next = l2; return null; } if(l2==null) { dummy.next = l1; return null; } ListNode cur = dummy; while(l1!=null||l2!=null){ int c1 = Integer.MAX_VALUE; int c2 = Integer.MAX_VALUE; if(l1!=null) c1 = l1.val; if(l2!=null) c2 = l2.val; if(c1&lt;c2){ cur.next = l1; cur = l1; l1 = l1.next; }else{ cur.next = l2; cur = l2; l2 = l2.next; } } return cur; } }]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于链表的插入排序]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[插入排序的基本介绍插入排序的时间复杂度为O(n*n),但是在 给定数据近乎有序的情况下，它的时间复杂度可以接近O(n).它的基本思想是对于当前的节点。不断与该节点前面节点进行比较，直到它前面的数据小于它。如下图所示：对元素2进行排序时，只要往前一直找，就可以将它插入合适的位置。插入排序基于数组很容易实现，原因在于我们可以很方便的找到每一个位置上的数据。但是链表不能这么做，原因在于很难直接去到每一个元素。结合链表的特点，我们可以设置一个虚拟的头节点，对于每一个节点，都要从该虚拟节点开始，一直到大于这个节点的数为止。 JAVA 代码实现/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode insertionSortList(ListNode head) { if(head==null) return head; ListNode dummy = new ListNode(0); ListNode pro = dummy; ListNode cur = head; while(cur!=null){ ListNode nex = cur.next; while(pro.next!=null&amp;&amp;pro.next.val&lt;cur.val) pro = pro.next; cur.next = pro.next; pro.next = cur; pro = dummy; cur = nex; } return dummy.next; } }]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 第149题 Max Points on a Line]]></title>
    <url>%2Fleetcode%20%E7%AC%AC149%E9%A2%98%20%20Max%20Points%20on%20a%20Line.html</url>
    <content type="text"><![CDATA[题目要求：给定2D平面上的n个点，找出位于同一条直线上的最大点数。 解决思路这个问题的一种方案是考虑两点之间斜率，把斜率相同的点放置在一个表中，再找到包含最多点的斜率。这个其中有两点需要关注，一个是点坐标的取值范围，一个是涉及斜率计算的问题。我的想法是对于每一个点，分别计算在它之后的所有不同点的斜率，并且用一个Map集合存起来，对于这个点，找出斜率最大的那个。考虑它的正确性，我们可以假设一种极端情况，即给定所有的点都在一条直线上，那么第一个点中肯定已经可以计算所要的结果，其他的点虽然能正常运行，但是同一个斜率得到结果肯定比第一个少。这里还要指出的是，斜率计算的问题，当横坐标相同时，用Integer.MAX_VALUE表示。考虑到Double运算可能会出现精度溢出情况，采用了BigDecimal类来计算精确结果。 java代码/** * Definition for a point. * class Point { * int x; * int y; * Point() { x = 0; y = 0; } * Point(int a, int b) { x = a; y = b; } * } */ class Solution { public int maxPoints(Point[] points) { int res = 1; if(points.length==0) return 0; for(int i =0;i&lt;points.length;i++){ HashMap&lt;Double,Integer&gt; hm = new HashMap&lt;&gt;(); hm.put((double) Integer.MIN_VALUE,1);//当points数组不空时，直线上必有一点 int de = 0; for(int j=i+1;j&lt;points.length;j++){ if((points[i].y==points[j].y)&amp;&amp;(points[i].x==points[j].x)){ de++; }else{ double tt = dis(points[i],points[j]); if(hm.containsKey(tt)) hm.put(tt,hm.get(tt)+1); else hm.put(tt,2); } } for(int re:hm.values()) res = Math.max(res, de+re); } return res; } public static double dis(Point p1, Point p2) { if((p1.x-p2.x)==0) return (double)Integer.MAX_VALUE; if(p1.y==p2.y) return 0; java.math.BigDecimal bd1 = new java.math.BigDecimal(Double.toString(p1.y-p2.y)); java.math.BigDecimal bd2 = new java.math.BigDecimal(Double.toString(p1.x-p2.x)); return bd1.divide (bd2,16,java.math.BigDecimal.ROUND_HALF_UP).doubleValue(); } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode Two Sum问题]]></title>
    <url>%2Fleetcode%20Two%20Sum%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[Two Sum I Two Sum II - Input array is sorted 第1题 Two Sum I题目要求: 给定一个整数数组，返回这两个数字的索引，使它们合计成一个特定的目标。限定条件：返回值为这两个数字的索引，索引从0开始假定每个输入都只有一个解，且不能使用相同的元素两次 解决思路由于数组有序，故采用对撞指针的方法。设置两个指针分别指向数组的头尾，当两个数的和大于给定的值时，右指针左移，小于时，左指针右移。这里需要注意的时，左指针必须小于右指针。 Java代码public int[] twoSum(int[] nums, int target) { int [] res = new int[2]; HashMap&lt;Integer,Integer&gt; tm = new HashMap&lt;&gt;(); for(int i =0;i&lt;nums.length;i++){ if(tm.containsKey(target - nums[i])){ res[0]=tm.get(target-nums[i]); res[1]=i; }else{ tm.put(nums[i],i); } } return res; } 第167题Two Sum II题目要求: 给定已按升序排序的整数数组，找到两个数字，使它们合计为特定的目标数字。 限定条件 返回值为这两个数字的索引，且该索引是从1开始 假定每个输入都只有一个解，且不能使用相同的元素两次 解决思路由于数组可能无序，且要返回的是元素的索引。所以我想到的办法是利用Set集合建立一个查找表，遍历整个数组，每次放入一个新元素时，在表中查找是否有target - nums[i]，如果存在则返回相应的索引，反之则继续遍历。 Java代码public int[] twoSum(int[] numbers, int target) { int[] arr = new int[2]; int l = 0,r = numbers.length-1; while(l&lt;r){ if(numbers[l]+numbers[r]&gt;target) r--; else if(numbers[l]+numbers[r]&lt;target) l++; else{ arr[0] = l+1; arr[1] = r+1; break; } } return arr; } 一些思考对比上述两个题目可以看出，需要解决的问题几乎一致，但是由于给定条件不一样，数组是否有序，导致解决问题的思路也不一样，一般来说，上述两种方法也是比较常见的。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode76题 Minimum Window Substring]]></title>
    <url>%2Fleetcode76%E9%A2%98%20Minimum%20Window%20Substring.html</url>
    <content type="text"><![CDATA[最小窗口子字符串 题目要求：给定一个字符串S和T，在S中找到一个包含T中所有字符的最短字串，时间复杂度为O(n).注1：如果这个窗口不存在，返回一个空字符串注2：该题保证在S中总是只有一个唯一的最小窗口 解决思路采用滑动窗口的方法，首先定义一个HashMap集合，用来记录T中字符出现的次数，同时定义一个计数变量来统计所得到的字符串是否包含T中所有的字符。具体做法为：当定义的滑动窗口的右指针不断向右滑动，找到包含T中所有字符的字串。然后通过控制窗口的滑动，尽可能的减少该字串的长度。 Java语言解决方案class Solution { public String minWindow(String s, String t) { if(s.length()&lt;t.length()) return &quot;&quot;; char[] ss = s.toCharArray(); char[] tt = t.toCharArray(); int count = t.length(); String res = &quot;&quot;; HashMap&lt;Character,Integer&gt; hm = new HashMap&lt;&gt;(); for(int i=0;i&lt;t.length();i++) if(hm.containsKey(tt[i])) hm.put(tt[i], hm.get(tt[i])+1); else hm.put(tt[i], 1); int l=0,r=0; while(r&lt;s.length()){ if(hm.containsKey(ss[r])){ if(hm.get(ss[r])&gt;0) count--; hm.put(ss[r], hm.get(ss[r])-1); } while(l&lt;=r&amp;&amp;count==0){ if(res.isEmpty()||res.length()&gt;(r-l+1)) res = s.substring(l,r+1); if(hm.containsKey(ss[l])){ hm.put(ss[l], hm.get(ss[l])+1); if(hm.get(ss[l])&gt;0) count++; } l++; } r++; } return res; } } 题目链接: https://leetcode.com/problems/minimum-window-substring/description/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法中时间复杂度分析]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E4%B8%AD%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[算法的时间复杂度表示算法运行所需要的时间 大O表示法 递归算法中时间复杂度分析 大O表示法大O表示法 是一种体现算法时间复杂度的记法，如果用n表示数据规模，那么O(f(n)表示算法说需要执行的指令数(消耗的时间)和 f(n) 成正比。大O表示法指出了算法执行的最低上限。(大O表示法的前边省略了一个常数)。 例子：有一个字符数组，将数组中的每一个字符串按照字母排序，再将整个字符串数组按照字典序排序求这个算法的时间复杂度。分析：假设每个字符串的最大长度是s，字符数组中一共有n个字符串。* 对于一个字符串来说，进行排序的复杂度是O(s*log s),则整个字符数组的复杂度是O(n*slog s)\ 对于整个字符串数组排序的复杂度是O(n*log n)，而进行字典排序时每次最多进行s次比较，每次比较都是常数时间，所以复杂度是O(s*nlog n)\ 综上：整个算法的复杂度是O(s*n*(log n +log s) 常见的大O阶有常数阶O(1)，线性阶O(n)，平方阶O(n²)，对数阶O(logn)，nlogn阶O(nlogn)等等。如果有在有相同规模的n，则只保留最高阶，如O(n+n²) = O(n²)。 线性阶随数据规模n线性增长。如下面的代码： for(int i=0;i&lt;n;i++){ //时间复杂度为O(1)的算法 ... } 对数阶接着看如下代码： int number=1; while(number&lt;n){ number=number*2; //时间复杂度为O(1)的算法 ... } 可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。 平方阶下面的代码是循环嵌套： for(int i=0;i&lt;n;i++){ for(int j=i;j&lt;n;j++){ //复杂度为O(1)的算法 ... } } 需要注意的是内循环中int j=i，而不是int j=0。当i=0时，内循环执行了n次；i=1时内循环执行了n-1次，当i=n-1时执行了1次，我可以推算出总的执行次数为： n+(n-1)+(n-2)+(n-3)+……+1 = n²/2+n/2 只保留最高阶，因此保留n²/2，并且去掉这个项的常数，1/2,最终这段代码的时间复杂度为O(n²)。 注意：1.以下代码的复杂度仍为O(n)，原因是只进行了30*n次基本操作。 for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;30;j++){ //复杂度为O(1)的算法 ... } } 2.以下代码的复杂度仍为O(n*log n)。 for(int i=1;i&lt;n;i +=i){ for(int j=0;j&lt;n;j++){ //复杂度为O(1)的算法 ... } } 以上充分说明，应该时刻关注数据规模，而不是一些形式上的类似。 递归算法中时间复杂度分析递归中进行一次递归调用如下图所示，该二分查找只进行了一次递归调用。每次调用的复杂度为O(1),递归深度为O(log n),故整个算法的复杂度为O(log n)。 一般来说,在递归函数中只递归一次递归调用，总体的复杂度为O(每个递归函数的时间复杂度*递归深度) 递归中进行多次递归调用此时应该关注的是调用次数，如下面代码所示：此时可以通过数递归树上的节点。比如当n=3时，它的递归树如下图 右半侧，更一般的结论如左半侧所示。 又比如，在归并排序中，排序的数据规模都会减少一半，所以递归深度时log n，但是每层进行排序的数据规模都是n,所以时间复杂度是O(n*log n).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断链表成环，且找出环的起点]]></title>
    <url>%2F%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%88%90%E7%8E%AF%EF%BC%8C%E4%B8%94%E6%89%BE%E5%87%BA%E7%8E%AF%E7%9A%84%E8%B5%B7%E7%82%B9.html</url>
    <content type="text"><![CDATA[判断链表成环，且找出环的起点。 判断链表成环 找出环的起点 Java代码实现 1. 判断链表是否成环 Floyd环判断法：从同一个起点同时开始以不同速度前进的2个指针最终相遇，那么可以判定存在一个环。 设想：乌龟和兔子在同一个环上赛跑，跑的快的兔子速度为2，跑的慢的乌龟速度为1，则兔子终会赶上乌龟。 理解：如果以乌龟为参考对象，则兔子前进的速度为1，这就意味着，兔子必将赶上乌龟。 所以一个判断成环的方法是：先舍子两个指针都指向表头，其中p1每次前进一个节点，p2每次前进两个节点，且p1和p2同时走，当p2指向的地址为null，就证明链表没有环。如果在某个时刻，p1和p2指向的地址相同，那么链表就是有环的。 2.找出环的起点同时可以进一步考虑：K1是等于零的，也就是p1在进入环后，走了不到一圈就在交点处和p2重合。因为p1在进入环的时候，p2和p1之间的距离（沿着行走方向）至多为 d2-1，不可能超过d2-1，因为环的大小也才只有d2 。p2追赶p1，最多只需要走d2-1步，因为每走一步，p1和p2的相对距离减小1，那么p1最多只走了d2-1步，就是最多只经过了d2-1个节点，不可能走完一圈。最后推出的式子的含义可以理解为：d1的长度 = 环长度的整数倍 + 交点与环入口的距离所以我们可以得出：当p1和p2相遇后，让p1回到原点，p2在相遇点，且两者每次都前进一个节点，当两者再次相遇时，就是环的起点。 3. Java代码实现int FindBeginLoop(ListNode head){ ListNode p1 = head, p2 = head; boolean loopExists = false; if(head == null) return false; //判断环是否存在 while(p2.getNext()!=null&amp;&amp;p2.getNext().getNext()!=null){ p1 = p1.getNext(); p2 = p2.getNext().getNext(); if(p1==p2) loopExists = true; break; } //如果环存在，寻找环的起点 if(loopExists){ p1 = head; while(p1!=p2){ p1 = p1.getNext(); p2 = p2.getNext(); } return p1; } return null; //不存在 } //附：定义的LitNode类 public class ListNode { private int data; private ListNode next; public ListNode(int data) { this.data = data; } public int getData() { return data; } public void setData(int data) { this.data = data; } public SingleListNode getNext() { return next; } public void setNext(SingleListNode next) { this.next = next; } } 参考http://www.cnblogs.com/snake-hand/p/3148328.html]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[搭建一个属于自己的博客 写在前面一直想搭建一个属于自己的博客，但都没有付诸行动，直到看见@嘟嘟独立博客所写的一列的hexo教程，终于开始动起来，花了一天的时间完成了这个过程。之后计划将自己以前写过的一些东西一点点搬运过来。 我的配置 hexo配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: 爱生活,爱柒柒 #网站标题subtitle: #网站副标题description: 且自前行，莫问归处！ #网站描述author: LI Ren #您的名字language: zh-Hans #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址## 如果您的网站存放在子目录中，##例如 http://yoursite.com/blog，##则将url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。url: https://myrens.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page## 修改归档页面、某一分类页面、某一标签页面的显示篇数## 参考：http://theme-next.iissnan.com/faqs.html#setting-page-sizearchive_generator: per_page: 10 yearly: false monthly: false daily: falsecategory_generator: per_page: 10tag_generator: per_page: 10 # Extensions## Plugins: https://hexo.io/plugins/# RSS，要先进入站点文件夹根目录安装插件# npm install hexo-generator-feed --save 即可# 无需更多配置# 参数说明查看 README：https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml# 文章数，0 为全部 limit: 0 hub:# 是否包含文章内容 content: true ##commnetdisqus_shortname: # MathJax Supportmathjax: enable: true cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML # Swiftype Search Keyswiftype_key: tLXWKdsstE5UZFCodRRQ # emoji 支持githubEmojis: enable: true idName: github-emoji unicode: false styles: localEmojis: # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:LLLRS/LLLRS.github.io.git,master next主题配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839# ===============================================================# ========================= ATTENTION! ==========================# ===============================================================# # Theme Core Configuration Settings# ---------------------------------------------------------------# Set to true, if you want to fully override the default configuration.# Useful if you don't want to inherit the theme _config.yml configurations.override: false# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# To get or check favicons visit: https://realfavicongenerator.net# Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.# Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.# And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.# 站点图标啦，直接去 https://realfavicongenerator.net# 选项弄好后，下载压缩包，解压复制粘贴# 建议放在 hexo-site/source/images/ 里（没有自己建）# 这样可以避免更新 NexT 主题的时候遇到麻烦# 最后记得要稍微改下文件名，与下面的保持一致favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg android_manifest: /images/manifest.json ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: "Hexo, NexT, Java, Spring, ssm"# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss:footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2015 # Icon between year and copyright info. icon: heart # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). # Hexo 的链接 powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.# 菜单设置 || 菜单图标设置（图标上面说了，不重复）# 项目换行可以更改显示顺序# 如果这个项前会显示 .menu# 解决方法：编辑 ~/blog/themes/next/languages 下的相应文件# 比如添加一个“留言”菜单，站点配置文件的 language 是 zh-Hans# 则编辑 zh-Hans.yml，在 menu: 项内添加一行 留言: 留言# 注意空格，且符号 : 为英文字符！menu: home: / || home archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/LLLRS|| github E-Mail: 15311257617@163.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true Github: github # Blog rollslinks_icon: linklinks_title: 友情链接links_layout: block#links_layout: inlinelinks: 嘟嘟独立博客: http://tengj.top/ crossoverjie: https://crossoverjie.top/ # Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gif#avatar: /images/avatar.gif# 侧栏头像设置# 圆形以及旋转效果在本文 4.2 节的代码里# 点击回到博客首页教程见本文 5.13 节# 建议放在 hexo-site/source/uploads/ 里（没有自己建）# 这样可以避免更新 NexT 主题的时候遇到麻烦avatar: /uploads/logo.jpeg# Table Of Contents in the Sidebar# 侧栏文章目录设置（前提是 Markdown 书写正确）toc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: true# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: true # Enable sidebar on narrow view (only for Muse | Mist). onmobile: true# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically saving scroll position on each post/page in cookies.save_scroll: false# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcount# 显示统计字数和估计阅读时长# 注意：这个要安装插件，先进入站点文件夹根目录# 然后：npm install hexo-wordcount --savepost_wordcount: item_text: true wordcount: true min2read: false totalcount: false separated_meta: false# Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg #description: ex. subscribe to my blog by scanning my public wechat account# Rewardreward_comment: 欢迎一起进行交流！wechatpay: /images/wechat.jpg#alipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($black-deep).android_chrome_color: "#222"# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: https://fonts.cat.net # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Lato size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: Roboto Slab size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: Roboto Mono size:# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML# Han Support docs: https://hanzi.pro/han: false# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortName#duoshuo_shortname:# Disqusdisqus: enable: false shortname: count: true# Hypercomments#hypercomments_id:# changyanchangyan: enable: false appid: appkey:# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.org# app_id: oilMyKSMaPtFHPbgcbiCfJL6-gzGzoHsz# app_key: oUBvV1jEzR3mJ3RvgWoHex8G valine: enable: true appid: oilMyKSMaPtFHPbgcbiCfJL6-gzGzoHsz appkey: oUBvV1jEzR3mJ3RvgWoHex8G notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# Share#duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: true postbottom: enable: true options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Bing Webmaster tools verification setting# See: https://www.bing.com/webmaster/#bing_site_verification:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: false admin_enable: false user_id: 0 #admin_nickname: Author# Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# ---------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.# 可以显示每篇文章的阅读量# 然后可以通过阅读量建立 TopX 页面，教程链接：# https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.htmlleancloud_visitors: enable: true app_id: oilMyKSMaPtFHPbgcbiCfJL6-gzGzoHsz app_key: oUBvV1jEzR3mJ3RvgWoHex8G# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/# 不蒜子统计，用于在页脚显示总访客数和总浏览量，将 false 改为 true 就能直接使用busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: false # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: false# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: true transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: fadeIn post_body: fadeIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancyboxfancybox: true# Progress bar in the top during page loading.# 页面顶部加载条pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-flash# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ # 自定义 fancybox（暂时） fancybox: https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js fancybox_css: https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: https://cdnjs.cloudflare.com/ajax/libs/UAParser.js/0.7.9/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.4 致谢感谢嘟嘟独立博客。感谢reuixiy,这篇文章记录的十分详细。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
